
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model KakaoAccount
 * 
 */
export type KakaoAccount = $Result.DefaultSelection<Prisma.$KakaoAccountPayload>
/**
 * Model UserPreference
 * 
 */
export type UserPreference = $Result.DefaultSelection<Prisma.$UserPreferencePayload>
/**
 * Model VerificationCode
 * 
 */
export type VerificationCode = $Result.DefaultSelection<Prisma.$VerificationCodePayload>
/**
 * Model UserAgreement
 * 
 */
export type UserAgreement = $Result.DefaultSelection<Prisma.$UserAgreementPayload>
/**
 * Model Challenge
 * 
 */
export type Challenge = $Result.DefaultSelection<Prisma.$ChallengePayload>
/**
 * Model ChallengeParticipant
 * 
 */
export type ChallengeParticipant = $Result.DefaultSelection<Prisma.$ChallengeParticipantPayload>
/**
 * Model ChallengeAvailableCafe
 * 
 */
export type ChallengeAvailableCafe = $Result.DefaultSelection<Prisma.$ChallengeAvailableCafePayload>
/**
 * Model BadgeType
 * 
 */
export type BadgeType = $Result.DefaultSelection<Prisma.$BadgeTypePayload>
/**
 * Model Badge
 * 
 */
export type Badge = $Result.DefaultSelection<Prisma.$BadgePayload>
/**
 * Model StampBook
 * 
 */
export type StampBook = $Result.DefaultSelection<Prisma.$StampBookPayload>
/**
 * Model Stamp
 * 
 */
export type Stamp = $Result.DefaultSelection<Prisma.$StampPayload>
/**
 * Model PointTransaction
 * 
 */
export type PointTransaction = $Result.DefaultSelection<Prisma.$PointTransactionPayload>
/**
 * Model Cafe
 * 
 */
export type Cafe = $Result.DefaultSelection<Prisma.$CafePayload>
/**
 * Model CafeMenu
 * 
 */
export type CafeMenu = $Result.DefaultSelection<Prisma.$CafeMenuPayload>
/**
 * Model CafePhoto
 * 
 */
export type CafePhoto = $Result.DefaultSelection<Prisma.$CafePhotoPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Coupon
 * 
 */
export type Coupon = $Result.DefaultSelection<Prisma.$CouponPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  CUSTOMER: 'CUSTOMER',
  OWNER: 'OWNER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const UserStatus: {
  active: 'active',
  inactive: 'inactive'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const CafeStatus: {
  active: 'active',
  inactive: 'inactive',
  deleted: 'deleted'
};

export type CafeStatus = (typeof CafeStatus)[keyof typeof CafeStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type CafeStatus = $Enums.CafeStatus

export const CafeStatus: typeof $Enums.CafeStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kakaoAccount`: Exposes CRUD operations for the **KakaoAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KakaoAccounts
    * const kakaoAccounts = await prisma.kakaoAccount.findMany()
    * ```
    */
  get kakaoAccount(): Prisma.KakaoAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPreference`: Exposes CRUD operations for the **UserPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPreferences
    * const userPreferences = await prisma.userPreference.findMany()
    * ```
    */
  get userPreference(): Prisma.UserPreferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationCode`: Exposes CRUD operations for the **VerificationCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationCodes
    * const verificationCodes = await prisma.verificationCode.findMany()
    * ```
    */
  get verificationCode(): Prisma.VerificationCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAgreement`: Exposes CRUD operations for the **UserAgreement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAgreements
    * const userAgreements = await prisma.userAgreement.findMany()
    * ```
    */
  get userAgreement(): Prisma.UserAgreementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challenge`: Exposes CRUD operations for the **Challenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Challenges
    * const challenges = await prisma.challenge.findMany()
    * ```
    */
  get challenge(): Prisma.ChallengeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeParticipant`: Exposes CRUD operations for the **ChallengeParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeParticipants
    * const challengeParticipants = await prisma.challengeParticipant.findMany()
    * ```
    */
  get challengeParticipant(): Prisma.ChallengeParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeAvailableCafe`: Exposes CRUD operations for the **ChallengeAvailableCafe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeAvailableCafes
    * const challengeAvailableCafes = await prisma.challengeAvailableCafe.findMany()
    * ```
    */
  get challengeAvailableCafe(): Prisma.ChallengeAvailableCafeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.badgeType`: Exposes CRUD operations for the **BadgeType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BadgeTypes
    * const badgeTypes = await prisma.badgeType.findMany()
    * ```
    */
  get badgeType(): Prisma.BadgeTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **Badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.BadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stampBook`: Exposes CRUD operations for the **StampBook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StampBooks
    * const stampBooks = await prisma.stampBook.findMany()
    * ```
    */
  get stampBook(): Prisma.StampBookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stamp`: Exposes CRUD operations for the **Stamp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stamps
    * const stamps = await prisma.stamp.findMany()
    * ```
    */
  get stamp(): Prisma.StampDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pointTransaction`: Exposes CRUD operations for the **PointTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PointTransactions
    * const pointTransactions = await prisma.pointTransaction.findMany()
    * ```
    */
  get pointTransaction(): Prisma.PointTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cafe`: Exposes CRUD operations for the **Cafe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cafes
    * const cafes = await prisma.cafe.findMany()
    * ```
    */
  get cafe(): Prisma.CafeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cafeMenu`: Exposes CRUD operations for the **CafeMenu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafeMenus
    * const cafeMenus = await prisma.cafeMenu.findMany()
    * ```
    */
  get cafeMenu(): Prisma.CafeMenuDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cafePhoto`: Exposes CRUD operations for the **CafePhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CafePhotos
    * const cafePhotos = await prisma.cafePhoto.findMany()
    * ```
    */
  get cafePhoto(): Prisma.CafePhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coupon`: Exposes CRUD operations for the **Coupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupon.findMany()
    * ```
    */
  get coupon(): Prisma.CouponDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    KakaoAccount: 'KakaoAccount',
    UserPreference: 'UserPreference',
    VerificationCode: 'VerificationCode',
    UserAgreement: 'UserAgreement',
    Challenge: 'Challenge',
    ChallengeParticipant: 'ChallengeParticipant',
    ChallengeAvailableCafe: 'ChallengeAvailableCafe',
    BadgeType: 'BadgeType',
    Badge: 'Badge',
    StampBook: 'StampBook',
    Stamp: 'Stamp',
    PointTransaction: 'PointTransaction',
    Cafe: 'Cafe',
    CafeMenu: 'CafeMenu',
    CafePhoto: 'CafePhoto',
    Review: 'Review',
    Notification: 'Notification',
    Coupon: 'Coupon'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "kakaoAccount" | "userPreference" | "verificationCode" | "userAgreement" | "challenge" | "challengeParticipant" | "challengeAvailableCafe" | "badgeType" | "badge" | "stampBook" | "stamp" | "pointTransaction" | "cafe" | "cafeMenu" | "cafePhoto" | "review" | "notification" | "coupon"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      KakaoAccount: {
        payload: Prisma.$KakaoAccountPayload<ExtArgs>
        fields: Prisma.KakaoAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KakaoAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KakaoAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KakaoAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KakaoAccountPayload>
          }
          findFirst: {
            args: Prisma.KakaoAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KakaoAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KakaoAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KakaoAccountPayload>
          }
          findMany: {
            args: Prisma.KakaoAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KakaoAccountPayload>[]
          }
          create: {
            args: Prisma.KakaoAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KakaoAccountPayload>
          }
          createMany: {
            args: Prisma.KakaoAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KakaoAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KakaoAccountPayload>[]
          }
          delete: {
            args: Prisma.KakaoAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KakaoAccountPayload>
          }
          update: {
            args: Prisma.KakaoAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KakaoAccountPayload>
          }
          deleteMany: {
            args: Prisma.KakaoAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KakaoAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KakaoAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KakaoAccountPayload>[]
          }
          upsert: {
            args: Prisma.KakaoAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KakaoAccountPayload>
          }
          aggregate: {
            args: Prisma.KakaoAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKakaoAccount>
          }
          groupBy: {
            args: Prisma.KakaoAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<KakaoAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.KakaoAccountCountArgs<ExtArgs>
            result: $Utils.Optional<KakaoAccountCountAggregateOutputType> | number
          }
        }
      }
      UserPreference: {
        payload: Prisma.$UserPreferencePayload<ExtArgs>
        fields: Prisma.UserPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          findFirst: {
            args: Prisma.UserPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          findMany: {
            args: Prisma.UserPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>[]
          }
          create: {
            args: Prisma.UserPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          createMany: {
            args: Prisma.UserPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>[]
          }
          delete: {
            args: Prisma.UserPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          update: {
            args: Prisma.UserPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          deleteMany: {
            args: Prisma.UserPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPreferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>[]
          }
          upsert: {
            args: Prisma.UserPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          aggregate: {
            args: Prisma.UserPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPreference>
          }
          groupBy: {
            args: Prisma.UserPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<UserPreferenceCountAggregateOutputType> | number
          }
        }
      }
      VerificationCode: {
        payload: Prisma.$VerificationCodePayload<ExtArgs>
        fields: Prisma.VerificationCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          findFirst: {
            args: Prisma.VerificationCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          findMany: {
            args: Prisma.VerificationCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>[]
          }
          create: {
            args: Prisma.VerificationCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          createMany: {
            args: Prisma.VerificationCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>[]
          }
          delete: {
            args: Prisma.VerificationCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          update: {
            args: Prisma.VerificationCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          deleteMany: {
            args: Prisma.VerificationCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>[]
          }
          upsert: {
            args: Prisma.VerificationCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          aggregate: {
            args: Prisma.VerificationCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationCode>
          }
          groupBy: {
            args: Prisma.VerificationCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCodeCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCodeCountAggregateOutputType> | number
          }
        }
      }
      UserAgreement: {
        payload: Prisma.$UserAgreementPayload<ExtArgs>
        fields: Prisma.UserAgreementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAgreementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAgreementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload>
          }
          findFirst: {
            args: Prisma.UserAgreementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAgreementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload>
          }
          findMany: {
            args: Prisma.UserAgreementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload>[]
          }
          create: {
            args: Prisma.UserAgreementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload>
          }
          createMany: {
            args: Prisma.UserAgreementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAgreementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload>[]
          }
          delete: {
            args: Prisma.UserAgreementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload>
          }
          update: {
            args: Prisma.UserAgreementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload>
          }
          deleteMany: {
            args: Prisma.UserAgreementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAgreementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAgreementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload>[]
          }
          upsert: {
            args: Prisma.UserAgreementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAgreementPayload>
          }
          aggregate: {
            args: Prisma.UserAgreementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAgreement>
          }
          groupBy: {
            args: Prisma.UserAgreementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAgreementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAgreementCountArgs<ExtArgs>
            result: $Utils.Optional<UserAgreementCountAggregateOutputType> | number
          }
        }
      }
      Challenge: {
        payload: Prisma.$ChallengePayload<ExtArgs>
        fields: Prisma.ChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          findFirst: {
            args: Prisma.ChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          findMany: {
            args: Prisma.ChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          create: {
            args: Prisma.ChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          createMany: {
            args: Prisma.ChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          delete: {
            args: Prisma.ChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          update: {
            args: Prisma.ChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          deleteMany: {
            args: Prisma.ChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          upsert: {
            args: Prisma.ChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          aggregate: {
            args: Prisma.ChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallenge>
          }
          groupBy: {
            args: Prisma.ChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeCountAggregateOutputType> | number
          }
        }
      }
      ChallengeParticipant: {
        payload: Prisma.$ChallengeParticipantPayload<ExtArgs>
        fields: Prisma.ChallengeParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>
          }
          findFirst: {
            args: Prisma.ChallengeParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>
          }
          findMany: {
            args: Prisma.ChallengeParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>[]
          }
          create: {
            args: Prisma.ChallengeParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>
          }
          createMany: {
            args: Prisma.ChallengeParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>[]
          }
          delete: {
            args: Prisma.ChallengeParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>
          }
          update: {
            args: Prisma.ChallengeParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>[]
          }
          upsert: {
            args: Prisma.ChallengeParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeParticipantPayload>
          }
          aggregate: {
            args: Prisma.ChallengeParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeParticipant>
          }
          groupBy: {
            args: Prisma.ChallengeParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeParticipantCountAggregateOutputType> | number
          }
        }
      }
      ChallengeAvailableCafe: {
        payload: Prisma.$ChallengeAvailableCafePayload<ExtArgs>
        fields: Prisma.ChallengeAvailableCafeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeAvailableCafeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAvailableCafePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeAvailableCafeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAvailableCafePayload>
          }
          findFirst: {
            args: Prisma.ChallengeAvailableCafeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAvailableCafePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeAvailableCafeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAvailableCafePayload>
          }
          findMany: {
            args: Prisma.ChallengeAvailableCafeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAvailableCafePayload>[]
          }
          create: {
            args: Prisma.ChallengeAvailableCafeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAvailableCafePayload>
          }
          createMany: {
            args: Prisma.ChallengeAvailableCafeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeAvailableCafeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAvailableCafePayload>[]
          }
          delete: {
            args: Prisma.ChallengeAvailableCafeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAvailableCafePayload>
          }
          update: {
            args: Prisma.ChallengeAvailableCafeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAvailableCafePayload>
          }
          deleteMany: {
            args: Prisma.ChallengeAvailableCafeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeAvailableCafeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeAvailableCafeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAvailableCafePayload>[]
          }
          upsert: {
            args: Prisma.ChallengeAvailableCafeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeAvailableCafePayload>
          }
          aggregate: {
            args: Prisma.ChallengeAvailableCafeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeAvailableCafe>
          }
          groupBy: {
            args: Prisma.ChallengeAvailableCafeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeAvailableCafeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeAvailableCafeCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeAvailableCafeCountAggregateOutputType> | number
          }
        }
      }
      BadgeType: {
        payload: Prisma.$BadgeTypePayload<ExtArgs>
        fields: Prisma.BadgeTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeTypePayload>
          }
          findFirst: {
            args: Prisma.BadgeTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeTypePayload>
          }
          findMany: {
            args: Prisma.BadgeTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeTypePayload>[]
          }
          create: {
            args: Prisma.BadgeTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeTypePayload>
          }
          createMany: {
            args: Prisma.BadgeTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgeTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeTypePayload>[]
          }
          delete: {
            args: Prisma.BadgeTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeTypePayload>
          }
          update: {
            args: Prisma.BadgeTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeTypePayload>
          }
          deleteMany: {
            args: Prisma.BadgeTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BadgeTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeTypePayload>[]
          }
          upsert: {
            args: Prisma.BadgeTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeTypePayload>
          }
          aggregate: {
            args: Prisma.BadgeTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadgeType>
          }
          groupBy: {
            args: Prisma.BadgeTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeTypeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeTypeCountAggregateOutputType> | number
          }
        }
      }
      Badge: {
        payload: Prisma.$BadgePayload<ExtArgs>
        fields: Prisma.BadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findFirst: {
            args: Prisma.BadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findMany: {
            args: Prisma.BadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          create: {
            args: Prisma.BadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          createMany: {
            args: Prisma.BadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          delete: {
            args: Prisma.BadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          update: {
            args: Prisma.BadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          deleteMany: {
            args: Prisma.BadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BadgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          upsert: {
            args: Prisma.BadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadge>
          }
          groupBy: {
            args: Prisma.BadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number
          }
        }
      }
      StampBook: {
        payload: Prisma.$StampBookPayload<ExtArgs>
        fields: Prisma.StampBookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StampBookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampBookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StampBookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampBookPayload>
          }
          findFirst: {
            args: Prisma.StampBookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampBookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StampBookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampBookPayload>
          }
          findMany: {
            args: Prisma.StampBookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampBookPayload>[]
          }
          create: {
            args: Prisma.StampBookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampBookPayload>
          }
          createMany: {
            args: Prisma.StampBookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StampBookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampBookPayload>[]
          }
          delete: {
            args: Prisma.StampBookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampBookPayload>
          }
          update: {
            args: Prisma.StampBookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampBookPayload>
          }
          deleteMany: {
            args: Prisma.StampBookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StampBookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StampBookUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampBookPayload>[]
          }
          upsert: {
            args: Prisma.StampBookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampBookPayload>
          }
          aggregate: {
            args: Prisma.StampBookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStampBook>
          }
          groupBy: {
            args: Prisma.StampBookGroupByArgs<ExtArgs>
            result: $Utils.Optional<StampBookGroupByOutputType>[]
          }
          count: {
            args: Prisma.StampBookCountArgs<ExtArgs>
            result: $Utils.Optional<StampBookCountAggregateOutputType> | number
          }
        }
      }
      Stamp: {
        payload: Prisma.$StampPayload<ExtArgs>
        fields: Prisma.StampFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StampFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StampFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampPayload>
          }
          findFirst: {
            args: Prisma.StampFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StampFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampPayload>
          }
          findMany: {
            args: Prisma.StampFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampPayload>[]
          }
          create: {
            args: Prisma.StampCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampPayload>
          }
          createMany: {
            args: Prisma.StampCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StampCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampPayload>[]
          }
          delete: {
            args: Prisma.StampDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampPayload>
          }
          update: {
            args: Prisma.StampUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampPayload>
          }
          deleteMany: {
            args: Prisma.StampDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StampUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StampUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampPayload>[]
          }
          upsert: {
            args: Prisma.StampUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StampPayload>
          }
          aggregate: {
            args: Prisma.StampAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStamp>
          }
          groupBy: {
            args: Prisma.StampGroupByArgs<ExtArgs>
            result: $Utils.Optional<StampGroupByOutputType>[]
          }
          count: {
            args: Prisma.StampCountArgs<ExtArgs>
            result: $Utils.Optional<StampCountAggregateOutputType> | number
          }
        }
      }
      PointTransaction: {
        payload: Prisma.$PointTransactionPayload<ExtArgs>
        fields: Prisma.PointTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PointTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PointTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          findFirst: {
            args: Prisma.PointTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PointTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          findMany: {
            args: Prisma.PointTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>[]
          }
          create: {
            args: Prisma.PointTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          createMany: {
            args: Prisma.PointTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PointTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>[]
          }
          delete: {
            args: Prisma.PointTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          update: {
            args: Prisma.PointTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          deleteMany: {
            args: Prisma.PointTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PointTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PointTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>[]
          }
          upsert: {
            args: Prisma.PointTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          aggregate: {
            args: Prisma.PointTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePointTransaction>
          }
          groupBy: {
            args: Prisma.PointTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PointTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PointTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<PointTransactionCountAggregateOutputType> | number
          }
        }
      }
      Cafe: {
        payload: Prisma.$CafePayload<ExtArgs>
        fields: Prisma.CafeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CafeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CafeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePayload>
          }
          findFirst: {
            args: Prisma.CafeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CafeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePayload>
          }
          findMany: {
            args: Prisma.CafeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePayload>[]
          }
          create: {
            args: Prisma.CafeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePayload>
          }
          createMany: {
            args: Prisma.CafeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CafeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePayload>[]
          }
          delete: {
            args: Prisma.CafeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePayload>
          }
          update: {
            args: Prisma.CafeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePayload>
          }
          deleteMany: {
            args: Prisma.CafeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CafeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CafeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePayload>[]
          }
          upsert: {
            args: Prisma.CafeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePayload>
          }
          aggregate: {
            args: Prisma.CafeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCafe>
          }
          groupBy: {
            args: Prisma.CafeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CafeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CafeCountArgs<ExtArgs>
            result: $Utils.Optional<CafeCountAggregateOutputType> | number
          }
        }
      }
      CafeMenu: {
        payload: Prisma.$CafeMenuPayload<ExtArgs>
        fields: Prisma.CafeMenuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CafeMenuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeMenuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CafeMenuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeMenuPayload>
          }
          findFirst: {
            args: Prisma.CafeMenuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeMenuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CafeMenuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeMenuPayload>
          }
          findMany: {
            args: Prisma.CafeMenuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeMenuPayload>[]
          }
          create: {
            args: Prisma.CafeMenuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeMenuPayload>
          }
          createMany: {
            args: Prisma.CafeMenuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CafeMenuCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeMenuPayload>[]
          }
          delete: {
            args: Prisma.CafeMenuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeMenuPayload>
          }
          update: {
            args: Prisma.CafeMenuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeMenuPayload>
          }
          deleteMany: {
            args: Prisma.CafeMenuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CafeMenuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CafeMenuUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeMenuPayload>[]
          }
          upsert: {
            args: Prisma.CafeMenuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafeMenuPayload>
          }
          aggregate: {
            args: Prisma.CafeMenuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCafeMenu>
          }
          groupBy: {
            args: Prisma.CafeMenuGroupByArgs<ExtArgs>
            result: $Utils.Optional<CafeMenuGroupByOutputType>[]
          }
          count: {
            args: Prisma.CafeMenuCountArgs<ExtArgs>
            result: $Utils.Optional<CafeMenuCountAggregateOutputType> | number
          }
        }
      }
      CafePhoto: {
        payload: Prisma.$CafePhotoPayload<ExtArgs>
        fields: Prisma.CafePhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CafePhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CafePhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePhotoPayload>
          }
          findFirst: {
            args: Prisma.CafePhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CafePhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePhotoPayload>
          }
          findMany: {
            args: Prisma.CafePhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePhotoPayload>[]
          }
          create: {
            args: Prisma.CafePhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePhotoPayload>
          }
          createMany: {
            args: Prisma.CafePhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CafePhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePhotoPayload>[]
          }
          delete: {
            args: Prisma.CafePhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePhotoPayload>
          }
          update: {
            args: Prisma.CafePhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePhotoPayload>
          }
          deleteMany: {
            args: Prisma.CafePhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CafePhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CafePhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePhotoPayload>[]
          }
          upsert: {
            args: Prisma.CafePhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CafePhotoPayload>
          }
          aggregate: {
            args: Prisma.CafePhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCafePhoto>
          }
          groupBy: {
            args: Prisma.CafePhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CafePhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CafePhotoCountArgs<ExtArgs>
            result: $Utils.Optional<CafePhotoCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Coupon: {
        payload: Prisma.$CouponPayload<ExtArgs>
        fields: Prisma.CouponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CouponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CouponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findFirst: {
            args: Prisma.CouponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CouponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findMany: {
            args: Prisma.CouponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          create: {
            args: Prisma.CouponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          createMany: {
            args: Prisma.CouponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CouponCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          delete: {
            args: Prisma.CouponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          update: {
            args: Prisma.CouponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          deleteMany: {
            args: Prisma.CouponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CouponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CouponUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          upsert: {
            args: Prisma.CouponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          aggregate: {
            args: Prisma.CouponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoupon>
          }
          groupBy: {
            args: Prisma.CouponGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponGroupByOutputType>[]
          }
          count: {
            args: Prisma.CouponCountArgs<ExtArgs>
            result: $Utils.Optional<CouponCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    kakaoAccount?: KakaoAccountOmit
    userPreference?: UserPreferenceOmit
    verificationCode?: VerificationCodeOmit
    userAgreement?: UserAgreementOmit
    challenge?: ChallengeOmit
    challengeParticipant?: ChallengeParticipantOmit
    challengeAvailableCafe?: ChallengeAvailableCafeOmit
    badgeType?: BadgeTypeOmit
    badge?: BadgeOmit
    stampBook?: StampBookOmit
    stamp?: StampOmit
    pointTransaction?: PointTransactionOmit
    cafe?: CafeOmit
    cafeMenu?: CafeMenuOmit
    cafePhoto?: CafePhotoOmit
    review?: ReviewOmit
    notification?: NotificationOmit
    coupon?: CouponOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    kakao_accounts: number
    user_preferences: number
    verification_codes: number
    challenge_participants: number
    badges: number
    stamp_books: number
    point_transactions: number
    reviews: number
    notifications: number
    coupons: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kakao_accounts?: boolean | UserCountOutputTypeCountKakao_accountsArgs
    user_preferences?: boolean | UserCountOutputTypeCountUser_preferencesArgs
    verification_codes?: boolean | UserCountOutputTypeCountVerification_codesArgs
    challenge_participants?: boolean | UserCountOutputTypeCountChallenge_participantsArgs
    badges?: boolean | UserCountOutputTypeCountBadgesArgs
    stamp_books?: boolean | UserCountOutputTypeCountStamp_booksArgs
    point_transactions?: boolean | UserCountOutputTypeCountPoint_transactionsArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    coupons?: boolean | UserCountOutputTypeCountCouponsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountKakao_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KakaoAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferenceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVerification_codesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationCodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChallenge_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStamp_booksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StampBookWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPoint_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
  }


  /**
   * Count Type ChallengeCountOutputType
   */

  export type ChallengeCountOutputType = {
    participants: number
    available_cafes: number
    badges: number
  }

  export type ChallengeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | ChallengeCountOutputTypeCountParticipantsArgs
    available_cafes?: boolean | ChallengeCountOutputTypeCountAvailable_cafesArgs
    badges?: boolean | ChallengeCountOutputTypeCountBadgesArgs
  }

  // Custom InputTypes
  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeCountOutputType
     */
    select?: ChallengeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeParticipantWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountAvailable_cafesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeAvailableCafeWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
  }


  /**
   * Count Type BadgeTypeCountOutputType
   */

  export type BadgeTypeCountOutputType = {
    badges: number
  }

  export type BadgeTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badges?: boolean | BadgeTypeCountOutputTypeCountBadgesArgs
  }

  // Custom InputTypes
  /**
   * BadgeTypeCountOutputType without action
   */
  export type BadgeTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeTypeCountOutputType
     */
    select?: BadgeTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgeTypeCountOutputType without action
   */
  export type BadgeTypeCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
  }


  /**
   * Count Type StampBookCountOutputType
   */

  export type StampBookCountOutputType = {
    stamps: number
    point_transactions: number
  }

  export type StampBookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stamps?: boolean | StampBookCountOutputTypeCountStampsArgs
    point_transactions?: boolean | StampBookCountOutputTypeCountPoint_transactionsArgs
  }

  // Custom InputTypes
  /**
   * StampBookCountOutputType without action
   */
  export type StampBookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StampBookCountOutputType
     */
    select?: StampBookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StampBookCountOutputType without action
   */
  export type StampBookCountOutputTypeCountStampsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StampWhereInput
  }

  /**
   * StampBookCountOutputType without action
   */
  export type StampBookCountOutputTypeCountPoint_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointTransactionWhereInput
  }


  /**
   * Count Type CafeCountOutputType
   */

  export type CafeCountOutputType = {
    menu: number
    photos: number
    available_challenges: number
    stamp_books: number
    reviews: number
    notifications: number
    coupons: number
  }

  export type CafeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu?: boolean | CafeCountOutputTypeCountMenuArgs
    photos?: boolean | CafeCountOutputTypeCountPhotosArgs
    available_challenges?: boolean | CafeCountOutputTypeCountAvailable_challengesArgs
    stamp_books?: boolean | CafeCountOutputTypeCountStamp_booksArgs
    reviews?: boolean | CafeCountOutputTypeCountReviewsArgs
    notifications?: boolean | CafeCountOutputTypeCountNotificationsArgs
    coupons?: boolean | CafeCountOutputTypeCountCouponsArgs
  }

  // Custom InputTypes
  /**
   * CafeCountOutputType without action
   */
  export type CafeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeCountOutputType
     */
    select?: CafeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CafeCountOutputType without action
   */
  export type CafeCountOutputTypeCountMenuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeMenuWhereInput
  }

  /**
   * CafeCountOutputType without action
   */
  export type CafeCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafePhotoWhereInput
  }

  /**
   * CafeCountOutputType without action
   */
  export type CafeCountOutputTypeCountAvailable_challengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeAvailableCafeWhereInput
  }

  /**
   * CafeCountOutputType without action
   */
  export type CafeCountOutputTypeCountStamp_booksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StampBookWhereInput
  }

  /**
   * CafeCountOutputType without action
   */
  export type CafeCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * CafeCountOutputType without action
   */
  export type CafeCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * CafeCountOutputType without action
   */
  export type CafeCountOutputTypeCountCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    kakao_id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: bigint | null
    kakao_id: bigint | null
  }

  export type UserMinAggregateOutputType = {
    id: bigint | null
    email: string | null
    kakao_id: bigint | null
    password_hash: string | null
    phone_number: string | null
    nickname: string | null
    role: $Enums.Role | null
    allow_kakao_alert: boolean | null
    status: $Enums.UserStatus | null
    fcm_token: string | null
    profile_image_url: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: bigint | null
    email: string | null
    kakao_id: bigint | null
    password_hash: string | null
    phone_number: string | null
    nickname: string | null
    role: $Enums.Role | null
    allow_kakao_alert: boolean | null
    status: $Enums.UserStatus | null
    fcm_token: string | null
    profile_image_url: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    kakao_id: number
    password_hash: number
    phone_number: number
    nickname: number
    role: number
    allow_kakao_alert: number
    status: number
    fcm_token: number
    profile_image_url: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    kakao_id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    kakao_id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    kakao_id?: true
    password_hash?: true
    phone_number?: true
    nickname?: true
    role?: true
    allow_kakao_alert?: true
    status?: true
    fcm_token?: true
    profile_image_url?: true
    created_at?: true
    updated_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    kakao_id?: true
    password_hash?: true
    phone_number?: true
    nickname?: true
    role?: true
    allow_kakao_alert?: true
    status?: true
    fcm_token?: true
    profile_image_url?: true
    created_at?: true
    updated_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    kakao_id?: true
    password_hash?: true
    phone_number?: true
    nickname?: true
    role?: true
    allow_kakao_alert?: true
    status?: true
    fcm_token?: true
    profile_image_url?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: bigint
    email: string | null
    kakao_id: bigint | null
    password_hash: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token: string | null
    profile_image_url: string | null
    created_at: Date
    updated_at: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    kakao_id?: boolean
    password_hash?: boolean
    phone_number?: boolean
    nickname?: boolean
    role?: boolean
    allow_kakao_alert?: boolean
    status?: boolean
    fcm_token?: boolean
    profile_image_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    kakao_accounts?: boolean | User$kakao_accountsArgs<ExtArgs>
    user_agreements?: boolean | User$user_agreementsArgs<ExtArgs>
    user_preferences?: boolean | User$user_preferencesArgs<ExtArgs>
    verification_codes?: boolean | User$verification_codesArgs<ExtArgs>
    challenge_participants?: boolean | User$challenge_participantsArgs<ExtArgs>
    badges?: boolean | User$badgesArgs<ExtArgs>
    stamp_books?: boolean | User$stamp_booksArgs<ExtArgs>
    point_transactions?: boolean | User$point_transactionsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    coupons?: boolean | User$couponsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    kakao_id?: boolean
    password_hash?: boolean
    phone_number?: boolean
    nickname?: boolean
    role?: boolean
    allow_kakao_alert?: boolean
    status?: boolean
    fcm_token?: boolean
    profile_image_url?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    kakao_id?: boolean
    password_hash?: boolean
    phone_number?: boolean
    nickname?: boolean
    role?: boolean
    allow_kakao_alert?: boolean
    status?: boolean
    fcm_token?: boolean
    profile_image_url?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    kakao_id?: boolean
    password_hash?: boolean
    phone_number?: boolean
    nickname?: boolean
    role?: boolean
    allow_kakao_alert?: boolean
    status?: boolean
    fcm_token?: boolean
    profile_image_url?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "kakao_id" | "password_hash" | "phone_number" | "nickname" | "role" | "allow_kakao_alert" | "status" | "fcm_token" | "profile_image_url" | "created_at" | "updated_at", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kakao_accounts?: boolean | User$kakao_accountsArgs<ExtArgs>
    user_agreements?: boolean | User$user_agreementsArgs<ExtArgs>
    user_preferences?: boolean | User$user_preferencesArgs<ExtArgs>
    verification_codes?: boolean | User$verification_codesArgs<ExtArgs>
    challenge_participants?: boolean | User$challenge_participantsArgs<ExtArgs>
    badges?: boolean | User$badgesArgs<ExtArgs>
    stamp_books?: boolean | User$stamp_booksArgs<ExtArgs>
    point_transactions?: boolean | User$point_transactionsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    coupons?: boolean | User$couponsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      kakao_accounts: Prisma.$KakaoAccountPayload<ExtArgs>[]
      user_agreements: Prisma.$UserAgreementPayload<ExtArgs> | null
      user_preferences: Prisma.$UserPreferencePayload<ExtArgs>[]
      verification_codes: Prisma.$VerificationCodePayload<ExtArgs>[]
      challenge_participants: Prisma.$ChallengeParticipantPayload<ExtArgs>[]
      badges: Prisma.$BadgePayload<ExtArgs>[]
      stamp_books: Prisma.$StampBookPayload<ExtArgs>[]
      point_transactions: Prisma.$PointTransactionPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      coupons: Prisma.$CouponPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      email: string | null
      kakao_id: bigint | null
      password_hash: string | null
      phone_number: string
      nickname: string
      role: $Enums.Role
      allow_kakao_alert: boolean
      status: $Enums.UserStatus
      fcm_token: string | null
      profile_image_url: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kakao_accounts<T extends User$kakao_accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$kakao_accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KakaoAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_agreements<T extends User$user_agreementsArgs<ExtArgs> = {}>(args?: Subset<T, User$user_agreementsArgs<ExtArgs>>): Prisma__UserAgreementClient<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user_preferences<T extends User$user_preferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$user_preferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verification_codes<T extends User$verification_codesArgs<ExtArgs> = {}>(args?: Subset<T, User$verification_codesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    challenge_participants<T extends User$challenge_participantsArgs<ExtArgs> = {}>(args?: Subset<T, User$challenge_participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    badges<T extends User$badgesArgs<ExtArgs> = {}>(args?: Subset<T, User$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stamp_books<T extends User$stamp_booksArgs<ExtArgs> = {}>(args?: Subset<T, User$stamp_booksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StampBookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    point_transactions<T extends User$point_transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$point_transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coupons<T extends User$couponsArgs<ExtArgs> = {}>(args?: Subset<T, User$couponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'BigInt'>
    readonly email: FieldRef<"User", 'String'>
    readonly kakao_id: FieldRef<"User", 'BigInt'>
    readonly password_hash: FieldRef<"User", 'String'>
    readonly phone_number: FieldRef<"User", 'String'>
    readonly nickname: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly allow_kakao_alert: FieldRef<"User", 'Boolean'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly fcm_token: FieldRef<"User", 'String'>
    readonly profile_image_url: FieldRef<"User", 'String'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.kakao_accounts
   */
  export type User$kakao_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KakaoAccount
     */
    select?: KakaoAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KakaoAccount
     */
    omit?: KakaoAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KakaoAccountInclude<ExtArgs> | null
    where?: KakaoAccountWhereInput
    orderBy?: KakaoAccountOrderByWithRelationInput | KakaoAccountOrderByWithRelationInput[]
    cursor?: KakaoAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KakaoAccountScalarFieldEnum | KakaoAccountScalarFieldEnum[]
  }

  /**
   * User.user_agreements
   */
  export type User$user_agreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAgreement
     */
    omit?: UserAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    where?: UserAgreementWhereInput
  }

  /**
   * User.user_preferences
   */
  export type User$user_preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    where?: UserPreferenceWhereInput
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    cursor?: UserPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPreferenceScalarFieldEnum | UserPreferenceScalarFieldEnum[]
  }

  /**
   * User.verification_codes
   */
  export type User$verification_codesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    where?: VerificationCodeWhereInput
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    cursor?: VerificationCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerificationCodeScalarFieldEnum | VerificationCodeScalarFieldEnum[]
  }

  /**
   * User.challenge_participants
   */
  export type User$challenge_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    where?: ChallengeParticipantWhereInput
    orderBy?: ChallengeParticipantOrderByWithRelationInput | ChallengeParticipantOrderByWithRelationInput[]
    cursor?: ChallengeParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeParticipantScalarFieldEnum | ChallengeParticipantScalarFieldEnum[]
  }

  /**
   * User.badges
   */
  export type User$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    cursor?: BadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * User.stamp_books
   */
  export type User$stamp_booksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StampBook
     */
    select?: StampBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StampBook
     */
    omit?: StampBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampBookInclude<ExtArgs> | null
    where?: StampBookWhereInput
    orderBy?: StampBookOrderByWithRelationInput | StampBookOrderByWithRelationInput[]
    cursor?: StampBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StampBookScalarFieldEnum | StampBookScalarFieldEnum[]
  }

  /**
   * User.point_transactions
   */
  export type User$point_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    where?: PointTransactionWhereInput
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    cursor?: PointTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PointTransactionScalarFieldEnum | PointTransactionScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.coupons
   */
  export type User$couponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    cursor?: CouponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model KakaoAccount
   */

  export type AggregateKakaoAccount = {
    _count: KakaoAccountCountAggregateOutputType | null
    _avg: KakaoAccountAvgAggregateOutputType | null
    _sum: KakaoAccountSumAggregateOutputType | null
    _min: KakaoAccountMinAggregateOutputType | null
    _max: KakaoAccountMaxAggregateOutputType | null
  }

  export type KakaoAccountAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type KakaoAccountSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
  }

  export type KakaoAccountMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    social_id: string | null
    created_at: Date | null
  }

  export type KakaoAccountMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    social_id: string | null
    created_at: Date | null
  }

  export type KakaoAccountCountAggregateOutputType = {
    id: number
    user_id: number
    social_id: number
    created_at: number
    _all: number
  }


  export type KakaoAccountAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type KakaoAccountSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type KakaoAccountMinAggregateInputType = {
    id?: true
    user_id?: true
    social_id?: true
    created_at?: true
  }

  export type KakaoAccountMaxAggregateInputType = {
    id?: true
    user_id?: true
    social_id?: true
    created_at?: true
  }

  export type KakaoAccountCountAggregateInputType = {
    id?: true
    user_id?: true
    social_id?: true
    created_at?: true
    _all?: true
  }

  export type KakaoAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KakaoAccount to aggregate.
     */
    where?: KakaoAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KakaoAccounts to fetch.
     */
    orderBy?: KakaoAccountOrderByWithRelationInput | KakaoAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KakaoAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KakaoAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KakaoAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KakaoAccounts
    **/
    _count?: true | KakaoAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KakaoAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KakaoAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KakaoAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KakaoAccountMaxAggregateInputType
  }

  export type GetKakaoAccountAggregateType<T extends KakaoAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateKakaoAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKakaoAccount[P]>
      : GetScalarType<T[P], AggregateKakaoAccount[P]>
  }




  export type KakaoAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KakaoAccountWhereInput
    orderBy?: KakaoAccountOrderByWithAggregationInput | KakaoAccountOrderByWithAggregationInput[]
    by: KakaoAccountScalarFieldEnum[] | KakaoAccountScalarFieldEnum
    having?: KakaoAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KakaoAccountCountAggregateInputType | true
    _avg?: KakaoAccountAvgAggregateInputType
    _sum?: KakaoAccountSumAggregateInputType
    _min?: KakaoAccountMinAggregateInputType
    _max?: KakaoAccountMaxAggregateInputType
  }

  export type KakaoAccountGroupByOutputType = {
    id: bigint
    user_id: bigint
    social_id: string
    created_at: Date
    _count: KakaoAccountCountAggregateOutputType | null
    _avg: KakaoAccountAvgAggregateOutputType | null
    _sum: KakaoAccountSumAggregateOutputType | null
    _min: KakaoAccountMinAggregateOutputType | null
    _max: KakaoAccountMaxAggregateOutputType | null
  }

  type GetKakaoAccountGroupByPayload<T extends KakaoAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KakaoAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KakaoAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KakaoAccountGroupByOutputType[P]>
            : GetScalarType<T[P], KakaoAccountGroupByOutputType[P]>
        }
      >
    >


  export type KakaoAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    social_id?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kakaoAccount"]>

  export type KakaoAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    social_id?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kakaoAccount"]>

  export type KakaoAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    social_id?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kakaoAccount"]>

  export type KakaoAccountSelectScalar = {
    id?: boolean
    user_id?: boolean
    social_id?: boolean
    created_at?: boolean
  }

  export type KakaoAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "social_id" | "created_at", ExtArgs["result"]["kakaoAccount"]>
  export type KakaoAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type KakaoAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type KakaoAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $KakaoAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KakaoAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint
      social_id: string
      created_at: Date
    }, ExtArgs["result"]["kakaoAccount"]>
    composites: {}
  }

  type KakaoAccountGetPayload<S extends boolean | null | undefined | KakaoAccountDefaultArgs> = $Result.GetResult<Prisma.$KakaoAccountPayload, S>

  type KakaoAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KakaoAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KakaoAccountCountAggregateInputType | true
    }

  export interface KakaoAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KakaoAccount'], meta: { name: 'KakaoAccount' } }
    /**
     * Find zero or one KakaoAccount that matches the filter.
     * @param {KakaoAccountFindUniqueArgs} args - Arguments to find a KakaoAccount
     * @example
     * // Get one KakaoAccount
     * const kakaoAccount = await prisma.kakaoAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KakaoAccountFindUniqueArgs>(args: SelectSubset<T, KakaoAccountFindUniqueArgs<ExtArgs>>): Prisma__KakaoAccountClient<$Result.GetResult<Prisma.$KakaoAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KakaoAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KakaoAccountFindUniqueOrThrowArgs} args - Arguments to find a KakaoAccount
     * @example
     * // Get one KakaoAccount
     * const kakaoAccount = await prisma.kakaoAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KakaoAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, KakaoAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KakaoAccountClient<$Result.GetResult<Prisma.$KakaoAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KakaoAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KakaoAccountFindFirstArgs} args - Arguments to find a KakaoAccount
     * @example
     * // Get one KakaoAccount
     * const kakaoAccount = await prisma.kakaoAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KakaoAccountFindFirstArgs>(args?: SelectSubset<T, KakaoAccountFindFirstArgs<ExtArgs>>): Prisma__KakaoAccountClient<$Result.GetResult<Prisma.$KakaoAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KakaoAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KakaoAccountFindFirstOrThrowArgs} args - Arguments to find a KakaoAccount
     * @example
     * // Get one KakaoAccount
     * const kakaoAccount = await prisma.kakaoAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KakaoAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, KakaoAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__KakaoAccountClient<$Result.GetResult<Prisma.$KakaoAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KakaoAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KakaoAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KakaoAccounts
     * const kakaoAccounts = await prisma.kakaoAccount.findMany()
     * 
     * // Get first 10 KakaoAccounts
     * const kakaoAccounts = await prisma.kakaoAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kakaoAccountWithIdOnly = await prisma.kakaoAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KakaoAccountFindManyArgs>(args?: SelectSubset<T, KakaoAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KakaoAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KakaoAccount.
     * @param {KakaoAccountCreateArgs} args - Arguments to create a KakaoAccount.
     * @example
     * // Create one KakaoAccount
     * const KakaoAccount = await prisma.kakaoAccount.create({
     *   data: {
     *     // ... data to create a KakaoAccount
     *   }
     * })
     * 
     */
    create<T extends KakaoAccountCreateArgs>(args: SelectSubset<T, KakaoAccountCreateArgs<ExtArgs>>): Prisma__KakaoAccountClient<$Result.GetResult<Prisma.$KakaoAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KakaoAccounts.
     * @param {KakaoAccountCreateManyArgs} args - Arguments to create many KakaoAccounts.
     * @example
     * // Create many KakaoAccounts
     * const kakaoAccount = await prisma.kakaoAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KakaoAccountCreateManyArgs>(args?: SelectSubset<T, KakaoAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KakaoAccounts and returns the data saved in the database.
     * @param {KakaoAccountCreateManyAndReturnArgs} args - Arguments to create many KakaoAccounts.
     * @example
     * // Create many KakaoAccounts
     * const kakaoAccount = await prisma.kakaoAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KakaoAccounts and only return the `id`
     * const kakaoAccountWithIdOnly = await prisma.kakaoAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KakaoAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, KakaoAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KakaoAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KakaoAccount.
     * @param {KakaoAccountDeleteArgs} args - Arguments to delete one KakaoAccount.
     * @example
     * // Delete one KakaoAccount
     * const KakaoAccount = await prisma.kakaoAccount.delete({
     *   where: {
     *     // ... filter to delete one KakaoAccount
     *   }
     * })
     * 
     */
    delete<T extends KakaoAccountDeleteArgs>(args: SelectSubset<T, KakaoAccountDeleteArgs<ExtArgs>>): Prisma__KakaoAccountClient<$Result.GetResult<Prisma.$KakaoAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KakaoAccount.
     * @param {KakaoAccountUpdateArgs} args - Arguments to update one KakaoAccount.
     * @example
     * // Update one KakaoAccount
     * const kakaoAccount = await prisma.kakaoAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KakaoAccountUpdateArgs>(args: SelectSubset<T, KakaoAccountUpdateArgs<ExtArgs>>): Prisma__KakaoAccountClient<$Result.GetResult<Prisma.$KakaoAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KakaoAccounts.
     * @param {KakaoAccountDeleteManyArgs} args - Arguments to filter KakaoAccounts to delete.
     * @example
     * // Delete a few KakaoAccounts
     * const { count } = await prisma.kakaoAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KakaoAccountDeleteManyArgs>(args?: SelectSubset<T, KakaoAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KakaoAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KakaoAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KakaoAccounts
     * const kakaoAccount = await prisma.kakaoAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KakaoAccountUpdateManyArgs>(args: SelectSubset<T, KakaoAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KakaoAccounts and returns the data updated in the database.
     * @param {KakaoAccountUpdateManyAndReturnArgs} args - Arguments to update many KakaoAccounts.
     * @example
     * // Update many KakaoAccounts
     * const kakaoAccount = await prisma.kakaoAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KakaoAccounts and only return the `id`
     * const kakaoAccountWithIdOnly = await prisma.kakaoAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KakaoAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, KakaoAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KakaoAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KakaoAccount.
     * @param {KakaoAccountUpsertArgs} args - Arguments to update or create a KakaoAccount.
     * @example
     * // Update or create a KakaoAccount
     * const kakaoAccount = await prisma.kakaoAccount.upsert({
     *   create: {
     *     // ... data to create a KakaoAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KakaoAccount we want to update
     *   }
     * })
     */
    upsert<T extends KakaoAccountUpsertArgs>(args: SelectSubset<T, KakaoAccountUpsertArgs<ExtArgs>>): Prisma__KakaoAccountClient<$Result.GetResult<Prisma.$KakaoAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KakaoAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KakaoAccountCountArgs} args - Arguments to filter KakaoAccounts to count.
     * @example
     * // Count the number of KakaoAccounts
     * const count = await prisma.kakaoAccount.count({
     *   where: {
     *     // ... the filter for the KakaoAccounts we want to count
     *   }
     * })
    **/
    count<T extends KakaoAccountCountArgs>(
      args?: Subset<T, KakaoAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KakaoAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KakaoAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KakaoAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KakaoAccountAggregateArgs>(args: Subset<T, KakaoAccountAggregateArgs>): Prisma.PrismaPromise<GetKakaoAccountAggregateType<T>>

    /**
     * Group by KakaoAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KakaoAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KakaoAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KakaoAccountGroupByArgs['orderBy'] }
        : { orderBy?: KakaoAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KakaoAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKakaoAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KakaoAccount model
   */
  readonly fields: KakaoAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KakaoAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KakaoAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KakaoAccount model
   */
  interface KakaoAccountFieldRefs {
    readonly id: FieldRef<"KakaoAccount", 'BigInt'>
    readonly user_id: FieldRef<"KakaoAccount", 'BigInt'>
    readonly social_id: FieldRef<"KakaoAccount", 'String'>
    readonly created_at: FieldRef<"KakaoAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KakaoAccount findUnique
   */
  export type KakaoAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KakaoAccount
     */
    select?: KakaoAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KakaoAccount
     */
    omit?: KakaoAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KakaoAccountInclude<ExtArgs> | null
    /**
     * Filter, which KakaoAccount to fetch.
     */
    where: KakaoAccountWhereUniqueInput
  }

  /**
   * KakaoAccount findUniqueOrThrow
   */
  export type KakaoAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KakaoAccount
     */
    select?: KakaoAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KakaoAccount
     */
    omit?: KakaoAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KakaoAccountInclude<ExtArgs> | null
    /**
     * Filter, which KakaoAccount to fetch.
     */
    where: KakaoAccountWhereUniqueInput
  }

  /**
   * KakaoAccount findFirst
   */
  export type KakaoAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KakaoAccount
     */
    select?: KakaoAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KakaoAccount
     */
    omit?: KakaoAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KakaoAccountInclude<ExtArgs> | null
    /**
     * Filter, which KakaoAccount to fetch.
     */
    where?: KakaoAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KakaoAccounts to fetch.
     */
    orderBy?: KakaoAccountOrderByWithRelationInput | KakaoAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KakaoAccounts.
     */
    cursor?: KakaoAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KakaoAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KakaoAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KakaoAccounts.
     */
    distinct?: KakaoAccountScalarFieldEnum | KakaoAccountScalarFieldEnum[]
  }

  /**
   * KakaoAccount findFirstOrThrow
   */
  export type KakaoAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KakaoAccount
     */
    select?: KakaoAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KakaoAccount
     */
    omit?: KakaoAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KakaoAccountInclude<ExtArgs> | null
    /**
     * Filter, which KakaoAccount to fetch.
     */
    where?: KakaoAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KakaoAccounts to fetch.
     */
    orderBy?: KakaoAccountOrderByWithRelationInput | KakaoAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KakaoAccounts.
     */
    cursor?: KakaoAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KakaoAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KakaoAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KakaoAccounts.
     */
    distinct?: KakaoAccountScalarFieldEnum | KakaoAccountScalarFieldEnum[]
  }

  /**
   * KakaoAccount findMany
   */
  export type KakaoAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KakaoAccount
     */
    select?: KakaoAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KakaoAccount
     */
    omit?: KakaoAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KakaoAccountInclude<ExtArgs> | null
    /**
     * Filter, which KakaoAccounts to fetch.
     */
    where?: KakaoAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KakaoAccounts to fetch.
     */
    orderBy?: KakaoAccountOrderByWithRelationInput | KakaoAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KakaoAccounts.
     */
    cursor?: KakaoAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KakaoAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KakaoAccounts.
     */
    skip?: number
    distinct?: KakaoAccountScalarFieldEnum | KakaoAccountScalarFieldEnum[]
  }

  /**
   * KakaoAccount create
   */
  export type KakaoAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KakaoAccount
     */
    select?: KakaoAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KakaoAccount
     */
    omit?: KakaoAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KakaoAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a KakaoAccount.
     */
    data: XOR<KakaoAccountCreateInput, KakaoAccountUncheckedCreateInput>
  }

  /**
   * KakaoAccount createMany
   */
  export type KakaoAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KakaoAccounts.
     */
    data: KakaoAccountCreateManyInput | KakaoAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KakaoAccount createManyAndReturn
   */
  export type KakaoAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KakaoAccount
     */
    select?: KakaoAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KakaoAccount
     */
    omit?: KakaoAccountOmit<ExtArgs> | null
    /**
     * The data used to create many KakaoAccounts.
     */
    data: KakaoAccountCreateManyInput | KakaoAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KakaoAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KakaoAccount update
   */
  export type KakaoAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KakaoAccount
     */
    select?: KakaoAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KakaoAccount
     */
    omit?: KakaoAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KakaoAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a KakaoAccount.
     */
    data: XOR<KakaoAccountUpdateInput, KakaoAccountUncheckedUpdateInput>
    /**
     * Choose, which KakaoAccount to update.
     */
    where: KakaoAccountWhereUniqueInput
  }

  /**
   * KakaoAccount updateMany
   */
  export type KakaoAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KakaoAccounts.
     */
    data: XOR<KakaoAccountUpdateManyMutationInput, KakaoAccountUncheckedUpdateManyInput>
    /**
     * Filter which KakaoAccounts to update
     */
    where?: KakaoAccountWhereInput
    /**
     * Limit how many KakaoAccounts to update.
     */
    limit?: number
  }

  /**
   * KakaoAccount updateManyAndReturn
   */
  export type KakaoAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KakaoAccount
     */
    select?: KakaoAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KakaoAccount
     */
    omit?: KakaoAccountOmit<ExtArgs> | null
    /**
     * The data used to update KakaoAccounts.
     */
    data: XOR<KakaoAccountUpdateManyMutationInput, KakaoAccountUncheckedUpdateManyInput>
    /**
     * Filter which KakaoAccounts to update
     */
    where?: KakaoAccountWhereInput
    /**
     * Limit how many KakaoAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KakaoAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KakaoAccount upsert
   */
  export type KakaoAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KakaoAccount
     */
    select?: KakaoAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KakaoAccount
     */
    omit?: KakaoAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KakaoAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the KakaoAccount to update in case it exists.
     */
    where: KakaoAccountWhereUniqueInput
    /**
     * In case the KakaoAccount found by the `where` argument doesn't exist, create a new KakaoAccount with this data.
     */
    create: XOR<KakaoAccountCreateInput, KakaoAccountUncheckedCreateInput>
    /**
     * In case the KakaoAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KakaoAccountUpdateInput, KakaoAccountUncheckedUpdateInput>
  }

  /**
   * KakaoAccount delete
   */
  export type KakaoAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KakaoAccount
     */
    select?: KakaoAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KakaoAccount
     */
    omit?: KakaoAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KakaoAccountInclude<ExtArgs> | null
    /**
     * Filter which KakaoAccount to delete.
     */
    where: KakaoAccountWhereUniqueInput
  }

  /**
   * KakaoAccount deleteMany
   */
  export type KakaoAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KakaoAccounts to delete
     */
    where?: KakaoAccountWhereInput
    /**
     * Limit how many KakaoAccounts to delete.
     */
    limit?: number
  }

  /**
   * KakaoAccount without action
   */
  export type KakaoAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KakaoAccount
     */
    select?: KakaoAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KakaoAccount
     */
    omit?: KakaoAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KakaoAccountInclude<ExtArgs> | null
  }


  /**
   * Model UserPreference
   */

  export type AggregateUserPreference = {
    _count: UserPreferenceCountAggregateOutputType | null
    _avg: UserPreferenceAvgAggregateOutputType | null
    _sum: UserPreferenceSumAggregateOutputType | null
    _min: UserPreferenceMinAggregateOutputType | null
    _max: UserPreferenceMaxAggregateOutputType | null
  }

  export type UserPreferenceAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type UserPreferenceSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
  }

  export type UserPreferenceMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    preferred_area: string | null
    created_at: Date | null
  }

  export type UserPreferenceMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    preferred_area: string | null
    created_at: Date | null
  }

  export type UserPreferenceCountAggregateOutputType = {
    id: number
    user_id: number
    preferred_area: number
    preferred_keywords: number
    created_at: number
    _all: number
  }


  export type UserPreferenceAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type UserPreferenceSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type UserPreferenceMinAggregateInputType = {
    id?: true
    user_id?: true
    preferred_area?: true
    created_at?: true
  }

  export type UserPreferenceMaxAggregateInputType = {
    id?: true
    user_id?: true
    preferred_area?: true
    created_at?: true
  }

  export type UserPreferenceCountAggregateInputType = {
    id?: true
    user_id?: true
    preferred_area?: true
    preferred_keywords?: true
    created_at?: true
    _all?: true
  }

  export type UserPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreference to aggregate.
     */
    where?: UserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPreferences
    **/
    _count?: true | UserPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPreferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPreferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPreferenceMaxAggregateInputType
  }

  export type GetUserPreferenceAggregateType<T extends UserPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPreference[P]>
      : GetScalarType<T[P], AggregateUserPreference[P]>
  }




  export type UserPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferenceWhereInput
    orderBy?: UserPreferenceOrderByWithAggregationInput | UserPreferenceOrderByWithAggregationInput[]
    by: UserPreferenceScalarFieldEnum[] | UserPreferenceScalarFieldEnum
    having?: UserPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPreferenceCountAggregateInputType | true
    _avg?: UserPreferenceAvgAggregateInputType
    _sum?: UserPreferenceSumAggregateInputType
    _min?: UserPreferenceMinAggregateInputType
    _max?: UserPreferenceMaxAggregateInputType
  }

  export type UserPreferenceGroupByOutputType = {
    id: bigint
    user_id: bigint
    preferred_area: string
    preferred_keywords: JsonValue
    created_at: Date
    _count: UserPreferenceCountAggregateOutputType | null
    _avg: UserPreferenceAvgAggregateOutputType | null
    _sum: UserPreferenceSumAggregateOutputType | null
    _min: UserPreferenceMinAggregateOutputType | null
    _max: UserPreferenceMaxAggregateOutputType | null
  }

  type GetUserPreferenceGroupByPayload<T extends UserPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], UserPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type UserPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    preferred_area?: boolean
    preferred_keywords?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreference"]>

  export type UserPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    preferred_area?: boolean
    preferred_keywords?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreference"]>

  export type UserPreferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    preferred_area?: boolean
    preferred_keywords?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreference"]>

  export type UserPreferenceSelectScalar = {
    id?: boolean
    user_id?: boolean
    preferred_area?: boolean
    preferred_keywords?: boolean
    created_at?: boolean
  }

  export type UserPreferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "preferred_area" | "preferred_keywords" | "created_at", ExtArgs["result"]["userPreference"]>
  export type UserPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint
      preferred_area: string
      preferred_keywords: Prisma.JsonValue
      created_at: Date
    }, ExtArgs["result"]["userPreference"]>
    composites: {}
  }

  type UserPreferenceGetPayload<S extends boolean | null | undefined | UserPreferenceDefaultArgs> = $Result.GetResult<Prisma.$UserPreferencePayload, S>

  type UserPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPreferenceCountAggregateInputType | true
    }

  export interface UserPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPreference'], meta: { name: 'UserPreference' } }
    /**
     * Find zero or one UserPreference that matches the filter.
     * @param {UserPreferenceFindUniqueArgs} args - Arguments to find a UserPreference
     * @example
     * // Get one UserPreference
     * const userPreference = await prisma.userPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPreferenceFindUniqueArgs>(args: SelectSubset<T, UserPreferenceFindUniqueArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPreferenceFindUniqueOrThrowArgs} args - Arguments to find a UserPreference
     * @example
     * // Get one UserPreference
     * const userPreference = await prisma.userPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceFindFirstArgs} args - Arguments to find a UserPreference
     * @example
     * // Get one UserPreference
     * const userPreference = await prisma.userPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPreferenceFindFirstArgs>(args?: SelectSubset<T, UserPreferenceFindFirstArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceFindFirstOrThrowArgs} args - Arguments to find a UserPreference
     * @example
     * // Get one UserPreference
     * const userPreference = await prisma.userPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPreferences
     * const userPreferences = await prisma.userPreference.findMany()
     * 
     * // Get first 10 UserPreferences
     * const userPreferences = await prisma.userPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPreferenceWithIdOnly = await prisma.userPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPreferenceFindManyArgs>(args?: SelectSubset<T, UserPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPreference.
     * @param {UserPreferenceCreateArgs} args - Arguments to create a UserPreference.
     * @example
     * // Create one UserPreference
     * const UserPreference = await prisma.userPreference.create({
     *   data: {
     *     // ... data to create a UserPreference
     *   }
     * })
     * 
     */
    create<T extends UserPreferenceCreateArgs>(args: SelectSubset<T, UserPreferenceCreateArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPreferences.
     * @param {UserPreferenceCreateManyArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreference = await prisma.userPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPreferenceCreateManyArgs>(args?: SelectSubset<T, UserPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPreferences and returns the data saved in the database.
     * @param {UserPreferenceCreateManyAndReturnArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreference = await prisma.userPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPreferences and only return the `id`
     * const userPreferenceWithIdOnly = await prisma.userPreference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPreference.
     * @param {UserPreferenceDeleteArgs} args - Arguments to delete one UserPreference.
     * @example
     * // Delete one UserPreference
     * const UserPreference = await prisma.userPreference.delete({
     *   where: {
     *     // ... filter to delete one UserPreference
     *   }
     * })
     * 
     */
    delete<T extends UserPreferenceDeleteArgs>(args: SelectSubset<T, UserPreferenceDeleteArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPreference.
     * @param {UserPreferenceUpdateArgs} args - Arguments to update one UserPreference.
     * @example
     * // Update one UserPreference
     * const userPreference = await prisma.userPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPreferenceUpdateArgs>(args: SelectSubset<T, UserPreferenceUpdateArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPreferences.
     * @param {UserPreferenceDeleteManyArgs} args - Arguments to filter UserPreferences to delete.
     * @example
     * // Delete a few UserPreferences
     * const { count } = await prisma.userPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPreferenceDeleteManyArgs>(args?: SelectSubset<T, UserPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPreferences
     * const userPreference = await prisma.userPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPreferenceUpdateManyArgs>(args: SelectSubset<T, UserPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences and returns the data updated in the database.
     * @param {UserPreferenceUpdateManyAndReturnArgs} args - Arguments to update many UserPreferences.
     * @example
     * // Update many UserPreferences
     * const userPreference = await prisma.userPreference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPreferences and only return the `id`
     * const userPreferenceWithIdOnly = await prisma.userPreference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPreferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPreferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPreference.
     * @param {UserPreferenceUpsertArgs} args - Arguments to update or create a UserPreference.
     * @example
     * // Update or create a UserPreference
     * const userPreference = await prisma.userPreference.upsert({
     *   create: {
     *     // ... data to create a UserPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPreference we want to update
     *   }
     * })
     */
    upsert<T extends UserPreferenceUpsertArgs>(args: SelectSubset<T, UserPreferenceUpsertArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceCountArgs} args - Arguments to filter UserPreferences to count.
     * @example
     * // Count the number of UserPreferences
     * const count = await prisma.userPreference.count({
     *   where: {
     *     // ... the filter for the UserPreferences we want to count
     *   }
     * })
    **/
    count<T extends UserPreferenceCountArgs>(
      args?: Subset<T, UserPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPreferenceAggregateArgs>(args: Subset<T, UserPreferenceAggregateArgs>): Prisma.PrismaPromise<GetUserPreferenceAggregateType<T>>

    /**
     * Group by UserPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: UserPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPreference model
   */
  readonly fields: UserPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPreference model
   */
  interface UserPreferenceFieldRefs {
    readonly id: FieldRef<"UserPreference", 'BigInt'>
    readonly user_id: FieldRef<"UserPreference", 'BigInt'>
    readonly preferred_area: FieldRef<"UserPreference", 'String'>
    readonly preferred_keywords: FieldRef<"UserPreference", 'Json'>
    readonly created_at: FieldRef<"UserPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPreference findUnique
   */
  export type UserPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreference to fetch.
     */
    where: UserPreferenceWhereUniqueInput
  }

  /**
   * UserPreference findUniqueOrThrow
   */
  export type UserPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreference to fetch.
     */
    where: UserPreferenceWhereUniqueInput
  }

  /**
   * UserPreference findFirst
   */
  export type UserPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreference to fetch.
     */
    where?: UserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferenceScalarFieldEnum | UserPreferenceScalarFieldEnum[]
  }

  /**
   * UserPreference findFirstOrThrow
   */
  export type UserPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreference to fetch.
     */
    where?: UserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferenceScalarFieldEnum | UserPreferenceScalarFieldEnum[]
  }

  /**
   * UserPreference findMany
   */
  export type UserPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPreferences.
     */
    cursor?: UserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    distinct?: UserPreferenceScalarFieldEnum | UserPreferenceScalarFieldEnum[]
  }

  /**
   * UserPreference create
   */
  export type UserPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPreference.
     */
    data: XOR<UserPreferenceCreateInput, UserPreferenceUncheckedCreateInput>
  }

  /**
   * UserPreference createMany
   */
  export type UserPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferenceCreateManyInput | UserPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPreference createManyAndReturn
   */
  export type UserPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferenceCreateManyInput | UserPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreference update
   */
  export type UserPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPreference.
     */
    data: XOR<UserPreferenceUpdateInput, UserPreferenceUncheckedUpdateInput>
    /**
     * Choose, which UserPreference to update.
     */
    where: UserPreferenceWhereUniqueInput
  }

  /**
   * UserPreference updateMany
   */
  export type UserPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferenceUpdateManyMutationInput, UserPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferenceWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
  }

  /**
   * UserPreference updateManyAndReturn
   */
  export type UserPreferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferenceUpdateManyMutationInput, UserPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferenceWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreference upsert
   */
  export type UserPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPreference to update in case it exists.
     */
    where: UserPreferenceWhereUniqueInput
    /**
     * In case the UserPreference found by the `where` argument doesn't exist, create a new UserPreference with this data.
     */
    create: XOR<UserPreferenceCreateInput, UserPreferenceUncheckedCreateInput>
    /**
     * In case the UserPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPreferenceUpdateInput, UserPreferenceUncheckedUpdateInput>
  }

  /**
   * UserPreference delete
   */
  export type UserPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter which UserPreference to delete.
     */
    where: UserPreferenceWhereUniqueInput
  }

  /**
   * UserPreference deleteMany
   */
  export type UserPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to delete
     */
    where?: UserPreferenceWhereInput
    /**
     * Limit how many UserPreferences to delete.
     */
    limit?: number
  }

  /**
   * UserPreference without action
   */
  export type UserPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model VerificationCode
   */

  export type AggregateVerificationCode = {
    _count: VerificationCodeCountAggregateOutputType | null
    _avg: VerificationCodeAvgAggregateOutputType | null
    _sum: VerificationCodeSumAggregateOutputType | null
    _min: VerificationCodeMinAggregateOutputType | null
    _max: VerificationCodeMaxAggregateOutputType | null
  }

  export type VerificationCodeAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type VerificationCodeSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
  }

  export type VerificationCodeMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    phone_number: string | null
    code: string | null
    expires_at: Date | null
    verified: boolean | null
    created_at: Date | null
  }

  export type VerificationCodeMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    phone_number: string | null
    code: string | null
    expires_at: Date | null
    verified: boolean | null
    created_at: Date | null
  }

  export type VerificationCodeCountAggregateOutputType = {
    id: number
    user_id: number
    phone_number: number
    code: number
    expires_at: number
    verified: number
    created_at: number
    _all: number
  }


  export type VerificationCodeAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type VerificationCodeSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type VerificationCodeMinAggregateInputType = {
    id?: true
    user_id?: true
    phone_number?: true
    code?: true
    expires_at?: true
    verified?: true
    created_at?: true
  }

  export type VerificationCodeMaxAggregateInputType = {
    id?: true
    user_id?: true
    phone_number?: true
    code?: true
    expires_at?: true
    verified?: true
    created_at?: true
  }

  export type VerificationCodeCountAggregateInputType = {
    id?: true
    user_id?: true
    phone_number?: true
    code?: true
    expires_at?: true
    verified?: true
    created_at?: true
    _all?: true
  }

  export type VerificationCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationCode to aggregate.
     */
    where?: VerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationCodes to fetch.
     */
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationCodes
    **/
    _count?: true | VerificationCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerificationCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerificationCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationCodeMaxAggregateInputType
  }

  export type GetVerificationCodeAggregateType<T extends VerificationCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationCode[P]>
      : GetScalarType<T[P], AggregateVerificationCode[P]>
  }




  export type VerificationCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationCodeWhereInput
    orderBy?: VerificationCodeOrderByWithAggregationInput | VerificationCodeOrderByWithAggregationInput[]
    by: VerificationCodeScalarFieldEnum[] | VerificationCodeScalarFieldEnum
    having?: VerificationCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCodeCountAggregateInputType | true
    _avg?: VerificationCodeAvgAggregateInputType
    _sum?: VerificationCodeSumAggregateInputType
    _min?: VerificationCodeMinAggregateInputType
    _max?: VerificationCodeMaxAggregateInputType
  }

  export type VerificationCodeGroupByOutputType = {
    id: bigint
    user_id: bigint | null
    phone_number: string
    code: string
    expires_at: Date
    verified: boolean
    created_at: Date
    _count: VerificationCodeCountAggregateOutputType | null
    _avg: VerificationCodeAvgAggregateOutputType | null
    _sum: VerificationCodeSumAggregateOutputType | null
    _min: VerificationCodeMinAggregateOutputType | null
    _max: VerificationCodeMaxAggregateOutputType | null
  }

  type GetVerificationCodeGroupByPayload<T extends VerificationCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationCodeGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationCodeGroupByOutputType[P]>
        }
      >
    >


  export type VerificationCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    phone_number?: boolean
    code?: boolean
    expires_at?: boolean
    verified?: boolean
    created_at?: boolean
    user?: boolean | VerificationCode$userArgs<ExtArgs>
  }, ExtArgs["result"]["verificationCode"]>

  export type VerificationCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    phone_number?: boolean
    code?: boolean
    expires_at?: boolean
    verified?: boolean
    created_at?: boolean
    user?: boolean | VerificationCode$userArgs<ExtArgs>
  }, ExtArgs["result"]["verificationCode"]>

  export type VerificationCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    phone_number?: boolean
    code?: boolean
    expires_at?: boolean
    verified?: boolean
    created_at?: boolean
    user?: boolean | VerificationCode$userArgs<ExtArgs>
  }, ExtArgs["result"]["verificationCode"]>

  export type VerificationCodeSelectScalar = {
    id?: boolean
    user_id?: boolean
    phone_number?: boolean
    code?: boolean
    expires_at?: boolean
    verified?: boolean
    created_at?: boolean
  }

  export type VerificationCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "phone_number" | "code" | "expires_at" | "verified" | "created_at", ExtArgs["result"]["verificationCode"]>
  export type VerificationCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | VerificationCode$userArgs<ExtArgs>
  }
  export type VerificationCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | VerificationCode$userArgs<ExtArgs>
  }
  export type VerificationCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | VerificationCode$userArgs<ExtArgs>
  }

  export type $VerificationCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationCode"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint | null
      phone_number: string
      code: string
      expires_at: Date
      verified: boolean
      created_at: Date
    }, ExtArgs["result"]["verificationCode"]>
    composites: {}
  }

  type VerificationCodeGetPayload<S extends boolean | null | undefined | VerificationCodeDefaultArgs> = $Result.GetResult<Prisma.$VerificationCodePayload, S>

  type VerificationCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCodeCountAggregateInputType | true
    }

  export interface VerificationCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationCode'], meta: { name: 'VerificationCode' } }
    /**
     * Find zero or one VerificationCode that matches the filter.
     * @param {VerificationCodeFindUniqueArgs} args - Arguments to find a VerificationCode
     * @example
     * // Get one VerificationCode
     * const verificationCode = await prisma.verificationCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationCodeFindUniqueArgs>(args: SelectSubset<T, VerificationCodeFindUniqueArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationCodeFindUniqueOrThrowArgs} args - Arguments to find a VerificationCode
     * @example
     * // Get one VerificationCode
     * const verificationCode = await prisma.verificationCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeFindFirstArgs} args - Arguments to find a VerificationCode
     * @example
     * // Get one VerificationCode
     * const verificationCode = await prisma.verificationCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationCodeFindFirstArgs>(args?: SelectSubset<T, VerificationCodeFindFirstArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeFindFirstOrThrowArgs} args - Arguments to find a VerificationCode
     * @example
     * // Get one VerificationCode
     * const verificationCode = await prisma.verificationCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationCodes
     * const verificationCodes = await prisma.verificationCode.findMany()
     * 
     * // Get first 10 VerificationCodes
     * const verificationCodes = await prisma.verificationCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationCodeWithIdOnly = await prisma.verificationCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationCodeFindManyArgs>(args?: SelectSubset<T, VerificationCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationCode.
     * @param {VerificationCodeCreateArgs} args - Arguments to create a VerificationCode.
     * @example
     * // Create one VerificationCode
     * const VerificationCode = await prisma.verificationCode.create({
     *   data: {
     *     // ... data to create a VerificationCode
     *   }
     * })
     * 
     */
    create<T extends VerificationCodeCreateArgs>(args: SelectSubset<T, VerificationCodeCreateArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationCodes.
     * @param {VerificationCodeCreateManyArgs} args - Arguments to create many VerificationCodes.
     * @example
     * // Create many VerificationCodes
     * const verificationCode = await prisma.verificationCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCodeCreateManyArgs>(args?: SelectSubset<T, VerificationCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationCodes and returns the data saved in the database.
     * @param {VerificationCodeCreateManyAndReturnArgs} args - Arguments to create many VerificationCodes.
     * @example
     * // Create many VerificationCodes
     * const verificationCode = await prisma.verificationCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationCodes and only return the `id`
     * const verificationCodeWithIdOnly = await prisma.verificationCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationCode.
     * @param {VerificationCodeDeleteArgs} args - Arguments to delete one VerificationCode.
     * @example
     * // Delete one VerificationCode
     * const VerificationCode = await prisma.verificationCode.delete({
     *   where: {
     *     // ... filter to delete one VerificationCode
     *   }
     * })
     * 
     */
    delete<T extends VerificationCodeDeleteArgs>(args: SelectSubset<T, VerificationCodeDeleteArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationCode.
     * @param {VerificationCodeUpdateArgs} args - Arguments to update one VerificationCode.
     * @example
     * // Update one VerificationCode
     * const verificationCode = await prisma.verificationCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationCodeUpdateArgs>(args: SelectSubset<T, VerificationCodeUpdateArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationCodes.
     * @param {VerificationCodeDeleteManyArgs} args - Arguments to filter VerificationCodes to delete.
     * @example
     * // Delete a few VerificationCodes
     * const { count } = await prisma.verificationCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationCodeDeleteManyArgs>(args?: SelectSubset<T, VerificationCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationCodes
     * const verificationCode = await prisma.verificationCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationCodeUpdateManyArgs>(args: SelectSubset<T, VerificationCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationCodes and returns the data updated in the database.
     * @param {VerificationCodeUpdateManyAndReturnArgs} args - Arguments to update many VerificationCodes.
     * @example
     * // Update many VerificationCodes
     * const verificationCode = await prisma.verificationCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationCodes and only return the `id`
     * const verificationCodeWithIdOnly = await prisma.verificationCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationCode.
     * @param {VerificationCodeUpsertArgs} args - Arguments to update or create a VerificationCode.
     * @example
     * // Update or create a VerificationCode
     * const verificationCode = await prisma.verificationCode.upsert({
     *   create: {
     *     // ... data to create a VerificationCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationCode we want to update
     *   }
     * })
     */
    upsert<T extends VerificationCodeUpsertArgs>(args: SelectSubset<T, VerificationCodeUpsertArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeCountArgs} args - Arguments to filter VerificationCodes to count.
     * @example
     * // Count the number of VerificationCodes
     * const count = await prisma.verificationCode.count({
     *   where: {
     *     // ... the filter for the VerificationCodes we want to count
     *   }
     * })
    **/
    count<T extends VerificationCodeCountArgs>(
      args?: Subset<T, VerificationCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationCodeAggregateArgs>(args: Subset<T, VerificationCodeAggregateArgs>): Prisma.PrismaPromise<GetVerificationCodeAggregateType<T>>

    /**
     * Group by VerificationCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationCodeGroupByArgs['orderBy'] }
        : { orderBy?: VerificationCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationCode model
   */
  readonly fields: VerificationCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends VerificationCode$userArgs<ExtArgs> = {}>(args?: Subset<T, VerificationCode$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationCode model
   */
  interface VerificationCodeFieldRefs {
    readonly id: FieldRef<"VerificationCode", 'BigInt'>
    readonly user_id: FieldRef<"VerificationCode", 'BigInt'>
    readonly phone_number: FieldRef<"VerificationCode", 'String'>
    readonly code: FieldRef<"VerificationCode", 'String'>
    readonly expires_at: FieldRef<"VerificationCode", 'DateTime'>
    readonly verified: FieldRef<"VerificationCode", 'Boolean'>
    readonly created_at: FieldRef<"VerificationCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationCode findUnique
   */
  export type VerificationCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * Filter, which VerificationCode to fetch.
     */
    where: VerificationCodeWhereUniqueInput
  }

  /**
   * VerificationCode findUniqueOrThrow
   */
  export type VerificationCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * Filter, which VerificationCode to fetch.
     */
    where: VerificationCodeWhereUniqueInput
  }

  /**
   * VerificationCode findFirst
   */
  export type VerificationCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * Filter, which VerificationCode to fetch.
     */
    where?: VerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationCodes to fetch.
     */
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationCodes.
     */
    cursor?: VerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationCodes.
     */
    distinct?: VerificationCodeScalarFieldEnum | VerificationCodeScalarFieldEnum[]
  }

  /**
   * VerificationCode findFirstOrThrow
   */
  export type VerificationCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * Filter, which VerificationCode to fetch.
     */
    where?: VerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationCodes to fetch.
     */
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationCodes.
     */
    cursor?: VerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationCodes.
     */
    distinct?: VerificationCodeScalarFieldEnum | VerificationCodeScalarFieldEnum[]
  }

  /**
   * VerificationCode findMany
   */
  export type VerificationCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * Filter, which VerificationCodes to fetch.
     */
    where?: VerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationCodes to fetch.
     */
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationCodes.
     */
    cursor?: VerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationCodes.
     */
    skip?: number
    distinct?: VerificationCodeScalarFieldEnum | VerificationCodeScalarFieldEnum[]
  }

  /**
   * VerificationCode create
   */
  export type VerificationCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a VerificationCode.
     */
    data: XOR<VerificationCodeCreateInput, VerificationCodeUncheckedCreateInput>
  }

  /**
   * VerificationCode createMany
   */
  export type VerificationCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationCodes.
     */
    data: VerificationCodeCreateManyInput | VerificationCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationCode createManyAndReturn
   */
  export type VerificationCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationCodes.
     */
    data: VerificationCodeCreateManyInput | VerificationCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerificationCode update
   */
  export type VerificationCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a VerificationCode.
     */
    data: XOR<VerificationCodeUpdateInput, VerificationCodeUncheckedUpdateInput>
    /**
     * Choose, which VerificationCode to update.
     */
    where: VerificationCodeWhereUniqueInput
  }

  /**
   * VerificationCode updateMany
   */
  export type VerificationCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationCodes.
     */
    data: XOR<VerificationCodeUpdateManyMutationInput, VerificationCodeUncheckedUpdateManyInput>
    /**
     * Filter which VerificationCodes to update
     */
    where?: VerificationCodeWhereInput
    /**
     * Limit how many VerificationCodes to update.
     */
    limit?: number
  }

  /**
   * VerificationCode updateManyAndReturn
   */
  export type VerificationCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * The data used to update VerificationCodes.
     */
    data: XOR<VerificationCodeUpdateManyMutationInput, VerificationCodeUncheckedUpdateManyInput>
    /**
     * Filter which VerificationCodes to update
     */
    where?: VerificationCodeWhereInput
    /**
     * Limit how many VerificationCodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerificationCode upsert
   */
  export type VerificationCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the VerificationCode to update in case it exists.
     */
    where: VerificationCodeWhereUniqueInput
    /**
     * In case the VerificationCode found by the `where` argument doesn't exist, create a new VerificationCode with this data.
     */
    create: XOR<VerificationCodeCreateInput, VerificationCodeUncheckedCreateInput>
    /**
     * In case the VerificationCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationCodeUpdateInput, VerificationCodeUncheckedUpdateInput>
  }

  /**
   * VerificationCode delete
   */
  export type VerificationCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
    /**
     * Filter which VerificationCode to delete.
     */
    where: VerificationCodeWhereUniqueInput
  }

  /**
   * VerificationCode deleteMany
   */
  export type VerificationCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationCodes to delete
     */
    where?: VerificationCodeWhereInput
    /**
     * Limit how many VerificationCodes to delete.
     */
    limit?: number
  }

  /**
   * VerificationCode.user
   */
  export type VerificationCode$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * VerificationCode without action
   */
  export type VerificationCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationCodeInclude<ExtArgs> | null
  }


  /**
   * Model UserAgreement
   */

  export type AggregateUserAgreement = {
    _count: UserAgreementCountAggregateOutputType | null
    _avg: UserAgreementAvgAggregateOutputType | null
    _sum: UserAgreementSumAggregateOutputType | null
    _min: UserAgreementMinAggregateOutputType | null
    _max: UserAgreementMaxAggregateOutputType | null
  }

  export type UserAgreementAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type UserAgreementSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
  }

  export type UserAgreementMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    terms_agreed: boolean | null
    privacy_policy_agreed: boolean | null
    marketing_agreed: boolean | null
    location_permission: boolean | null
    agreed_at: Date | null
  }

  export type UserAgreementMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    terms_agreed: boolean | null
    privacy_policy_agreed: boolean | null
    marketing_agreed: boolean | null
    location_permission: boolean | null
    agreed_at: Date | null
  }

  export type UserAgreementCountAggregateOutputType = {
    id: number
    user_id: number
    terms_agreed: number
    privacy_policy_agreed: number
    marketing_agreed: number
    location_permission: number
    agreed_at: number
    _all: number
  }


  export type UserAgreementAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type UserAgreementSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type UserAgreementMinAggregateInputType = {
    id?: true
    user_id?: true
    terms_agreed?: true
    privacy_policy_agreed?: true
    marketing_agreed?: true
    location_permission?: true
    agreed_at?: true
  }

  export type UserAgreementMaxAggregateInputType = {
    id?: true
    user_id?: true
    terms_agreed?: true
    privacy_policy_agreed?: true
    marketing_agreed?: true
    location_permission?: true
    agreed_at?: true
  }

  export type UserAgreementCountAggregateInputType = {
    id?: true
    user_id?: true
    terms_agreed?: true
    privacy_policy_agreed?: true
    marketing_agreed?: true
    location_permission?: true
    agreed_at?: true
    _all?: true
  }

  export type UserAgreementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAgreement to aggregate.
     */
    where?: UserAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAgreements to fetch.
     */
    orderBy?: UserAgreementOrderByWithRelationInput | UserAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAgreements
    **/
    _count?: true | UserAgreementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAgreementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAgreementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAgreementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAgreementMaxAggregateInputType
  }

  export type GetUserAgreementAggregateType<T extends UserAgreementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAgreement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAgreement[P]>
      : GetScalarType<T[P], AggregateUserAgreement[P]>
  }




  export type UserAgreementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAgreementWhereInput
    orderBy?: UserAgreementOrderByWithAggregationInput | UserAgreementOrderByWithAggregationInput[]
    by: UserAgreementScalarFieldEnum[] | UserAgreementScalarFieldEnum
    having?: UserAgreementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAgreementCountAggregateInputType | true
    _avg?: UserAgreementAvgAggregateInputType
    _sum?: UserAgreementSumAggregateInputType
    _min?: UserAgreementMinAggregateInputType
    _max?: UserAgreementMaxAggregateInputType
  }

  export type UserAgreementGroupByOutputType = {
    id: bigint
    user_id: bigint
    terms_agreed: boolean
    privacy_policy_agreed: boolean
    marketing_agreed: boolean
    location_permission: boolean
    agreed_at: Date
    _count: UserAgreementCountAggregateOutputType | null
    _avg: UserAgreementAvgAggregateOutputType | null
    _sum: UserAgreementSumAggregateOutputType | null
    _min: UserAgreementMinAggregateOutputType | null
    _max: UserAgreementMaxAggregateOutputType | null
  }

  type GetUserAgreementGroupByPayload<T extends UserAgreementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAgreementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAgreementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAgreementGroupByOutputType[P]>
            : GetScalarType<T[P], UserAgreementGroupByOutputType[P]>
        }
      >
    >


  export type UserAgreementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    terms_agreed?: boolean
    privacy_policy_agreed?: boolean
    marketing_agreed?: boolean
    location_permission?: boolean
    agreed_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAgreement"]>

  export type UserAgreementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    terms_agreed?: boolean
    privacy_policy_agreed?: boolean
    marketing_agreed?: boolean
    location_permission?: boolean
    agreed_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAgreement"]>

  export type UserAgreementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    terms_agreed?: boolean
    privacy_policy_agreed?: boolean
    marketing_agreed?: boolean
    location_permission?: boolean
    agreed_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAgreement"]>

  export type UserAgreementSelectScalar = {
    id?: boolean
    user_id?: boolean
    terms_agreed?: boolean
    privacy_policy_agreed?: boolean
    marketing_agreed?: boolean
    location_permission?: boolean
    agreed_at?: boolean
  }

  export type UserAgreementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "terms_agreed" | "privacy_policy_agreed" | "marketing_agreed" | "location_permission" | "agreed_at", ExtArgs["result"]["userAgreement"]>
  export type UserAgreementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAgreementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAgreementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserAgreementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAgreement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint
      terms_agreed: boolean
      privacy_policy_agreed: boolean
      marketing_agreed: boolean
      location_permission: boolean
      agreed_at: Date
    }, ExtArgs["result"]["userAgreement"]>
    composites: {}
  }

  type UserAgreementGetPayload<S extends boolean | null | undefined | UserAgreementDefaultArgs> = $Result.GetResult<Prisma.$UserAgreementPayload, S>

  type UserAgreementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAgreementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAgreementCountAggregateInputType | true
    }

  export interface UserAgreementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAgreement'], meta: { name: 'UserAgreement' } }
    /**
     * Find zero or one UserAgreement that matches the filter.
     * @param {UserAgreementFindUniqueArgs} args - Arguments to find a UserAgreement
     * @example
     * // Get one UserAgreement
     * const userAgreement = await prisma.userAgreement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAgreementFindUniqueArgs>(args: SelectSubset<T, UserAgreementFindUniqueArgs<ExtArgs>>): Prisma__UserAgreementClient<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAgreement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAgreementFindUniqueOrThrowArgs} args - Arguments to find a UserAgreement
     * @example
     * // Get one UserAgreement
     * const userAgreement = await prisma.userAgreement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAgreementFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAgreementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAgreementClient<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAgreement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAgreementFindFirstArgs} args - Arguments to find a UserAgreement
     * @example
     * // Get one UserAgreement
     * const userAgreement = await prisma.userAgreement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAgreementFindFirstArgs>(args?: SelectSubset<T, UserAgreementFindFirstArgs<ExtArgs>>): Prisma__UserAgreementClient<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAgreement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAgreementFindFirstOrThrowArgs} args - Arguments to find a UserAgreement
     * @example
     * // Get one UserAgreement
     * const userAgreement = await prisma.userAgreement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAgreementFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAgreementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAgreementClient<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAgreements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAgreementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAgreements
     * const userAgreements = await prisma.userAgreement.findMany()
     * 
     * // Get first 10 UserAgreements
     * const userAgreements = await prisma.userAgreement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAgreementWithIdOnly = await prisma.userAgreement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAgreementFindManyArgs>(args?: SelectSubset<T, UserAgreementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAgreement.
     * @param {UserAgreementCreateArgs} args - Arguments to create a UserAgreement.
     * @example
     * // Create one UserAgreement
     * const UserAgreement = await prisma.userAgreement.create({
     *   data: {
     *     // ... data to create a UserAgreement
     *   }
     * })
     * 
     */
    create<T extends UserAgreementCreateArgs>(args: SelectSubset<T, UserAgreementCreateArgs<ExtArgs>>): Prisma__UserAgreementClient<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAgreements.
     * @param {UserAgreementCreateManyArgs} args - Arguments to create many UserAgreements.
     * @example
     * // Create many UserAgreements
     * const userAgreement = await prisma.userAgreement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAgreementCreateManyArgs>(args?: SelectSubset<T, UserAgreementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAgreements and returns the data saved in the database.
     * @param {UserAgreementCreateManyAndReturnArgs} args - Arguments to create many UserAgreements.
     * @example
     * // Create many UserAgreements
     * const userAgreement = await prisma.userAgreement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAgreements and only return the `id`
     * const userAgreementWithIdOnly = await prisma.userAgreement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAgreementCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAgreementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAgreement.
     * @param {UserAgreementDeleteArgs} args - Arguments to delete one UserAgreement.
     * @example
     * // Delete one UserAgreement
     * const UserAgreement = await prisma.userAgreement.delete({
     *   where: {
     *     // ... filter to delete one UserAgreement
     *   }
     * })
     * 
     */
    delete<T extends UserAgreementDeleteArgs>(args: SelectSubset<T, UserAgreementDeleteArgs<ExtArgs>>): Prisma__UserAgreementClient<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAgreement.
     * @param {UserAgreementUpdateArgs} args - Arguments to update one UserAgreement.
     * @example
     * // Update one UserAgreement
     * const userAgreement = await prisma.userAgreement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAgreementUpdateArgs>(args: SelectSubset<T, UserAgreementUpdateArgs<ExtArgs>>): Prisma__UserAgreementClient<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAgreements.
     * @param {UserAgreementDeleteManyArgs} args - Arguments to filter UserAgreements to delete.
     * @example
     * // Delete a few UserAgreements
     * const { count } = await prisma.userAgreement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAgreementDeleteManyArgs>(args?: SelectSubset<T, UserAgreementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAgreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAgreementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAgreements
     * const userAgreement = await prisma.userAgreement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAgreementUpdateManyArgs>(args: SelectSubset<T, UserAgreementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAgreements and returns the data updated in the database.
     * @param {UserAgreementUpdateManyAndReturnArgs} args - Arguments to update many UserAgreements.
     * @example
     * // Update many UserAgreements
     * const userAgreement = await prisma.userAgreement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAgreements and only return the `id`
     * const userAgreementWithIdOnly = await prisma.userAgreement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAgreementUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAgreementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAgreement.
     * @param {UserAgreementUpsertArgs} args - Arguments to update or create a UserAgreement.
     * @example
     * // Update or create a UserAgreement
     * const userAgreement = await prisma.userAgreement.upsert({
     *   create: {
     *     // ... data to create a UserAgreement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAgreement we want to update
     *   }
     * })
     */
    upsert<T extends UserAgreementUpsertArgs>(args: SelectSubset<T, UserAgreementUpsertArgs<ExtArgs>>): Prisma__UserAgreementClient<$Result.GetResult<Prisma.$UserAgreementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAgreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAgreementCountArgs} args - Arguments to filter UserAgreements to count.
     * @example
     * // Count the number of UserAgreements
     * const count = await prisma.userAgreement.count({
     *   where: {
     *     // ... the filter for the UserAgreements we want to count
     *   }
     * })
    **/
    count<T extends UserAgreementCountArgs>(
      args?: Subset<T, UserAgreementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAgreementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAgreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAgreementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAgreementAggregateArgs>(args: Subset<T, UserAgreementAggregateArgs>): Prisma.PrismaPromise<GetUserAgreementAggregateType<T>>

    /**
     * Group by UserAgreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAgreementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAgreementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAgreementGroupByArgs['orderBy'] }
        : { orderBy?: UserAgreementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAgreementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAgreementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAgreement model
   */
  readonly fields: UserAgreementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAgreement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAgreementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAgreement model
   */
  interface UserAgreementFieldRefs {
    readonly id: FieldRef<"UserAgreement", 'BigInt'>
    readonly user_id: FieldRef<"UserAgreement", 'BigInt'>
    readonly terms_agreed: FieldRef<"UserAgreement", 'Boolean'>
    readonly privacy_policy_agreed: FieldRef<"UserAgreement", 'Boolean'>
    readonly marketing_agreed: FieldRef<"UserAgreement", 'Boolean'>
    readonly location_permission: FieldRef<"UserAgreement", 'Boolean'>
    readonly agreed_at: FieldRef<"UserAgreement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAgreement findUnique
   */
  export type UserAgreementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAgreement
     */
    omit?: UserAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    /**
     * Filter, which UserAgreement to fetch.
     */
    where: UserAgreementWhereUniqueInput
  }

  /**
   * UserAgreement findUniqueOrThrow
   */
  export type UserAgreementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAgreement
     */
    omit?: UserAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    /**
     * Filter, which UserAgreement to fetch.
     */
    where: UserAgreementWhereUniqueInput
  }

  /**
   * UserAgreement findFirst
   */
  export type UserAgreementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAgreement
     */
    omit?: UserAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    /**
     * Filter, which UserAgreement to fetch.
     */
    where?: UserAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAgreements to fetch.
     */
    orderBy?: UserAgreementOrderByWithRelationInput | UserAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAgreements.
     */
    cursor?: UserAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAgreements.
     */
    distinct?: UserAgreementScalarFieldEnum | UserAgreementScalarFieldEnum[]
  }

  /**
   * UserAgreement findFirstOrThrow
   */
  export type UserAgreementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAgreement
     */
    omit?: UserAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    /**
     * Filter, which UserAgreement to fetch.
     */
    where?: UserAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAgreements to fetch.
     */
    orderBy?: UserAgreementOrderByWithRelationInput | UserAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAgreements.
     */
    cursor?: UserAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAgreements.
     */
    distinct?: UserAgreementScalarFieldEnum | UserAgreementScalarFieldEnum[]
  }

  /**
   * UserAgreement findMany
   */
  export type UserAgreementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAgreement
     */
    omit?: UserAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    /**
     * Filter, which UserAgreements to fetch.
     */
    where?: UserAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAgreements to fetch.
     */
    orderBy?: UserAgreementOrderByWithRelationInput | UserAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAgreements.
     */
    cursor?: UserAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAgreements.
     */
    skip?: number
    distinct?: UserAgreementScalarFieldEnum | UserAgreementScalarFieldEnum[]
  }

  /**
   * UserAgreement create
   */
  export type UserAgreementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAgreement
     */
    omit?: UserAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAgreement.
     */
    data: XOR<UserAgreementCreateInput, UserAgreementUncheckedCreateInput>
  }

  /**
   * UserAgreement createMany
   */
  export type UserAgreementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAgreements.
     */
    data: UserAgreementCreateManyInput | UserAgreementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAgreement createManyAndReturn
   */
  export type UserAgreementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAgreement
     */
    omit?: UserAgreementOmit<ExtArgs> | null
    /**
     * The data used to create many UserAgreements.
     */
    data: UserAgreementCreateManyInput | UserAgreementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAgreement update
   */
  export type UserAgreementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAgreement
     */
    omit?: UserAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAgreement.
     */
    data: XOR<UserAgreementUpdateInput, UserAgreementUncheckedUpdateInput>
    /**
     * Choose, which UserAgreement to update.
     */
    where: UserAgreementWhereUniqueInput
  }

  /**
   * UserAgreement updateMany
   */
  export type UserAgreementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAgreements.
     */
    data: XOR<UserAgreementUpdateManyMutationInput, UserAgreementUncheckedUpdateManyInput>
    /**
     * Filter which UserAgreements to update
     */
    where?: UserAgreementWhereInput
    /**
     * Limit how many UserAgreements to update.
     */
    limit?: number
  }

  /**
   * UserAgreement updateManyAndReturn
   */
  export type UserAgreementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAgreement
     */
    omit?: UserAgreementOmit<ExtArgs> | null
    /**
     * The data used to update UserAgreements.
     */
    data: XOR<UserAgreementUpdateManyMutationInput, UserAgreementUncheckedUpdateManyInput>
    /**
     * Filter which UserAgreements to update
     */
    where?: UserAgreementWhereInput
    /**
     * Limit how many UserAgreements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAgreement upsert
   */
  export type UserAgreementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAgreement
     */
    omit?: UserAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAgreement to update in case it exists.
     */
    where: UserAgreementWhereUniqueInput
    /**
     * In case the UserAgreement found by the `where` argument doesn't exist, create a new UserAgreement with this data.
     */
    create: XOR<UserAgreementCreateInput, UserAgreementUncheckedCreateInput>
    /**
     * In case the UserAgreement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAgreementUpdateInput, UserAgreementUncheckedUpdateInput>
  }

  /**
   * UserAgreement delete
   */
  export type UserAgreementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAgreement
     */
    omit?: UserAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
    /**
     * Filter which UserAgreement to delete.
     */
    where: UserAgreementWhereUniqueInput
  }

  /**
   * UserAgreement deleteMany
   */
  export type UserAgreementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAgreements to delete
     */
    where?: UserAgreementWhereInput
    /**
     * Limit how many UserAgreements to delete.
     */
    limit?: number
  }

  /**
   * UserAgreement without action
   */
  export type UserAgreementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAgreement
     */
    select?: UserAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAgreement
     */
    omit?: UserAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAgreementInclude<ExtArgs> | null
  }


  /**
   * Model Challenge
   */

  export type AggregateChallenge = {
    _count: ChallengeCountAggregateOutputType | null
    _avg: ChallengeAvgAggregateOutputType | null
    _sum: ChallengeSumAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  export type ChallengeAvgAggregateOutputType = {
    id: number | null
  }

  export type ChallengeSumAggregateOutputType = {
    id: number | null
  }

  export type ChallengeMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    thumbnail_url: string | null
    start_date: Date | null
    end_date: Date | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChallengeMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    thumbnail_url: string | null
    start_date: Date | null
    end_date: Date | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChallengeCountAggregateOutputType = {
    id: number
    title: number
    description: number
    thumbnail_url: number
    start_date: number
    end_date: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ChallengeAvgAggregateInputType = {
    id?: true
  }

  export type ChallengeSumAggregateInputType = {
    id?: true
  }

  export type ChallengeMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail_url?: true
    start_date?: true
    end_date?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type ChallengeMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail_url?: true
    start_date?: true
    end_date?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type ChallengeCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail_url?: true
    start_date?: true
    end_date?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Challenge to aggregate.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Challenges
    **/
    _count?: true | ChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeMaxAggregateInputType
  }

  export type GetChallengeAggregateType<T extends ChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallenge[P]>
      : GetScalarType<T[P], AggregateChallenge[P]>
  }




  export type ChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWhereInput
    orderBy?: ChallengeOrderByWithAggregationInput | ChallengeOrderByWithAggregationInput[]
    by: ChallengeScalarFieldEnum[] | ChallengeScalarFieldEnum
    having?: ChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeCountAggregateInputType | true
    _avg?: ChallengeAvgAggregateInputType
    _sum?: ChallengeSumAggregateInputType
    _min?: ChallengeMinAggregateInputType
    _max?: ChallengeMaxAggregateInputType
  }

  export type ChallengeGroupByOutputType = {
    id: number
    title: string
    description: string
    thumbnail_url: string
    start_date: Date
    end_date: Date
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: ChallengeCountAggregateOutputType | null
    _avg: ChallengeAvgAggregateOutputType | null
    _sum: ChallengeSumAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  type GetChallengeGroupByPayload<T extends ChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail_url?: boolean
    start_date?: boolean
    end_date?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    participants?: boolean | Challenge$participantsArgs<ExtArgs>
    available_cafes?: boolean | Challenge$available_cafesArgs<ExtArgs>
    badges?: boolean | Challenge$badgesArgs<ExtArgs>
    _count?: boolean | ChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail_url?: boolean
    start_date?: boolean
    end_date?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail_url?: boolean
    start_date?: boolean
    end_date?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail_url?: boolean
    start_date?: boolean
    end_date?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ChallengeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "thumbnail_url" | "start_date" | "end_date" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["challenge"]>
  export type ChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | Challenge$participantsArgs<ExtArgs>
    available_cafes?: boolean | Challenge$available_cafesArgs<ExtArgs>
    badges?: boolean | Challenge$badgesArgs<ExtArgs>
    _count?: boolean | ChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChallengeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ChallengeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Challenge"
    objects: {
      participants: Prisma.$ChallengeParticipantPayload<ExtArgs>[]
      available_cafes: Prisma.$ChallengeAvailableCafePayload<ExtArgs>[]
      badges: Prisma.$BadgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      thumbnail_url: string
      start_date: Date
      end_date: Date
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["challenge"]>
    composites: {}
  }

  type ChallengeGetPayload<S extends boolean | null | undefined | ChallengeDefaultArgs> = $Result.GetResult<Prisma.$ChallengePayload, S>

  type ChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeCountAggregateInputType | true
    }

  export interface ChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Challenge'], meta: { name: 'Challenge' } }
    /**
     * Find zero or one Challenge that matches the filter.
     * @param {ChallengeFindUniqueArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeFindUniqueArgs>(args: SelectSubset<T, ChallengeFindUniqueArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Challenge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeFindUniqueOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Challenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeFindFirstArgs>(args?: SelectSubset<T, ChallengeFindFirstArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Challenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Challenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Challenges
     * const challenges = await prisma.challenge.findMany()
     * 
     * // Get first 10 Challenges
     * const challenges = await prisma.challenge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeWithIdOnly = await prisma.challenge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeFindManyArgs>(args?: SelectSubset<T, ChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Challenge.
     * @param {ChallengeCreateArgs} args - Arguments to create a Challenge.
     * @example
     * // Create one Challenge
     * const Challenge = await prisma.challenge.create({
     *   data: {
     *     // ... data to create a Challenge
     *   }
     * })
     * 
     */
    create<T extends ChallengeCreateArgs>(args: SelectSubset<T, ChallengeCreateArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Challenges.
     * @param {ChallengeCreateManyArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeCreateManyArgs>(args?: SelectSubset<T, ChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Challenges and returns the data saved in the database.
     * @param {ChallengeCreateManyAndReturnArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Challenges and only return the `id`
     * const challengeWithIdOnly = await prisma.challenge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Challenge.
     * @param {ChallengeDeleteArgs} args - Arguments to delete one Challenge.
     * @example
     * // Delete one Challenge
     * const Challenge = await prisma.challenge.delete({
     *   where: {
     *     // ... filter to delete one Challenge
     *   }
     * })
     * 
     */
    delete<T extends ChallengeDeleteArgs>(args: SelectSubset<T, ChallengeDeleteArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Challenge.
     * @param {ChallengeUpdateArgs} args - Arguments to update one Challenge.
     * @example
     * // Update one Challenge
     * const challenge = await prisma.challenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeUpdateArgs>(args: SelectSubset<T, ChallengeUpdateArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Challenges.
     * @param {ChallengeDeleteManyArgs} args - Arguments to filter Challenges to delete.
     * @example
     * // Delete a few Challenges
     * const { count } = await prisma.challenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeDeleteManyArgs>(args?: SelectSubset<T, ChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Challenges
     * const challenge = await prisma.challenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeUpdateManyArgs>(args: SelectSubset<T, ChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Challenges and returns the data updated in the database.
     * @param {ChallengeUpdateManyAndReturnArgs} args - Arguments to update many Challenges.
     * @example
     * // Update many Challenges
     * const challenge = await prisma.challenge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Challenges and only return the `id`
     * const challengeWithIdOnly = await prisma.challenge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Challenge.
     * @param {ChallengeUpsertArgs} args - Arguments to update or create a Challenge.
     * @example
     * // Update or create a Challenge
     * const challenge = await prisma.challenge.upsert({
     *   create: {
     *     // ... data to create a Challenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Challenge we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeUpsertArgs>(args: SelectSubset<T, ChallengeUpsertArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeCountArgs} args - Arguments to filter Challenges to count.
     * @example
     * // Count the number of Challenges
     * const count = await prisma.challenge.count({
     *   where: {
     *     // ... the filter for the Challenges we want to count
     *   }
     * })
    **/
    count<T extends ChallengeCountArgs>(
      args?: Subset<T, ChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeAggregateArgs>(args: Subset<T, ChallengeAggregateArgs>): Prisma.PrismaPromise<GetChallengeAggregateType<T>>

    /**
     * Group by Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Challenge model
   */
  readonly fields: ChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Challenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participants<T extends Challenge$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    available_cafes<T extends Challenge$available_cafesArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$available_cafesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeAvailableCafePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    badges<T extends Challenge$badgesArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Challenge model
   */
  interface ChallengeFieldRefs {
    readonly id: FieldRef<"Challenge", 'Int'>
    readonly title: FieldRef<"Challenge", 'String'>
    readonly description: FieldRef<"Challenge", 'String'>
    readonly thumbnail_url: FieldRef<"Challenge", 'String'>
    readonly start_date: FieldRef<"Challenge", 'DateTime'>
    readonly end_date: FieldRef<"Challenge", 'DateTime'>
    readonly is_active: FieldRef<"Challenge", 'Boolean'>
    readonly created_at: FieldRef<"Challenge", 'DateTime'>
    readonly updated_at: FieldRef<"Challenge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Challenge findUnique
   */
  export type ChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge findUniqueOrThrow
   */
  export type ChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge findFirst
   */
  export type ChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge findFirstOrThrow
   */
  export type ChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge findMany
   */
  export type ChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenges to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge create
   */
  export type ChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a Challenge.
     */
    data: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
  }

  /**
   * Challenge createMany
   */
  export type ChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Challenge createManyAndReturn
   */
  export type ChallengeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Challenge update
   */
  export type ChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a Challenge.
     */
    data: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
    /**
     * Choose, which Challenge to update.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge updateMany
   */
  export type ChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Challenges.
     */
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyInput>
    /**
     * Filter which Challenges to update
     */
    where?: ChallengeWhereInput
    /**
     * Limit how many Challenges to update.
     */
    limit?: number
  }

  /**
   * Challenge updateManyAndReturn
   */
  export type ChallengeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * The data used to update Challenges.
     */
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyInput>
    /**
     * Filter which Challenges to update
     */
    where?: ChallengeWhereInput
    /**
     * Limit how many Challenges to update.
     */
    limit?: number
  }

  /**
   * Challenge upsert
   */
  export type ChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the Challenge to update in case it exists.
     */
    where: ChallengeWhereUniqueInput
    /**
     * In case the Challenge found by the `where` argument doesn't exist, create a new Challenge with this data.
     */
    create: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
    /**
     * In case the Challenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
  }

  /**
   * Challenge delete
   */
  export type ChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter which Challenge to delete.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge deleteMany
   */
  export type ChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Challenges to delete
     */
    where?: ChallengeWhereInput
    /**
     * Limit how many Challenges to delete.
     */
    limit?: number
  }

  /**
   * Challenge.participants
   */
  export type Challenge$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    where?: ChallengeParticipantWhereInput
    orderBy?: ChallengeParticipantOrderByWithRelationInput | ChallengeParticipantOrderByWithRelationInput[]
    cursor?: ChallengeParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeParticipantScalarFieldEnum | ChallengeParticipantScalarFieldEnum[]
  }

  /**
   * Challenge.available_cafes
   */
  export type Challenge$available_cafesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAvailableCafe
     */
    select?: ChallengeAvailableCafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAvailableCafe
     */
    omit?: ChallengeAvailableCafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAvailableCafeInclude<ExtArgs> | null
    where?: ChallengeAvailableCafeWhereInput
    orderBy?: ChallengeAvailableCafeOrderByWithRelationInput | ChallengeAvailableCafeOrderByWithRelationInput[]
    cursor?: ChallengeAvailableCafeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeAvailableCafeScalarFieldEnum | ChallengeAvailableCafeScalarFieldEnum[]
  }

  /**
   * Challenge.badges
   */
  export type Challenge$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    cursor?: BadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Challenge without action
   */
  export type ChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Challenge
     */
    omit?: ChallengeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeParticipant
   */

  export type AggregateChallengeParticipant = {
    _count: ChallengeParticipantCountAggregateOutputType | null
    _avg: ChallengeParticipantAvgAggregateOutputType | null
    _sum: ChallengeParticipantSumAggregateOutputType | null
    _min: ChallengeParticipantMinAggregateOutputType | null
    _max: ChallengeParticipantMaxAggregateOutputType | null
  }

  export type ChallengeParticipantAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    challenge_id: number | null
  }

  export type ChallengeParticipantSumAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    challenge_id: number | null
  }

  export type ChallengeParticipantMinAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    challenge_id: number | null
    status: string | null
    joined_at: Date | null
    completed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChallengeParticipantMaxAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    challenge_id: number | null
    status: string | null
    joined_at: Date | null
    completed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChallengeParticipantCountAggregateOutputType = {
    id: number
    user_id: number
    challenge_id: number
    status: number
    joined_at: number
    completed_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ChallengeParticipantAvgAggregateInputType = {
    id?: true
    user_id?: true
    challenge_id?: true
  }

  export type ChallengeParticipantSumAggregateInputType = {
    id?: true
    user_id?: true
    challenge_id?: true
  }

  export type ChallengeParticipantMinAggregateInputType = {
    id?: true
    user_id?: true
    challenge_id?: true
    status?: true
    joined_at?: true
    completed_at?: true
    created_at?: true
    updated_at?: true
  }

  export type ChallengeParticipantMaxAggregateInputType = {
    id?: true
    user_id?: true
    challenge_id?: true
    status?: true
    joined_at?: true
    completed_at?: true
    created_at?: true
    updated_at?: true
  }

  export type ChallengeParticipantCountAggregateInputType = {
    id?: true
    user_id?: true
    challenge_id?: true
    status?: true
    joined_at?: true
    completed_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ChallengeParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeParticipant to aggregate.
     */
    where?: ChallengeParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeParticipants to fetch.
     */
    orderBy?: ChallengeParticipantOrderByWithRelationInput | ChallengeParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeParticipants
    **/
    _count?: true | ChallengeParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeParticipantMaxAggregateInputType
  }

  export type GetChallengeParticipantAggregateType<T extends ChallengeParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeParticipant[P]>
      : GetScalarType<T[P], AggregateChallengeParticipant[P]>
  }




  export type ChallengeParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeParticipantWhereInput
    orderBy?: ChallengeParticipantOrderByWithAggregationInput | ChallengeParticipantOrderByWithAggregationInput[]
    by: ChallengeParticipantScalarFieldEnum[] | ChallengeParticipantScalarFieldEnum
    having?: ChallengeParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeParticipantCountAggregateInputType | true
    _avg?: ChallengeParticipantAvgAggregateInputType
    _sum?: ChallengeParticipantSumAggregateInputType
    _min?: ChallengeParticipantMinAggregateInputType
    _max?: ChallengeParticipantMaxAggregateInputType
  }

  export type ChallengeParticipantGroupByOutputType = {
    id: number
    user_id: bigint
    challenge_id: number
    status: string
    joined_at: Date
    completed_at: Date
    created_at: Date
    updated_at: Date
    _count: ChallengeParticipantCountAggregateOutputType | null
    _avg: ChallengeParticipantAvgAggregateOutputType | null
    _sum: ChallengeParticipantSumAggregateOutputType | null
    _min: ChallengeParticipantMinAggregateOutputType | null
    _max: ChallengeParticipantMaxAggregateOutputType | null
  }

  type GetChallengeParticipantGroupByPayload<T extends ChallengeParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    challenge_id?: boolean
    status?: boolean
    joined_at?: boolean
    completed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeParticipant"]>

  export type ChallengeParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    challenge_id?: boolean
    status?: boolean
    joined_at?: boolean
    completed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeParticipant"]>

  export type ChallengeParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    challenge_id?: boolean
    status?: boolean
    joined_at?: boolean
    completed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeParticipant"]>

  export type ChallengeParticipantSelectScalar = {
    id?: boolean
    user_id?: boolean
    challenge_id?: boolean
    status?: boolean
    joined_at?: boolean
    completed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ChallengeParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "challenge_id" | "status" | "joined_at" | "completed_at" | "created_at" | "updated_at", ExtArgs["result"]["challengeParticipant"]>
  export type ChallengeParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $ChallengeParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeParticipant"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: bigint
      challenge_id: number
      status: string
      joined_at: Date
      completed_at: Date
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["challengeParticipant"]>
    composites: {}
  }

  type ChallengeParticipantGetPayload<S extends boolean | null | undefined | ChallengeParticipantDefaultArgs> = $Result.GetResult<Prisma.$ChallengeParticipantPayload, S>

  type ChallengeParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeParticipantCountAggregateInputType | true
    }

  export interface ChallengeParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeParticipant'], meta: { name: 'ChallengeParticipant' } }
    /**
     * Find zero or one ChallengeParticipant that matches the filter.
     * @param {ChallengeParticipantFindUniqueArgs} args - Arguments to find a ChallengeParticipant
     * @example
     * // Get one ChallengeParticipant
     * const challengeParticipant = await prisma.challengeParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeParticipantFindUniqueArgs>(args: SelectSubset<T, ChallengeParticipantFindUniqueArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeParticipantFindUniqueOrThrowArgs} args - Arguments to find a ChallengeParticipant
     * @example
     * // Get one ChallengeParticipant
     * const challengeParticipant = await prisma.challengeParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantFindFirstArgs} args - Arguments to find a ChallengeParticipant
     * @example
     * // Get one ChallengeParticipant
     * const challengeParticipant = await prisma.challengeParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeParticipantFindFirstArgs>(args?: SelectSubset<T, ChallengeParticipantFindFirstArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantFindFirstOrThrowArgs} args - Arguments to find a ChallengeParticipant
     * @example
     * // Get one ChallengeParticipant
     * const challengeParticipant = await prisma.challengeParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeParticipants
     * const challengeParticipants = await prisma.challengeParticipant.findMany()
     * 
     * // Get first 10 ChallengeParticipants
     * const challengeParticipants = await prisma.challengeParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeParticipantWithIdOnly = await prisma.challengeParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeParticipantFindManyArgs>(args?: SelectSubset<T, ChallengeParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeParticipant.
     * @param {ChallengeParticipantCreateArgs} args - Arguments to create a ChallengeParticipant.
     * @example
     * // Create one ChallengeParticipant
     * const ChallengeParticipant = await prisma.challengeParticipant.create({
     *   data: {
     *     // ... data to create a ChallengeParticipant
     *   }
     * })
     * 
     */
    create<T extends ChallengeParticipantCreateArgs>(args: SelectSubset<T, ChallengeParticipantCreateArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeParticipants.
     * @param {ChallengeParticipantCreateManyArgs} args - Arguments to create many ChallengeParticipants.
     * @example
     * // Create many ChallengeParticipants
     * const challengeParticipant = await prisma.challengeParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeParticipantCreateManyArgs>(args?: SelectSubset<T, ChallengeParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeParticipants and returns the data saved in the database.
     * @param {ChallengeParticipantCreateManyAndReturnArgs} args - Arguments to create many ChallengeParticipants.
     * @example
     * // Create many ChallengeParticipants
     * const challengeParticipant = await prisma.challengeParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeParticipants and only return the `id`
     * const challengeParticipantWithIdOnly = await prisma.challengeParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeParticipant.
     * @param {ChallengeParticipantDeleteArgs} args - Arguments to delete one ChallengeParticipant.
     * @example
     * // Delete one ChallengeParticipant
     * const ChallengeParticipant = await prisma.challengeParticipant.delete({
     *   where: {
     *     // ... filter to delete one ChallengeParticipant
     *   }
     * })
     * 
     */
    delete<T extends ChallengeParticipantDeleteArgs>(args: SelectSubset<T, ChallengeParticipantDeleteArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeParticipant.
     * @param {ChallengeParticipantUpdateArgs} args - Arguments to update one ChallengeParticipant.
     * @example
     * // Update one ChallengeParticipant
     * const challengeParticipant = await prisma.challengeParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeParticipantUpdateArgs>(args: SelectSubset<T, ChallengeParticipantUpdateArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeParticipants.
     * @param {ChallengeParticipantDeleteManyArgs} args - Arguments to filter ChallengeParticipants to delete.
     * @example
     * // Delete a few ChallengeParticipants
     * const { count } = await prisma.challengeParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeParticipantDeleteManyArgs>(args?: SelectSubset<T, ChallengeParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeParticipants
     * const challengeParticipant = await prisma.challengeParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeParticipantUpdateManyArgs>(args: SelectSubset<T, ChallengeParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeParticipants and returns the data updated in the database.
     * @param {ChallengeParticipantUpdateManyAndReturnArgs} args - Arguments to update many ChallengeParticipants.
     * @example
     * // Update many ChallengeParticipants
     * const challengeParticipant = await prisma.challengeParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeParticipants and only return the `id`
     * const challengeParticipantWithIdOnly = await prisma.challengeParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeParticipant.
     * @param {ChallengeParticipantUpsertArgs} args - Arguments to update or create a ChallengeParticipant.
     * @example
     * // Update or create a ChallengeParticipant
     * const challengeParticipant = await prisma.challengeParticipant.upsert({
     *   create: {
     *     // ... data to create a ChallengeParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeParticipant we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeParticipantUpsertArgs>(args: SelectSubset<T, ChallengeParticipantUpsertArgs<ExtArgs>>): Prisma__ChallengeParticipantClient<$Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantCountArgs} args - Arguments to filter ChallengeParticipants to count.
     * @example
     * // Count the number of ChallengeParticipants
     * const count = await prisma.challengeParticipant.count({
     *   where: {
     *     // ... the filter for the ChallengeParticipants we want to count
     *   }
     * })
    **/
    count<T extends ChallengeParticipantCountArgs>(
      args?: Subset<T, ChallengeParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeParticipantAggregateArgs>(args: Subset<T, ChallengeParticipantAggregateArgs>): Prisma.PrismaPromise<GetChallengeParticipantAggregateType<T>>

    /**
     * Group by ChallengeParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeParticipant model
   */
  readonly fields: ChallengeParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeParticipant model
   */
  interface ChallengeParticipantFieldRefs {
    readonly id: FieldRef<"ChallengeParticipant", 'Int'>
    readonly user_id: FieldRef<"ChallengeParticipant", 'BigInt'>
    readonly challenge_id: FieldRef<"ChallengeParticipant", 'Int'>
    readonly status: FieldRef<"ChallengeParticipant", 'String'>
    readonly joined_at: FieldRef<"ChallengeParticipant", 'DateTime'>
    readonly completed_at: FieldRef<"ChallengeParticipant", 'DateTime'>
    readonly created_at: FieldRef<"ChallengeParticipant", 'DateTime'>
    readonly updated_at: FieldRef<"ChallengeParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeParticipant findUnique
   */
  export type ChallengeParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeParticipant to fetch.
     */
    where: ChallengeParticipantWhereUniqueInput
  }

  /**
   * ChallengeParticipant findUniqueOrThrow
   */
  export type ChallengeParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeParticipant to fetch.
     */
    where: ChallengeParticipantWhereUniqueInput
  }

  /**
   * ChallengeParticipant findFirst
   */
  export type ChallengeParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeParticipant to fetch.
     */
    where?: ChallengeParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeParticipants to fetch.
     */
    orderBy?: ChallengeParticipantOrderByWithRelationInput | ChallengeParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeParticipants.
     */
    cursor?: ChallengeParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeParticipants.
     */
    distinct?: ChallengeParticipantScalarFieldEnum | ChallengeParticipantScalarFieldEnum[]
  }

  /**
   * ChallengeParticipant findFirstOrThrow
   */
  export type ChallengeParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeParticipant to fetch.
     */
    where?: ChallengeParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeParticipants to fetch.
     */
    orderBy?: ChallengeParticipantOrderByWithRelationInput | ChallengeParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeParticipants.
     */
    cursor?: ChallengeParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeParticipants.
     */
    distinct?: ChallengeParticipantScalarFieldEnum | ChallengeParticipantScalarFieldEnum[]
  }

  /**
   * ChallengeParticipant findMany
   */
  export type ChallengeParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeParticipants to fetch.
     */
    where?: ChallengeParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeParticipants to fetch.
     */
    orderBy?: ChallengeParticipantOrderByWithRelationInput | ChallengeParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeParticipants.
     */
    cursor?: ChallengeParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeParticipants.
     */
    skip?: number
    distinct?: ChallengeParticipantScalarFieldEnum | ChallengeParticipantScalarFieldEnum[]
  }

  /**
   * ChallengeParticipant create
   */
  export type ChallengeParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeParticipant.
     */
    data: XOR<ChallengeParticipantCreateInput, ChallengeParticipantUncheckedCreateInput>
  }

  /**
   * ChallengeParticipant createMany
   */
  export type ChallengeParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeParticipants.
     */
    data: ChallengeParticipantCreateManyInput | ChallengeParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeParticipant createManyAndReturn
   */
  export type ChallengeParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeParticipants.
     */
    data: ChallengeParticipantCreateManyInput | ChallengeParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeParticipant update
   */
  export type ChallengeParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeParticipant.
     */
    data: XOR<ChallengeParticipantUpdateInput, ChallengeParticipantUncheckedUpdateInput>
    /**
     * Choose, which ChallengeParticipant to update.
     */
    where: ChallengeParticipantWhereUniqueInput
  }

  /**
   * ChallengeParticipant updateMany
   */
  export type ChallengeParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeParticipants.
     */
    data: XOR<ChallengeParticipantUpdateManyMutationInput, ChallengeParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeParticipants to update
     */
    where?: ChallengeParticipantWhereInput
    /**
     * Limit how many ChallengeParticipants to update.
     */
    limit?: number
  }

  /**
   * ChallengeParticipant updateManyAndReturn
   */
  export type ChallengeParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeParticipants.
     */
    data: XOR<ChallengeParticipantUpdateManyMutationInput, ChallengeParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeParticipants to update
     */
    where?: ChallengeParticipantWhereInput
    /**
     * Limit how many ChallengeParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeParticipant upsert
   */
  export type ChallengeParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeParticipant to update in case it exists.
     */
    where: ChallengeParticipantWhereUniqueInput
    /**
     * In case the ChallengeParticipant found by the `where` argument doesn't exist, create a new ChallengeParticipant with this data.
     */
    create: XOR<ChallengeParticipantCreateInput, ChallengeParticipantUncheckedCreateInput>
    /**
     * In case the ChallengeParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeParticipantUpdateInput, ChallengeParticipantUncheckedUpdateInput>
  }

  /**
   * ChallengeParticipant delete
   */
  export type ChallengeParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
    /**
     * Filter which ChallengeParticipant to delete.
     */
    where: ChallengeParticipantWhereUniqueInput
  }

  /**
   * ChallengeParticipant deleteMany
   */
  export type ChallengeParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeParticipants to delete
     */
    where?: ChallengeParticipantWhereInput
    /**
     * Limit how many ChallengeParticipants to delete.
     */
    limit?: number
  }

  /**
   * ChallengeParticipant without action
   */
  export type ChallengeParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeParticipant
     */
    select?: ChallengeParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeParticipant
     */
    omit?: ChallengeParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeParticipantInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeAvailableCafe
   */

  export type AggregateChallengeAvailableCafe = {
    _count: ChallengeAvailableCafeCountAggregateOutputType | null
    _avg: ChallengeAvailableCafeAvgAggregateOutputType | null
    _sum: ChallengeAvailableCafeSumAggregateOutputType | null
    _min: ChallengeAvailableCafeMinAggregateOutputType | null
    _max: ChallengeAvailableCafeMaxAggregateOutputType | null
  }

  export type ChallengeAvailableCafeAvgAggregateOutputType = {
    id: number | null
    challenge_id: number | null
    cafe_id: number | null
  }

  export type ChallengeAvailableCafeSumAggregateOutputType = {
    id: number | null
    challenge_id: number | null
    cafe_id: bigint | null
  }

  export type ChallengeAvailableCafeMinAggregateOutputType = {
    id: number | null
    challenge_id: number | null
    cafe_id: bigint | null
    created_at: Date | null
  }

  export type ChallengeAvailableCafeMaxAggregateOutputType = {
    id: number | null
    challenge_id: number | null
    cafe_id: bigint | null
    created_at: Date | null
  }

  export type ChallengeAvailableCafeCountAggregateOutputType = {
    id: number
    challenge_id: number
    cafe_id: number
    created_at: number
    _all: number
  }


  export type ChallengeAvailableCafeAvgAggregateInputType = {
    id?: true
    challenge_id?: true
    cafe_id?: true
  }

  export type ChallengeAvailableCafeSumAggregateInputType = {
    id?: true
    challenge_id?: true
    cafe_id?: true
  }

  export type ChallengeAvailableCafeMinAggregateInputType = {
    id?: true
    challenge_id?: true
    cafe_id?: true
    created_at?: true
  }

  export type ChallengeAvailableCafeMaxAggregateInputType = {
    id?: true
    challenge_id?: true
    cafe_id?: true
    created_at?: true
  }

  export type ChallengeAvailableCafeCountAggregateInputType = {
    id?: true
    challenge_id?: true
    cafe_id?: true
    created_at?: true
    _all?: true
  }

  export type ChallengeAvailableCafeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeAvailableCafe to aggregate.
     */
    where?: ChallengeAvailableCafeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeAvailableCafes to fetch.
     */
    orderBy?: ChallengeAvailableCafeOrderByWithRelationInput | ChallengeAvailableCafeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeAvailableCafeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeAvailableCafes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeAvailableCafes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeAvailableCafes
    **/
    _count?: true | ChallengeAvailableCafeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeAvailableCafeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeAvailableCafeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeAvailableCafeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeAvailableCafeMaxAggregateInputType
  }

  export type GetChallengeAvailableCafeAggregateType<T extends ChallengeAvailableCafeAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeAvailableCafe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeAvailableCafe[P]>
      : GetScalarType<T[P], AggregateChallengeAvailableCafe[P]>
  }




  export type ChallengeAvailableCafeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeAvailableCafeWhereInput
    orderBy?: ChallengeAvailableCafeOrderByWithAggregationInput | ChallengeAvailableCafeOrderByWithAggregationInput[]
    by: ChallengeAvailableCafeScalarFieldEnum[] | ChallengeAvailableCafeScalarFieldEnum
    having?: ChallengeAvailableCafeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeAvailableCafeCountAggregateInputType | true
    _avg?: ChallengeAvailableCafeAvgAggregateInputType
    _sum?: ChallengeAvailableCafeSumAggregateInputType
    _min?: ChallengeAvailableCafeMinAggregateInputType
    _max?: ChallengeAvailableCafeMaxAggregateInputType
  }

  export type ChallengeAvailableCafeGroupByOutputType = {
    id: number
    challenge_id: number
    cafe_id: bigint
    created_at: Date
    _count: ChallengeAvailableCafeCountAggregateOutputType | null
    _avg: ChallengeAvailableCafeAvgAggregateOutputType | null
    _sum: ChallengeAvailableCafeSumAggregateOutputType | null
    _min: ChallengeAvailableCafeMinAggregateOutputType | null
    _max: ChallengeAvailableCafeMaxAggregateOutputType | null
  }

  type GetChallengeAvailableCafeGroupByPayload<T extends ChallengeAvailableCafeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeAvailableCafeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeAvailableCafeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeAvailableCafeGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeAvailableCafeGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeAvailableCafeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_id?: boolean
    cafe_id?: boolean
    created_at?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeAvailableCafe"]>

  export type ChallengeAvailableCafeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_id?: boolean
    cafe_id?: boolean
    created_at?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeAvailableCafe"]>

  export type ChallengeAvailableCafeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challenge_id?: boolean
    cafe_id?: boolean
    created_at?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeAvailableCafe"]>

  export type ChallengeAvailableCafeSelectScalar = {
    id?: boolean
    challenge_id?: boolean
    cafe_id?: boolean
    created_at?: boolean
  }

  export type ChallengeAvailableCafeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "challenge_id" | "cafe_id" | "created_at", ExtArgs["result"]["challengeAvailableCafe"]>
  export type ChallengeAvailableCafeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }
  export type ChallengeAvailableCafeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }
  export type ChallengeAvailableCafeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }

  export type $ChallengeAvailableCafePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeAvailableCafe"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
      cafe: Prisma.$CafePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      challenge_id: number
      cafe_id: bigint
      created_at: Date
    }, ExtArgs["result"]["challengeAvailableCafe"]>
    composites: {}
  }

  type ChallengeAvailableCafeGetPayload<S extends boolean | null | undefined | ChallengeAvailableCafeDefaultArgs> = $Result.GetResult<Prisma.$ChallengeAvailableCafePayload, S>

  type ChallengeAvailableCafeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeAvailableCafeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeAvailableCafeCountAggregateInputType | true
    }

  export interface ChallengeAvailableCafeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeAvailableCafe'], meta: { name: 'ChallengeAvailableCafe' } }
    /**
     * Find zero or one ChallengeAvailableCafe that matches the filter.
     * @param {ChallengeAvailableCafeFindUniqueArgs} args - Arguments to find a ChallengeAvailableCafe
     * @example
     * // Get one ChallengeAvailableCafe
     * const challengeAvailableCafe = await prisma.challengeAvailableCafe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeAvailableCafeFindUniqueArgs>(args: SelectSubset<T, ChallengeAvailableCafeFindUniqueArgs<ExtArgs>>): Prisma__ChallengeAvailableCafeClient<$Result.GetResult<Prisma.$ChallengeAvailableCafePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeAvailableCafe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeAvailableCafeFindUniqueOrThrowArgs} args - Arguments to find a ChallengeAvailableCafe
     * @example
     * // Get one ChallengeAvailableCafe
     * const challengeAvailableCafe = await prisma.challengeAvailableCafe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeAvailableCafeFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeAvailableCafeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeAvailableCafeClient<$Result.GetResult<Prisma.$ChallengeAvailableCafePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeAvailableCafe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAvailableCafeFindFirstArgs} args - Arguments to find a ChallengeAvailableCafe
     * @example
     * // Get one ChallengeAvailableCafe
     * const challengeAvailableCafe = await prisma.challengeAvailableCafe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeAvailableCafeFindFirstArgs>(args?: SelectSubset<T, ChallengeAvailableCafeFindFirstArgs<ExtArgs>>): Prisma__ChallengeAvailableCafeClient<$Result.GetResult<Prisma.$ChallengeAvailableCafePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeAvailableCafe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAvailableCafeFindFirstOrThrowArgs} args - Arguments to find a ChallengeAvailableCafe
     * @example
     * // Get one ChallengeAvailableCafe
     * const challengeAvailableCafe = await prisma.challengeAvailableCafe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeAvailableCafeFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeAvailableCafeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeAvailableCafeClient<$Result.GetResult<Prisma.$ChallengeAvailableCafePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeAvailableCafes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAvailableCafeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeAvailableCafes
     * const challengeAvailableCafes = await prisma.challengeAvailableCafe.findMany()
     * 
     * // Get first 10 ChallengeAvailableCafes
     * const challengeAvailableCafes = await prisma.challengeAvailableCafe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeAvailableCafeWithIdOnly = await prisma.challengeAvailableCafe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeAvailableCafeFindManyArgs>(args?: SelectSubset<T, ChallengeAvailableCafeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeAvailableCafePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeAvailableCafe.
     * @param {ChallengeAvailableCafeCreateArgs} args - Arguments to create a ChallengeAvailableCafe.
     * @example
     * // Create one ChallengeAvailableCafe
     * const ChallengeAvailableCafe = await prisma.challengeAvailableCafe.create({
     *   data: {
     *     // ... data to create a ChallengeAvailableCafe
     *   }
     * })
     * 
     */
    create<T extends ChallengeAvailableCafeCreateArgs>(args: SelectSubset<T, ChallengeAvailableCafeCreateArgs<ExtArgs>>): Prisma__ChallengeAvailableCafeClient<$Result.GetResult<Prisma.$ChallengeAvailableCafePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeAvailableCafes.
     * @param {ChallengeAvailableCafeCreateManyArgs} args - Arguments to create many ChallengeAvailableCafes.
     * @example
     * // Create many ChallengeAvailableCafes
     * const challengeAvailableCafe = await prisma.challengeAvailableCafe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeAvailableCafeCreateManyArgs>(args?: SelectSubset<T, ChallengeAvailableCafeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeAvailableCafes and returns the data saved in the database.
     * @param {ChallengeAvailableCafeCreateManyAndReturnArgs} args - Arguments to create many ChallengeAvailableCafes.
     * @example
     * // Create many ChallengeAvailableCafes
     * const challengeAvailableCafe = await prisma.challengeAvailableCafe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeAvailableCafes and only return the `id`
     * const challengeAvailableCafeWithIdOnly = await prisma.challengeAvailableCafe.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeAvailableCafeCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeAvailableCafeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeAvailableCafePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChallengeAvailableCafe.
     * @param {ChallengeAvailableCafeDeleteArgs} args - Arguments to delete one ChallengeAvailableCafe.
     * @example
     * // Delete one ChallengeAvailableCafe
     * const ChallengeAvailableCafe = await prisma.challengeAvailableCafe.delete({
     *   where: {
     *     // ... filter to delete one ChallengeAvailableCafe
     *   }
     * })
     * 
     */
    delete<T extends ChallengeAvailableCafeDeleteArgs>(args: SelectSubset<T, ChallengeAvailableCafeDeleteArgs<ExtArgs>>): Prisma__ChallengeAvailableCafeClient<$Result.GetResult<Prisma.$ChallengeAvailableCafePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeAvailableCafe.
     * @param {ChallengeAvailableCafeUpdateArgs} args - Arguments to update one ChallengeAvailableCafe.
     * @example
     * // Update one ChallengeAvailableCafe
     * const challengeAvailableCafe = await prisma.challengeAvailableCafe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeAvailableCafeUpdateArgs>(args: SelectSubset<T, ChallengeAvailableCafeUpdateArgs<ExtArgs>>): Prisma__ChallengeAvailableCafeClient<$Result.GetResult<Prisma.$ChallengeAvailableCafePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeAvailableCafes.
     * @param {ChallengeAvailableCafeDeleteManyArgs} args - Arguments to filter ChallengeAvailableCafes to delete.
     * @example
     * // Delete a few ChallengeAvailableCafes
     * const { count } = await prisma.challengeAvailableCafe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeAvailableCafeDeleteManyArgs>(args?: SelectSubset<T, ChallengeAvailableCafeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeAvailableCafes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAvailableCafeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeAvailableCafes
     * const challengeAvailableCafe = await prisma.challengeAvailableCafe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeAvailableCafeUpdateManyArgs>(args: SelectSubset<T, ChallengeAvailableCafeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeAvailableCafes and returns the data updated in the database.
     * @param {ChallengeAvailableCafeUpdateManyAndReturnArgs} args - Arguments to update many ChallengeAvailableCafes.
     * @example
     * // Update many ChallengeAvailableCafes
     * const challengeAvailableCafe = await prisma.challengeAvailableCafe.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeAvailableCafes and only return the `id`
     * const challengeAvailableCafeWithIdOnly = await prisma.challengeAvailableCafe.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeAvailableCafeUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeAvailableCafeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeAvailableCafePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChallengeAvailableCafe.
     * @param {ChallengeAvailableCafeUpsertArgs} args - Arguments to update or create a ChallengeAvailableCafe.
     * @example
     * // Update or create a ChallengeAvailableCafe
     * const challengeAvailableCafe = await prisma.challengeAvailableCafe.upsert({
     *   create: {
     *     // ... data to create a ChallengeAvailableCafe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeAvailableCafe we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeAvailableCafeUpsertArgs>(args: SelectSubset<T, ChallengeAvailableCafeUpsertArgs<ExtArgs>>): Prisma__ChallengeAvailableCafeClient<$Result.GetResult<Prisma.$ChallengeAvailableCafePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeAvailableCafes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAvailableCafeCountArgs} args - Arguments to filter ChallengeAvailableCafes to count.
     * @example
     * // Count the number of ChallengeAvailableCafes
     * const count = await prisma.challengeAvailableCafe.count({
     *   where: {
     *     // ... the filter for the ChallengeAvailableCafes we want to count
     *   }
     * })
    **/
    count<T extends ChallengeAvailableCafeCountArgs>(
      args?: Subset<T, ChallengeAvailableCafeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeAvailableCafeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeAvailableCafe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAvailableCafeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeAvailableCafeAggregateArgs>(args: Subset<T, ChallengeAvailableCafeAggregateArgs>): Prisma.PrismaPromise<GetChallengeAvailableCafeAggregateType<T>>

    /**
     * Group by ChallengeAvailableCafe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAvailableCafeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeAvailableCafeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeAvailableCafeGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeAvailableCafeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeAvailableCafeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeAvailableCafeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeAvailableCafe model
   */
  readonly fields: ChallengeAvailableCafeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeAvailableCafe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeAvailableCafeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cafe<T extends CafeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CafeDefaultArgs<ExtArgs>>): Prisma__CafeClient<$Result.GetResult<Prisma.$CafePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeAvailableCafe model
   */
  interface ChallengeAvailableCafeFieldRefs {
    readonly id: FieldRef<"ChallengeAvailableCafe", 'Int'>
    readonly challenge_id: FieldRef<"ChallengeAvailableCafe", 'Int'>
    readonly cafe_id: FieldRef<"ChallengeAvailableCafe", 'BigInt'>
    readonly created_at: FieldRef<"ChallengeAvailableCafe", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeAvailableCafe findUnique
   */
  export type ChallengeAvailableCafeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAvailableCafe
     */
    select?: ChallengeAvailableCafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAvailableCafe
     */
    omit?: ChallengeAvailableCafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAvailableCafeInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeAvailableCafe to fetch.
     */
    where: ChallengeAvailableCafeWhereUniqueInput
  }

  /**
   * ChallengeAvailableCafe findUniqueOrThrow
   */
  export type ChallengeAvailableCafeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAvailableCafe
     */
    select?: ChallengeAvailableCafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAvailableCafe
     */
    omit?: ChallengeAvailableCafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAvailableCafeInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeAvailableCafe to fetch.
     */
    where: ChallengeAvailableCafeWhereUniqueInput
  }

  /**
   * ChallengeAvailableCafe findFirst
   */
  export type ChallengeAvailableCafeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAvailableCafe
     */
    select?: ChallengeAvailableCafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAvailableCafe
     */
    omit?: ChallengeAvailableCafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAvailableCafeInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeAvailableCafe to fetch.
     */
    where?: ChallengeAvailableCafeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeAvailableCafes to fetch.
     */
    orderBy?: ChallengeAvailableCafeOrderByWithRelationInput | ChallengeAvailableCafeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeAvailableCafes.
     */
    cursor?: ChallengeAvailableCafeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeAvailableCafes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeAvailableCafes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeAvailableCafes.
     */
    distinct?: ChallengeAvailableCafeScalarFieldEnum | ChallengeAvailableCafeScalarFieldEnum[]
  }

  /**
   * ChallengeAvailableCafe findFirstOrThrow
   */
  export type ChallengeAvailableCafeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAvailableCafe
     */
    select?: ChallengeAvailableCafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAvailableCafe
     */
    omit?: ChallengeAvailableCafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAvailableCafeInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeAvailableCafe to fetch.
     */
    where?: ChallengeAvailableCafeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeAvailableCafes to fetch.
     */
    orderBy?: ChallengeAvailableCafeOrderByWithRelationInput | ChallengeAvailableCafeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeAvailableCafes.
     */
    cursor?: ChallengeAvailableCafeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeAvailableCafes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeAvailableCafes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeAvailableCafes.
     */
    distinct?: ChallengeAvailableCafeScalarFieldEnum | ChallengeAvailableCafeScalarFieldEnum[]
  }

  /**
   * ChallengeAvailableCafe findMany
   */
  export type ChallengeAvailableCafeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAvailableCafe
     */
    select?: ChallengeAvailableCafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAvailableCafe
     */
    omit?: ChallengeAvailableCafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAvailableCafeInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeAvailableCafes to fetch.
     */
    where?: ChallengeAvailableCafeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeAvailableCafes to fetch.
     */
    orderBy?: ChallengeAvailableCafeOrderByWithRelationInput | ChallengeAvailableCafeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeAvailableCafes.
     */
    cursor?: ChallengeAvailableCafeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeAvailableCafes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeAvailableCafes.
     */
    skip?: number
    distinct?: ChallengeAvailableCafeScalarFieldEnum | ChallengeAvailableCafeScalarFieldEnum[]
  }

  /**
   * ChallengeAvailableCafe create
   */
  export type ChallengeAvailableCafeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAvailableCafe
     */
    select?: ChallengeAvailableCafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAvailableCafe
     */
    omit?: ChallengeAvailableCafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAvailableCafeInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeAvailableCafe.
     */
    data: XOR<ChallengeAvailableCafeCreateInput, ChallengeAvailableCafeUncheckedCreateInput>
  }

  /**
   * ChallengeAvailableCafe createMany
   */
  export type ChallengeAvailableCafeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeAvailableCafes.
     */
    data: ChallengeAvailableCafeCreateManyInput | ChallengeAvailableCafeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeAvailableCafe createManyAndReturn
   */
  export type ChallengeAvailableCafeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAvailableCafe
     */
    select?: ChallengeAvailableCafeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAvailableCafe
     */
    omit?: ChallengeAvailableCafeOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeAvailableCafes.
     */
    data: ChallengeAvailableCafeCreateManyInput | ChallengeAvailableCafeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAvailableCafeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeAvailableCafe update
   */
  export type ChallengeAvailableCafeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAvailableCafe
     */
    select?: ChallengeAvailableCafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAvailableCafe
     */
    omit?: ChallengeAvailableCafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAvailableCafeInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeAvailableCafe.
     */
    data: XOR<ChallengeAvailableCafeUpdateInput, ChallengeAvailableCafeUncheckedUpdateInput>
    /**
     * Choose, which ChallengeAvailableCafe to update.
     */
    where: ChallengeAvailableCafeWhereUniqueInput
  }

  /**
   * ChallengeAvailableCafe updateMany
   */
  export type ChallengeAvailableCafeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeAvailableCafes.
     */
    data: XOR<ChallengeAvailableCafeUpdateManyMutationInput, ChallengeAvailableCafeUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeAvailableCafes to update
     */
    where?: ChallengeAvailableCafeWhereInput
    /**
     * Limit how many ChallengeAvailableCafes to update.
     */
    limit?: number
  }

  /**
   * ChallengeAvailableCafe updateManyAndReturn
   */
  export type ChallengeAvailableCafeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAvailableCafe
     */
    select?: ChallengeAvailableCafeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAvailableCafe
     */
    omit?: ChallengeAvailableCafeOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeAvailableCafes.
     */
    data: XOR<ChallengeAvailableCafeUpdateManyMutationInput, ChallengeAvailableCafeUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeAvailableCafes to update
     */
    where?: ChallengeAvailableCafeWhereInput
    /**
     * Limit how many ChallengeAvailableCafes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAvailableCafeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeAvailableCafe upsert
   */
  export type ChallengeAvailableCafeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAvailableCafe
     */
    select?: ChallengeAvailableCafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAvailableCafe
     */
    omit?: ChallengeAvailableCafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAvailableCafeInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeAvailableCafe to update in case it exists.
     */
    where: ChallengeAvailableCafeWhereUniqueInput
    /**
     * In case the ChallengeAvailableCafe found by the `where` argument doesn't exist, create a new ChallengeAvailableCafe with this data.
     */
    create: XOR<ChallengeAvailableCafeCreateInput, ChallengeAvailableCafeUncheckedCreateInput>
    /**
     * In case the ChallengeAvailableCafe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeAvailableCafeUpdateInput, ChallengeAvailableCafeUncheckedUpdateInput>
  }

  /**
   * ChallengeAvailableCafe delete
   */
  export type ChallengeAvailableCafeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAvailableCafe
     */
    select?: ChallengeAvailableCafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAvailableCafe
     */
    omit?: ChallengeAvailableCafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAvailableCafeInclude<ExtArgs> | null
    /**
     * Filter which ChallengeAvailableCafe to delete.
     */
    where: ChallengeAvailableCafeWhereUniqueInput
  }

  /**
   * ChallengeAvailableCafe deleteMany
   */
  export type ChallengeAvailableCafeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeAvailableCafes to delete
     */
    where?: ChallengeAvailableCafeWhereInput
    /**
     * Limit how many ChallengeAvailableCafes to delete.
     */
    limit?: number
  }

  /**
   * ChallengeAvailableCafe without action
   */
  export type ChallengeAvailableCafeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAvailableCafe
     */
    select?: ChallengeAvailableCafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAvailableCafe
     */
    omit?: ChallengeAvailableCafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAvailableCafeInclude<ExtArgs> | null
  }


  /**
   * Model BadgeType
   */

  export type AggregateBadgeType = {
    _count: BadgeTypeCountAggregateOutputType | null
    _avg: BadgeTypeAvgAggregateOutputType | null
    _sum: BadgeTypeSumAggregateOutputType | null
    _min: BadgeTypeMinAggregateOutputType | null
    _max: BadgeTypeMaxAggregateOutputType | null
  }

  export type BadgeTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type BadgeTypeSumAggregateOutputType = {
    id: number | null
  }

  export type BadgeTypeMinAggregateOutputType = {
    id: number | null
    title: string | null
    image_url: string | null
    created_at: Date | null
  }

  export type BadgeTypeMaxAggregateOutputType = {
    id: number | null
    title: string | null
    image_url: string | null
    created_at: Date | null
  }

  export type BadgeTypeCountAggregateOutputType = {
    id: number
    title: number
    image_url: number
    created_at: number
    _all: number
  }


  export type BadgeTypeAvgAggregateInputType = {
    id?: true
  }

  export type BadgeTypeSumAggregateInputType = {
    id?: true
  }

  export type BadgeTypeMinAggregateInputType = {
    id?: true
    title?: true
    image_url?: true
    created_at?: true
  }

  export type BadgeTypeMaxAggregateInputType = {
    id?: true
    title?: true
    image_url?: true
    created_at?: true
  }

  export type BadgeTypeCountAggregateInputType = {
    id?: true
    title?: true
    image_url?: true
    created_at?: true
    _all?: true
  }

  export type BadgeTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BadgeType to aggregate.
     */
    where?: BadgeTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BadgeTypes to fetch.
     */
    orderBy?: BadgeTypeOrderByWithRelationInput | BadgeTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BadgeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BadgeTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BadgeTypes
    **/
    _count?: true | BadgeTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BadgeTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BadgeTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeTypeMaxAggregateInputType
  }

  export type GetBadgeTypeAggregateType<T extends BadgeTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadgeType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadgeType[P]>
      : GetScalarType<T[P], AggregateBadgeType[P]>
  }




  export type BadgeTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeTypeWhereInput
    orderBy?: BadgeTypeOrderByWithAggregationInput | BadgeTypeOrderByWithAggregationInput[]
    by: BadgeTypeScalarFieldEnum[] | BadgeTypeScalarFieldEnum
    having?: BadgeTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeTypeCountAggregateInputType | true
    _avg?: BadgeTypeAvgAggregateInputType
    _sum?: BadgeTypeSumAggregateInputType
    _min?: BadgeTypeMinAggregateInputType
    _max?: BadgeTypeMaxAggregateInputType
  }

  export type BadgeTypeGroupByOutputType = {
    id: number
    title: string
    image_url: string
    created_at: Date
    _count: BadgeTypeCountAggregateOutputType | null
    _avg: BadgeTypeAvgAggregateOutputType | null
    _sum: BadgeTypeSumAggregateOutputType | null
    _min: BadgeTypeMinAggregateOutputType | null
    _max: BadgeTypeMaxAggregateOutputType | null
  }

  type GetBadgeTypeGroupByPayload<T extends BadgeTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeTypeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeTypeGroupByOutputType[P]>
        }
      >
    >


  export type BadgeTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    image_url?: boolean
    created_at?: boolean
    badges?: boolean | BadgeType$badgesArgs<ExtArgs>
    _count?: boolean | BadgeTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badgeType"]>

  export type BadgeTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    image_url?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["badgeType"]>

  export type BadgeTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    image_url?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["badgeType"]>

  export type BadgeTypeSelectScalar = {
    id?: boolean
    title?: boolean
    image_url?: boolean
    created_at?: boolean
  }

  export type BadgeTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "image_url" | "created_at", ExtArgs["result"]["badgeType"]>
  export type BadgeTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badges?: boolean | BadgeType$badgesArgs<ExtArgs>
    _count?: boolean | BadgeTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BadgeTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BadgeTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BadgeTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BadgeType"
    objects: {
      badges: Prisma.$BadgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      image_url: string
      created_at: Date
    }, ExtArgs["result"]["badgeType"]>
    composites: {}
  }

  type BadgeTypeGetPayload<S extends boolean | null | undefined | BadgeTypeDefaultArgs> = $Result.GetResult<Prisma.$BadgeTypePayload, S>

  type BadgeTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BadgeTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BadgeTypeCountAggregateInputType | true
    }

  export interface BadgeTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BadgeType'], meta: { name: 'BadgeType' } }
    /**
     * Find zero or one BadgeType that matches the filter.
     * @param {BadgeTypeFindUniqueArgs} args - Arguments to find a BadgeType
     * @example
     * // Get one BadgeType
     * const badgeType = await prisma.badgeType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeTypeFindUniqueArgs>(args: SelectSubset<T, BadgeTypeFindUniqueArgs<ExtArgs>>): Prisma__BadgeTypeClient<$Result.GetResult<Prisma.$BadgeTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BadgeType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BadgeTypeFindUniqueOrThrowArgs} args - Arguments to find a BadgeType
     * @example
     * // Get one BadgeType
     * const badgeType = await prisma.badgeType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeTypeClient<$Result.GetResult<Prisma.$BadgeTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BadgeType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeTypeFindFirstArgs} args - Arguments to find a BadgeType
     * @example
     * // Get one BadgeType
     * const badgeType = await prisma.badgeType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeTypeFindFirstArgs>(args?: SelectSubset<T, BadgeTypeFindFirstArgs<ExtArgs>>): Prisma__BadgeTypeClient<$Result.GetResult<Prisma.$BadgeTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BadgeType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeTypeFindFirstOrThrowArgs} args - Arguments to find a BadgeType
     * @example
     * // Get one BadgeType
     * const badgeType = await prisma.badgeType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeTypeClient<$Result.GetResult<Prisma.$BadgeTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BadgeTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BadgeTypes
     * const badgeTypes = await prisma.badgeType.findMany()
     * 
     * // Get first 10 BadgeTypes
     * const badgeTypes = await prisma.badgeType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeTypeWithIdOnly = await prisma.badgeType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeTypeFindManyArgs>(args?: SelectSubset<T, BadgeTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgeTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BadgeType.
     * @param {BadgeTypeCreateArgs} args - Arguments to create a BadgeType.
     * @example
     * // Create one BadgeType
     * const BadgeType = await prisma.badgeType.create({
     *   data: {
     *     // ... data to create a BadgeType
     *   }
     * })
     * 
     */
    create<T extends BadgeTypeCreateArgs>(args: SelectSubset<T, BadgeTypeCreateArgs<ExtArgs>>): Prisma__BadgeTypeClient<$Result.GetResult<Prisma.$BadgeTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BadgeTypes.
     * @param {BadgeTypeCreateManyArgs} args - Arguments to create many BadgeTypes.
     * @example
     * // Create many BadgeTypes
     * const badgeType = await prisma.badgeType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeTypeCreateManyArgs>(args?: SelectSubset<T, BadgeTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BadgeTypes and returns the data saved in the database.
     * @param {BadgeTypeCreateManyAndReturnArgs} args - Arguments to create many BadgeTypes.
     * @example
     * // Create many BadgeTypes
     * const badgeType = await prisma.badgeType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BadgeTypes and only return the `id`
     * const badgeTypeWithIdOnly = await prisma.badgeType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgeTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgeTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgeTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BadgeType.
     * @param {BadgeTypeDeleteArgs} args - Arguments to delete one BadgeType.
     * @example
     * // Delete one BadgeType
     * const BadgeType = await prisma.badgeType.delete({
     *   where: {
     *     // ... filter to delete one BadgeType
     *   }
     * })
     * 
     */
    delete<T extends BadgeTypeDeleteArgs>(args: SelectSubset<T, BadgeTypeDeleteArgs<ExtArgs>>): Prisma__BadgeTypeClient<$Result.GetResult<Prisma.$BadgeTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BadgeType.
     * @param {BadgeTypeUpdateArgs} args - Arguments to update one BadgeType.
     * @example
     * // Update one BadgeType
     * const badgeType = await prisma.badgeType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeTypeUpdateArgs>(args: SelectSubset<T, BadgeTypeUpdateArgs<ExtArgs>>): Prisma__BadgeTypeClient<$Result.GetResult<Prisma.$BadgeTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BadgeTypes.
     * @param {BadgeTypeDeleteManyArgs} args - Arguments to filter BadgeTypes to delete.
     * @example
     * // Delete a few BadgeTypes
     * const { count } = await prisma.badgeType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeTypeDeleteManyArgs>(args?: SelectSubset<T, BadgeTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BadgeTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BadgeTypes
     * const badgeType = await prisma.badgeType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeTypeUpdateManyArgs>(args: SelectSubset<T, BadgeTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BadgeTypes and returns the data updated in the database.
     * @param {BadgeTypeUpdateManyAndReturnArgs} args - Arguments to update many BadgeTypes.
     * @example
     * // Update many BadgeTypes
     * const badgeType = await prisma.badgeType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BadgeTypes and only return the `id`
     * const badgeTypeWithIdOnly = await prisma.badgeType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BadgeTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, BadgeTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgeTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BadgeType.
     * @param {BadgeTypeUpsertArgs} args - Arguments to update or create a BadgeType.
     * @example
     * // Update or create a BadgeType
     * const badgeType = await prisma.badgeType.upsert({
     *   create: {
     *     // ... data to create a BadgeType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BadgeType we want to update
     *   }
     * })
     */
    upsert<T extends BadgeTypeUpsertArgs>(args: SelectSubset<T, BadgeTypeUpsertArgs<ExtArgs>>): Prisma__BadgeTypeClient<$Result.GetResult<Prisma.$BadgeTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BadgeTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeTypeCountArgs} args - Arguments to filter BadgeTypes to count.
     * @example
     * // Count the number of BadgeTypes
     * const count = await prisma.badgeType.count({
     *   where: {
     *     // ... the filter for the BadgeTypes we want to count
     *   }
     * })
    **/
    count<T extends BadgeTypeCountArgs>(
      args?: Subset<T, BadgeTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BadgeType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeTypeAggregateArgs>(args: Subset<T, BadgeTypeAggregateArgs>): Prisma.PrismaPromise<GetBadgeTypeAggregateType<T>>

    /**
     * Group by BadgeType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeTypeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BadgeType model
   */
  readonly fields: BadgeTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BadgeType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badges<T extends BadgeType$badgesArgs<ExtArgs> = {}>(args?: Subset<T, BadgeType$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BadgeType model
   */
  interface BadgeTypeFieldRefs {
    readonly id: FieldRef<"BadgeType", 'Int'>
    readonly title: FieldRef<"BadgeType", 'String'>
    readonly image_url: FieldRef<"BadgeType", 'String'>
    readonly created_at: FieldRef<"BadgeType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BadgeType findUnique
   */
  export type BadgeTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeType
     */
    select?: BadgeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeType
     */
    omit?: BadgeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeTypeInclude<ExtArgs> | null
    /**
     * Filter, which BadgeType to fetch.
     */
    where: BadgeTypeWhereUniqueInput
  }

  /**
   * BadgeType findUniqueOrThrow
   */
  export type BadgeTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeType
     */
    select?: BadgeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeType
     */
    omit?: BadgeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeTypeInclude<ExtArgs> | null
    /**
     * Filter, which BadgeType to fetch.
     */
    where: BadgeTypeWhereUniqueInput
  }

  /**
   * BadgeType findFirst
   */
  export type BadgeTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeType
     */
    select?: BadgeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeType
     */
    omit?: BadgeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeTypeInclude<ExtArgs> | null
    /**
     * Filter, which BadgeType to fetch.
     */
    where?: BadgeTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BadgeTypes to fetch.
     */
    orderBy?: BadgeTypeOrderByWithRelationInput | BadgeTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BadgeTypes.
     */
    cursor?: BadgeTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BadgeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BadgeTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BadgeTypes.
     */
    distinct?: BadgeTypeScalarFieldEnum | BadgeTypeScalarFieldEnum[]
  }

  /**
   * BadgeType findFirstOrThrow
   */
  export type BadgeTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeType
     */
    select?: BadgeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeType
     */
    omit?: BadgeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeTypeInclude<ExtArgs> | null
    /**
     * Filter, which BadgeType to fetch.
     */
    where?: BadgeTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BadgeTypes to fetch.
     */
    orderBy?: BadgeTypeOrderByWithRelationInput | BadgeTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BadgeTypes.
     */
    cursor?: BadgeTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BadgeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BadgeTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BadgeTypes.
     */
    distinct?: BadgeTypeScalarFieldEnum | BadgeTypeScalarFieldEnum[]
  }

  /**
   * BadgeType findMany
   */
  export type BadgeTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeType
     */
    select?: BadgeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeType
     */
    omit?: BadgeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeTypeInclude<ExtArgs> | null
    /**
     * Filter, which BadgeTypes to fetch.
     */
    where?: BadgeTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BadgeTypes to fetch.
     */
    orderBy?: BadgeTypeOrderByWithRelationInput | BadgeTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BadgeTypes.
     */
    cursor?: BadgeTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BadgeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BadgeTypes.
     */
    skip?: number
    distinct?: BadgeTypeScalarFieldEnum | BadgeTypeScalarFieldEnum[]
  }

  /**
   * BadgeType create
   */
  export type BadgeTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeType
     */
    select?: BadgeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeType
     */
    omit?: BadgeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a BadgeType.
     */
    data: XOR<BadgeTypeCreateInput, BadgeTypeUncheckedCreateInput>
  }

  /**
   * BadgeType createMany
   */
  export type BadgeTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BadgeTypes.
     */
    data: BadgeTypeCreateManyInput | BadgeTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BadgeType createManyAndReturn
   */
  export type BadgeTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeType
     */
    select?: BadgeTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeType
     */
    omit?: BadgeTypeOmit<ExtArgs> | null
    /**
     * The data used to create many BadgeTypes.
     */
    data: BadgeTypeCreateManyInput | BadgeTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BadgeType update
   */
  export type BadgeTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeType
     */
    select?: BadgeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeType
     */
    omit?: BadgeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a BadgeType.
     */
    data: XOR<BadgeTypeUpdateInput, BadgeTypeUncheckedUpdateInput>
    /**
     * Choose, which BadgeType to update.
     */
    where: BadgeTypeWhereUniqueInput
  }

  /**
   * BadgeType updateMany
   */
  export type BadgeTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BadgeTypes.
     */
    data: XOR<BadgeTypeUpdateManyMutationInput, BadgeTypeUncheckedUpdateManyInput>
    /**
     * Filter which BadgeTypes to update
     */
    where?: BadgeTypeWhereInput
    /**
     * Limit how many BadgeTypes to update.
     */
    limit?: number
  }

  /**
   * BadgeType updateManyAndReturn
   */
  export type BadgeTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeType
     */
    select?: BadgeTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeType
     */
    omit?: BadgeTypeOmit<ExtArgs> | null
    /**
     * The data used to update BadgeTypes.
     */
    data: XOR<BadgeTypeUpdateManyMutationInput, BadgeTypeUncheckedUpdateManyInput>
    /**
     * Filter which BadgeTypes to update
     */
    where?: BadgeTypeWhereInput
    /**
     * Limit how many BadgeTypes to update.
     */
    limit?: number
  }

  /**
   * BadgeType upsert
   */
  export type BadgeTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeType
     */
    select?: BadgeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeType
     */
    omit?: BadgeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the BadgeType to update in case it exists.
     */
    where: BadgeTypeWhereUniqueInput
    /**
     * In case the BadgeType found by the `where` argument doesn't exist, create a new BadgeType with this data.
     */
    create: XOR<BadgeTypeCreateInput, BadgeTypeUncheckedCreateInput>
    /**
     * In case the BadgeType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeTypeUpdateInput, BadgeTypeUncheckedUpdateInput>
  }

  /**
   * BadgeType delete
   */
  export type BadgeTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeType
     */
    select?: BadgeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeType
     */
    omit?: BadgeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeTypeInclude<ExtArgs> | null
    /**
     * Filter which BadgeType to delete.
     */
    where: BadgeTypeWhereUniqueInput
  }

  /**
   * BadgeType deleteMany
   */
  export type BadgeTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BadgeTypes to delete
     */
    where?: BadgeTypeWhereInput
    /**
     * Limit how many BadgeTypes to delete.
     */
    limit?: number
  }

  /**
   * BadgeType.badges
   */
  export type BadgeType$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    cursor?: BadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * BadgeType without action
   */
  export type BadgeTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeType
     */
    select?: BadgeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeType
     */
    omit?: BadgeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeTypeInclude<ExtArgs> | null
  }


  /**
   * Model Badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    challenge_id: number | null
    badge_type_id: number | null
  }

  export type BadgeSumAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    challenge_id: number | null
    badge_type_id: number | null
  }

  export type BadgeMinAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    challenge_id: number | null
    badge_type_id: number | null
    earned_at: Date | null
  }

  export type BadgeMaxAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    challenge_id: number | null
    badge_type_id: number | null
    earned_at: Date | null
  }

  export type BadgeCountAggregateOutputType = {
    id: number
    user_id: number
    challenge_id: number
    badge_type_id: number
    earned_at: number
    _all: number
  }


  export type BadgeAvgAggregateInputType = {
    id?: true
    user_id?: true
    challenge_id?: true
    badge_type_id?: true
  }

  export type BadgeSumAggregateInputType = {
    id?: true
    user_id?: true
    challenge_id?: true
    badge_type_id?: true
  }

  export type BadgeMinAggregateInputType = {
    id?: true
    user_id?: true
    challenge_id?: true
    badge_type_id?: true
    earned_at?: true
  }

  export type BadgeMaxAggregateInputType = {
    id?: true
    user_id?: true
    challenge_id?: true
    badge_type_id?: true
    earned_at?: true
  }

  export type BadgeCountAggregateInputType = {
    id?: true
    user_id?: true
    challenge_id?: true
    badge_type_id?: true
    earned_at?: true
    _all?: true
  }

  export type BadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badge to aggregate.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type BadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithAggregationInput | BadgeOrderByWithAggregationInput[]
    by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum
    having?: BadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _avg?: BadgeAvgAggregateInputType
    _sum?: BadgeSumAggregateInputType
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }

  export type BadgeGroupByOutputType = {
    id: number
    user_id: bigint
    challenge_id: number
    badge_type_id: number
    earned_at: Date
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends BadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type BadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    challenge_id?: boolean
    badge_type_id?: boolean
    earned_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    badge_type?: boolean | BadgeTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    challenge_id?: boolean
    badge_type_id?: boolean
    earned_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    badge_type?: boolean | BadgeTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    challenge_id?: boolean
    badge_type_id?: boolean
    earned_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    badge_type?: boolean | BadgeTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectScalar = {
    id?: boolean
    user_id?: boolean
    challenge_id?: boolean
    badge_type_id?: boolean
    earned_at?: boolean
  }

  export type BadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "challenge_id" | "badge_type_id" | "earned_at", ExtArgs["result"]["badge"]>
  export type BadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    badge_type?: boolean | BadgeTypeDefaultArgs<ExtArgs>
  }
  export type BadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    badge_type?: boolean | BadgeTypeDefaultArgs<ExtArgs>
  }
  export type BadgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    badge_type?: boolean | BadgeTypeDefaultArgs<ExtArgs>
  }

  export type $BadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Badge"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      challenge: Prisma.$ChallengePayload<ExtArgs>
      badge_type: Prisma.$BadgeTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: bigint
      challenge_id: number
      badge_type_id: number
      earned_at: Date
    }, ExtArgs["result"]["badge"]>
    composites: {}
  }

  type BadgeGetPayload<S extends boolean | null | undefined | BadgeDefaultArgs> = $Result.GetResult<Prisma.$BadgePayload, S>

  type BadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BadgeCountAggregateInputType | true
    }

  export interface BadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Badge'], meta: { name: 'Badge' } }
    /**
     * Find zero or one Badge that matches the filter.
     * @param {BadgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeFindUniqueArgs>(args: SelectSubset<T, BadgeFindUniqueArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BadgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeFindFirstArgs>(args?: SelectSubset<T, BadgeFindFirstArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeFindManyArgs>(args?: SelectSubset<T, BadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Badge.
     * @param {BadgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
     */
    create<T extends BadgeCreateArgs>(args: SelectSubset<T, BadgeCreateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Badges.
     * @param {BadgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeCreateManyArgs>(args?: SelectSubset<T, BadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {BadgeCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Badge.
     * @param {BadgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
     */
    delete<T extends BadgeDeleteArgs>(args: SelectSubset<T, BadgeDeleteArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Badge.
     * @param {BadgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeUpdateArgs>(args: SelectSubset<T, BadgeUpdateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Badges.
     * @param {BadgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeDeleteManyArgs>(args?: SelectSubset<T, BadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeUpdateManyArgs>(args: SelectSubset<T, BadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges and returns the data updated in the database.
     * @param {BadgeUpdateManyAndReturnArgs} args - Arguments to update many Badges.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BadgeUpdateManyAndReturnArgs>(args: SelectSubset<T, BadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Badge.
     * @param {BadgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends BadgeUpsertArgs>(args: SelectSubset<T, BadgeUpsertArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends BadgeCountArgs>(
      args?: Subset<T, BadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): Prisma.PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Badge model
   */
  readonly fields: BadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    badge_type<T extends BadgeTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BadgeTypeDefaultArgs<ExtArgs>>): Prisma__BadgeTypeClient<$Result.GetResult<Prisma.$BadgeTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Badge model
   */
  interface BadgeFieldRefs {
    readonly id: FieldRef<"Badge", 'Int'>
    readonly user_id: FieldRef<"Badge", 'BigInt'>
    readonly challenge_id: FieldRef<"Badge", 'Int'>
    readonly badge_type_id: FieldRef<"Badge", 'Int'>
    readonly earned_at: FieldRef<"Badge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Badge findUnique
   */
  export type BadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findUniqueOrThrow
   */
  export type BadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findFirst
   */
  export type BadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findFirstOrThrow
   */
  export type BadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findMany
   */
  export type BadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge create
   */
  export type BadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Badge.
     */
    data: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
  }

  /**
   * Badge createMany
   */
  export type BadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge createManyAndReturn
   */
  export type BadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Badge update
   */
  export type BadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Badge.
     */
    data: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
    /**
     * Choose, which Badge to update.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge updateMany
   */
  export type BadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
  }

  /**
   * Badge updateManyAndReturn
   */
  export type BadgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Badge upsert
   */
  export type BadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Badge to update in case it exists.
     */
    where: BadgeWhereUniqueInput
    /**
     * In case the Badge found by the `where` argument doesn't exist, create a new Badge with this data.
     */
    create: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
    /**
     * In case the Badge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
  }

  /**
   * Badge delete
   */
  export type BadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter which Badge to delete.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge deleteMany
   */
  export type BadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badges to delete
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to delete.
     */
    limit?: number
  }

  /**
   * Badge without action
   */
  export type BadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
  }


  /**
   * Model StampBook
   */

  export type AggregateStampBook = {
    _count: StampBookCountAggregateOutputType | null
    _avg: StampBookAvgAggregateOutputType | null
    _sum: StampBookSumAggregateOutputType | null
    _min: StampBookMinAggregateOutputType | null
    _max: StampBookMaxAggregateOutputType | null
  }

  export type StampBookAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    cafe_id: number | null
    current_count: number | null
    goal_count: number | null
  }

  export type StampBookSumAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    cafe_id: bigint | null
    current_count: number | null
    goal_count: number | null
  }

  export type StampBookMinAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    cafe_id: bigint | null
    current_count: number | null
    goal_count: number | null
    reward_detail: string | null
    started_at: Date | null
    last_visited_at: Date | null
    expires_at: Date | null
    extended_at: Date | null
    expired_at: Date | null
    completed_at: Date | null
    converted_at: Date | null
    status: string | null
    is_completed: boolean | null
    is_converted: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StampBookMaxAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    cafe_id: bigint | null
    current_count: number | null
    goal_count: number | null
    reward_detail: string | null
    started_at: Date | null
    last_visited_at: Date | null
    expires_at: Date | null
    extended_at: Date | null
    expired_at: Date | null
    completed_at: Date | null
    converted_at: Date | null
    status: string | null
    is_completed: boolean | null
    is_converted: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StampBookCountAggregateOutputType = {
    id: number
    user_id: number
    cafe_id: number
    current_count: number
    goal_count: number
    reward_detail: number
    started_at: number
    last_visited_at: number
    expires_at: number
    extended_at: number
    expired_at: number
    completed_at: number
    converted_at: number
    status: number
    is_completed: number
    is_converted: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type StampBookAvgAggregateInputType = {
    id?: true
    user_id?: true
    cafe_id?: true
    current_count?: true
    goal_count?: true
  }

  export type StampBookSumAggregateInputType = {
    id?: true
    user_id?: true
    cafe_id?: true
    current_count?: true
    goal_count?: true
  }

  export type StampBookMinAggregateInputType = {
    id?: true
    user_id?: true
    cafe_id?: true
    current_count?: true
    goal_count?: true
    reward_detail?: true
    started_at?: true
    last_visited_at?: true
    expires_at?: true
    extended_at?: true
    expired_at?: true
    completed_at?: true
    converted_at?: true
    status?: true
    is_completed?: true
    is_converted?: true
    created_at?: true
    updated_at?: true
  }

  export type StampBookMaxAggregateInputType = {
    id?: true
    user_id?: true
    cafe_id?: true
    current_count?: true
    goal_count?: true
    reward_detail?: true
    started_at?: true
    last_visited_at?: true
    expires_at?: true
    extended_at?: true
    expired_at?: true
    completed_at?: true
    converted_at?: true
    status?: true
    is_completed?: true
    is_converted?: true
    created_at?: true
    updated_at?: true
  }

  export type StampBookCountAggregateInputType = {
    id?: true
    user_id?: true
    cafe_id?: true
    current_count?: true
    goal_count?: true
    reward_detail?: true
    started_at?: true
    last_visited_at?: true
    expires_at?: true
    extended_at?: true
    expired_at?: true
    completed_at?: true
    converted_at?: true
    status?: true
    is_completed?: true
    is_converted?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type StampBookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StampBook to aggregate.
     */
    where?: StampBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StampBooks to fetch.
     */
    orderBy?: StampBookOrderByWithRelationInput | StampBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StampBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StampBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StampBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StampBooks
    **/
    _count?: true | StampBookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StampBookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StampBookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StampBookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StampBookMaxAggregateInputType
  }

  export type GetStampBookAggregateType<T extends StampBookAggregateArgs> = {
        [P in keyof T & keyof AggregateStampBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStampBook[P]>
      : GetScalarType<T[P], AggregateStampBook[P]>
  }




  export type StampBookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StampBookWhereInput
    orderBy?: StampBookOrderByWithAggregationInput | StampBookOrderByWithAggregationInput[]
    by: StampBookScalarFieldEnum[] | StampBookScalarFieldEnum
    having?: StampBookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StampBookCountAggregateInputType | true
    _avg?: StampBookAvgAggregateInputType
    _sum?: StampBookSumAggregateInputType
    _min?: StampBookMinAggregateInputType
    _max?: StampBookMaxAggregateInputType
  }

  export type StampBookGroupByOutputType = {
    id: number
    user_id: bigint
    cafe_id: bigint
    current_count: number
    goal_count: number
    reward_detail: string
    started_at: Date
    last_visited_at: Date
    expires_at: Date
    extended_at: Date
    expired_at: Date
    completed_at: Date
    converted_at: Date
    status: string
    is_completed: boolean
    is_converted: boolean
    created_at: Date
    updated_at: Date
    _count: StampBookCountAggregateOutputType | null
    _avg: StampBookAvgAggregateOutputType | null
    _sum: StampBookSumAggregateOutputType | null
    _min: StampBookMinAggregateOutputType | null
    _max: StampBookMaxAggregateOutputType | null
  }

  type GetStampBookGroupByPayload<T extends StampBookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StampBookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StampBookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StampBookGroupByOutputType[P]>
            : GetScalarType<T[P], StampBookGroupByOutputType[P]>
        }
      >
    >


  export type StampBookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    cafe_id?: boolean
    current_count?: boolean
    goal_count?: boolean
    reward_detail?: boolean
    started_at?: boolean
    last_visited_at?: boolean
    expires_at?: boolean
    extended_at?: boolean
    expired_at?: boolean
    completed_at?: boolean
    converted_at?: boolean
    status?: boolean
    is_completed?: boolean
    is_converted?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
    stamps?: boolean | StampBook$stampsArgs<ExtArgs>
    point_transactions?: boolean | StampBook$point_transactionsArgs<ExtArgs>
    _count?: boolean | StampBookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stampBook"]>

  export type StampBookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    cafe_id?: boolean
    current_count?: boolean
    goal_count?: boolean
    reward_detail?: boolean
    started_at?: boolean
    last_visited_at?: boolean
    expires_at?: boolean
    extended_at?: boolean
    expired_at?: boolean
    completed_at?: boolean
    converted_at?: boolean
    status?: boolean
    is_completed?: boolean
    is_converted?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stampBook"]>

  export type StampBookSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    cafe_id?: boolean
    current_count?: boolean
    goal_count?: boolean
    reward_detail?: boolean
    started_at?: boolean
    last_visited_at?: boolean
    expires_at?: boolean
    extended_at?: boolean
    expired_at?: boolean
    completed_at?: boolean
    converted_at?: boolean
    status?: boolean
    is_completed?: boolean
    is_converted?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stampBook"]>

  export type StampBookSelectScalar = {
    id?: boolean
    user_id?: boolean
    cafe_id?: boolean
    current_count?: boolean
    goal_count?: boolean
    reward_detail?: boolean
    started_at?: boolean
    last_visited_at?: boolean
    expires_at?: boolean
    extended_at?: boolean
    expired_at?: boolean
    completed_at?: boolean
    converted_at?: boolean
    status?: boolean
    is_completed?: boolean
    is_converted?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type StampBookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "cafe_id" | "current_count" | "goal_count" | "reward_detail" | "started_at" | "last_visited_at" | "expires_at" | "extended_at" | "expired_at" | "completed_at" | "converted_at" | "status" | "is_completed" | "is_converted" | "created_at" | "updated_at", ExtArgs["result"]["stampBook"]>
  export type StampBookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
    stamps?: boolean | StampBook$stampsArgs<ExtArgs>
    point_transactions?: boolean | StampBook$point_transactionsArgs<ExtArgs>
    _count?: boolean | StampBookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StampBookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }
  export type StampBookIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }

  export type $StampBookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StampBook"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      cafe: Prisma.$CafePayload<ExtArgs>
      stamps: Prisma.$StampPayload<ExtArgs>[]
      point_transactions: Prisma.$PointTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: bigint
      cafe_id: bigint
      current_count: number
      goal_count: number
      reward_detail: string
      started_at: Date
      last_visited_at: Date
      expires_at: Date
      extended_at: Date
      expired_at: Date
      completed_at: Date
      converted_at: Date
      status: string
      is_completed: boolean
      is_converted: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["stampBook"]>
    composites: {}
  }

  type StampBookGetPayload<S extends boolean | null | undefined | StampBookDefaultArgs> = $Result.GetResult<Prisma.$StampBookPayload, S>

  type StampBookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StampBookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StampBookCountAggregateInputType | true
    }

  export interface StampBookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StampBook'], meta: { name: 'StampBook' } }
    /**
     * Find zero or one StampBook that matches the filter.
     * @param {StampBookFindUniqueArgs} args - Arguments to find a StampBook
     * @example
     * // Get one StampBook
     * const stampBook = await prisma.stampBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StampBookFindUniqueArgs>(args: SelectSubset<T, StampBookFindUniqueArgs<ExtArgs>>): Prisma__StampBookClient<$Result.GetResult<Prisma.$StampBookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StampBook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StampBookFindUniqueOrThrowArgs} args - Arguments to find a StampBook
     * @example
     * // Get one StampBook
     * const stampBook = await prisma.stampBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StampBookFindUniqueOrThrowArgs>(args: SelectSubset<T, StampBookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StampBookClient<$Result.GetResult<Prisma.$StampBookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StampBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampBookFindFirstArgs} args - Arguments to find a StampBook
     * @example
     * // Get one StampBook
     * const stampBook = await prisma.stampBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StampBookFindFirstArgs>(args?: SelectSubset<T, StampBookFindFirstArgs<ExtArgs>>): Prisma__StampBookClient<$Result.GetResult<Prisma.$StampBookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StampBook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampBookFindFirstOrThrowArgs} args - Arguments to find a StampBook
     * @example
     * // Get one StampBook
     * const stampBook = await prisma.stampBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StampBookFindFirstOrThrowArgs>(args?: SelectSubset<T, StampBookFindFirstOrThrowArgs<ExtArgs>>): Prisma__StampBookClient<$Result.GetResult<Prisma.$StampBookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StampBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampBookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StampBooks
     * const stampBooks = await prisma.stampBook.findMany()
     * 
     * // Get first 10 StampBooks
     * const stampBooks = await prisma.stampBook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stampBookWithIdOnly = await prisma.stampBook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StampBookFindManyArgs>(args?: SelectSubset<T, StampBookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StampBookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StampBook.
     * @param {StampBookCreateArgs} args - Arguments to create a StampBook.
     * @example
     * // Create one StampBook
     * const StampBook = await prisma.stampBook.create({
     *   data: {
     *     // ... data to create a StampBook
     *   }
     * })
     * 
     */
    create<T extends StampBookCreateArgs>(args: SelectSubset<T, StampBookCreateArgs<ExtArgs>>): Prisma__StampBookClient<$Result.GetResult<Prisma.$StampBookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StampBooks.
     * @param {StampBookCreateManyArgs} args - Arguments to create many StampBooks.
     * @example
     * // Create many StampBooks
     * const stampBook = await prisma.stampBook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StampBookCreateManyArgs>(args?: SelectSubset<T, StampBookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StampBooks and returns the data saved in the database.
     * @param {StampBookCreateManyAndReturnArgs} args - Arguments to create many StampBooks.
     * @example
     * // Create many StampBooks
     * const stampBook = await prisma.stampBook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StampBooks and only return the `id`
     * const stampBookWithIdOnly = await prisma.stampBook.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StampBookCreateManyAndReturnArgs>(args?: SelectSubset<T, StampBookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StampBookPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StampBook.
     * @param {StampBookDeleteArgs} args - Arguments to delete one StampBook.
     * @example
     * // Delete one StampBook
     * const StampBook = await prisma.stampBook.delete({
     *   where: {
     *     // ... filter to delete one StampBook
     *   }
     * })
     * 
     */
    delete<T extends StampBookDeleteArgs>(args: SelectSubset<T, StampBookDeleteArgs<ExtArgs>>): Prisma__StampBookClient<$Result.GetResult<Prisma.$StampBookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StampBook.
     * @param {StampBookUpdateArgs} args - Arguments to update one StampBook.
     * @example
     * // Update one StampBook
     * const stampBook = await prisma.stampBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StampBookUpdateArgs>(args: SelectSubset<T, StampBookUpdateArgs<ExtArgs>>): Prisma__StampBookClient<$Result.GetResult<Prisma.$StampBookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StampBooks.
     * @param {StampBookDeleteManyArgs} args - Arguments to filter StampBooks to delete.
     * @example
     * // Delete a few StampBooks
     * const { count } = await prisma.stampBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StampBookDeleteManyArgs>(args?: SelectSubset<T, StampBookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StampBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StampBooks
     * const stampBook = await prisma.stampBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StampBookUpdateManyArgs>(args: SelectSubset<T, StampBookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StampBooks and returns the data updated in the database.
     * @param {StampBookUpdateManyAndReturnArgs} args - Arguments to update many StampBooks.
     * @example
     * // Update many StampBooks
     * const stampBook = await prisma.stampBook.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StampBooks and only return the `id`
     * const stampBookWithIdOnly = await prisma.stampBook.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StampBookUpdateManyAndReturnArgs>(args: SelectSubset<T, StampBookUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StampBookPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StampBook.
     * @param {StampBookUpsertArgs} args - Arguments to update or create a StampBook.
     * @example
     * // Update or create a StampBook
     * const stampBook = await prisma.stampBook.upsert({
     *   create: {
     *     // ... data to create a StampBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StampBook we want to update
     *   }
     * })
     */
    upsert<T extends StampBookUpsertArgs>(args: SelectSubset<T, StampBookUpsertArgs<ExtArgs>>): Prisma__StampBookClient<$Result.GetResult<Prisma.$StampBookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StampBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampBookCountArgs} args - Arguments to filter StampBooks to count.
     * @example
     * // Count the number of StampBooks
     * const count = await prisma.stampBook.count({
     *   where: {
     *     // ... the filter for the StampBooks we want to count
     *   }
     * })
    **/
    count<T extends StampBookCountArgs>(
      args?: Subset<T, StampBookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StampBookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StampBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StampBookAggregateArgs>(args: Subset<T, StampBookAggregateArgs>): Prisma.PrismaPromise<GetStampBookAggregateType<T>>

    /**
     * Group by StampBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StampBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StampBookGroupByArgs['orderBy'] }
        : { orderBy?: StampBookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StampBookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStampBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StampBook model
   */
  readonly fields: StampBookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StampBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StampBookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cafe<T extends CafeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CafeDefaultArgs<ExtArgs>>): Prisma__CafeClient<$Result.GetResult<Prisma.$CafePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stamps<T extends StampBook$stampsArgs<ExtArgs> = {}>(args?: Subset<T, StampBook$stampsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StampPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    point_transactions<T extends StampBook$point_transactionsArgs<ExtArgs> = {}>(args?: Subset<T, StampBook$point_transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StampBook model
   */
  interface StampBookFieldRefs {
    readonly id: FieldRef<"StampBook", 'Int'>
    readonly user_id: FieldRef<"StampBook", 'BigInt'>
    readonly cafe_id: FieldRef<"StampBook", 'BigInt'>
    readonly current_count: FieldRef<"StampBook", 'Int'>
    readonly goal_count: FieldRef<"StampBook", 'Int'>
    readonly reward_detail: FieldRef<"StampBook", 'String'>
    readonly started_at: FieldRef<"StampBook", 'DateTime'>
    readonly last_visited_at: FieldRef<"StampBook", 'DateTime'>
    readonly expires_at: FieldRef<"StampBook", 'DateTime'>
    readonly extended_at: FieldRef<"StampBook", 'DateTime'>
    readonly expired_at: FieldRef<"StampBook", 'DateTime'>
    readonly completed_at: FieldRef<"StampBook", 'DateTime'>
    readonly converted_at: FieldRef<"StampBook", 'DateTime'>
    readonly status: FieldRef<"StampBook", 'String'>
    readonly is_completed: FieldRef<"StampBook", 'Boolean'>
    readonly is_converted: FieldRef<"StampBook", 'Boolean'>
    readonly created_at: FieldRef<"StampBook", 'DateTime'>
    readonly updated_at: FieldRef<"StampBook", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StampBook findUnique
   */
  export type StampBookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StampBook
     */
    select?: StampBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StampBook
     */
    omit?: StampBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampBookInclude<ExtArgs> | null
    /**
     * Filter, which StampBook to fetch.
     */
    where: StampBookWhereUniqueInput
  }

  /**
   * StampBook findUniqueOrThrow
   */
  export type StampBookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StampBook
     */
    select?: StampBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StampBook
     */
    omit?: StampBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampBookInclude<ExtArgs> | null
    /**
     * Filter, which StampBook to fetch.
     */
    where: StampBookWhereUniqueInput
  }

  /**
   * StampBook findFirst
   */
  export type StampBookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StampBook
     */
    select?: StampBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StampBook
     */
    omit?: StampBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampBookInclude<ExtArgs> | null
    /**
     * Filter, which StampBook to fetch.
     */
    where?: StampBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StampBooks to fetch.
     */
    orderBy?: StampBookOrderByWithRelationInput | StampBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StampBooks.
     */
    cursor?: StampBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StampBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StampBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StampBooks.
     */
    distinct?: StampBookScalarFieldEnum | StampBookScalarFieldEnum[]
  }

  /**
   * StampBook findFirstOrThrow
   */
  export type StampBookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StampBook
     */
    select?: StampBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StampBook
     */
    omit?: StampBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampBookInclude<ExtArgs> | null
    /**
     * Filter, which StampBook to fetch.
     */
    where?: StampBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StampBooks to fetch.
     */
    orderBy?: StampBookOrderByWithRelationInput | StampBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StampBooks.
     */
    cursor?: StampBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StampBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StampBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StampBooks.
     */
    distinct?: StampBookScalarFieldEnum | StampBookScalarFieldEnum[]
  }

  /**
   * StampBook findMany
   */
  export type StampBookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StampBook
     */
    select?: StampBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StampBook
     */
    omit?: StampBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampBookInclude<ExtArgs> | null
    /**
     * Filter, which StampBooks to fetch.
     */
    where?: StampBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StampBooks to fetch.
     */
    orderBy?: StampBookOrderByWithRelationInput | StampBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StampBooks.
     */
    cursor?: StampBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StampBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StampBooks.
     */
    skip?: number
    distinct?: StampBookScalarFieldEnum | StampBookScalarFieldEnum[]
  }

  /**
   * StampBook create
   */
  export type StampBookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StampBook
     */
    select?: StampBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StampBook
     */
    omit?: StampBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampBookInclude<ExtArgs> | null
    /**
     * The data needed to create a StampBook.
     */
    data: XOR<StampBookCreateInput, StampBookUncheckedCreateInput>
  }

  /**
   * StampBook createMany
   */
  export type StampBookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StampBooks.
     */
    data: StampBookCreateManyInput | StampBookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StampBook createManyAndReturn
   */
  export type StampBookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StampBook
     */
    select?: StampBookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StampBook
     */
    omit?: StampBookOmit<ExtArgs> | null
    /**
     * The data used to create many StampBooks.
     */
    data: StampBookCreateManyInput | StampBookCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampBookIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StampBook update
   */
  export type StampBookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StampBook
     */
    select?: StampBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StampBook
     */
    omit?: StampBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampBookInclude<ExtArgs> | null
    /**
     * The data needed to update a StampBook.
     */
    data: XOR<StampBookUpdateInput, StampBookUncheckedUpdateInput>
    /**
     * Choose, which StampBook to update.
     */
    where: StampBookWhereUniqueInput
  }

  /**
   * StampBook updateMany
   */
  export type StampBookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StampBooks.
     */
    data: XOR<StampBookUpdateManyMutationInput, StampBookUncheckedUpdateManyInput>
    /**
     * Filter which StampBooks to update
     */
    where?: StampBookWhereInput
    /**
     * Limit how many StampBooks to update.
     */
    limit?: number
  }

  /**
   * StampBook updateManyAndReturn
   */
  export type StampBookUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StampBook
     */
    select?: StampBookSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StampBook
     */
    omit?: StampBookOmit<ExtArgs> | null
    /**
     * The data used to update StampBooks.
     */
    data: XOR<StampBookUpdateManyMutationInput, StampBookUncheckedUpdateManyInput>
    /**
     * Filter which StampBooks to update
     */
    where?: StampBookWhereInput
    /**
     * Limit how many StampBooks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampBookIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StampBook upsert
   */
  export type StampBookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StampBook
     */
    select?: StampBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StampBook
     */
    omit?: StampBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampBookInclude<ExtArgs> | null
    /**
     * The filter to search for the StampBook to update in case it exists.
     */
    where: StampBookWhereUniqueInput
    /**
     * In case the StampBook found by the `where` argument doesn't exist, create a new StampBook with this data.
     */
    create: XOR<StampBookCreateInput, StampBookUncheckedCreateInput>
    /**
     * In case the StampBook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StampBookUpdateInput, StampBookUncheckedUpdateInput>
  }

  /**
   * StampBook delete
   */
  export type StampBookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StampBook
     */
    select?: StampBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StampBook
     */
    omit?: StampBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampBookInclude<ExtArgs> | null
    /**
     * Filter which StampBook to delete.
     */
    where: StampBookWhereUniqueInput
  }

  /**
   * StampBook deleteMany
   */
  export type StampBookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StampBooks to delete
     */
    where?: StampBookWhereInput
    /**
     * Limit how many StampBooks to delete.
     */
    limit?: number
  }

  /**
   * StampBook.stamps
   */
  export type StampBook$stampsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stamp
     */
    omit?: StampOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampInclude<ExtArgs> | null
    where?: StampWhereInput
    orderBy?: StampOrderByWithRelationInput | StampOrderByWithRelationInput[]
    cursor?: StampWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StampScalarFieldEnum | StampScalarFieldEnum[]
  }

  /**
   * StampBook.point_transactions
   */
  export type StampBook$point_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    where?: PointTransactionWhereInput
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    cursor?: PointTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PointTransactionScalarFieldEnum | PointTransactionScalarFieldEnum[]
  }

  /**
   * StampBook without action
   */
  export type StampBookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StampBook
     */
    select?: StampBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StampBook
     */
    omit?: StampBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampBookInclude<ExtArgs> | null
  }


  /**
   * Model Stamp
   */

  export type AggregateStamp = {
    _count: StampCountAggregateOutputType | null
    _avg: StampAvgAggregateOutputType | null
    _sum: StampSumAggregateOutputType | null
    _min: StampMinAggregateOutputType | null
    _max: StampMaxAggregateOutputType | null
  }

  export type StampAvgAggregateOutputType = {
    id: number | null
    stamp_book_id: number | null
    latitude: number | null
    longitude: number | null
  }

  export type StampSumAggregateOutputType = {
    id: number | null
    stamp_book_id: number | null
    latitude: number | null
    longitude: number | null
  }

  export type StampMinAggregateOutputType = {
    id: number | null
    stamp_book_id: number | null
    stamp_image_url: string | null
    stamped_at: Date | null
    source: string | null
    note: string | null
    latitude: number | null
    longitude: number | null
  }

  export type StampMaxAggregateOutputType = {
    id: number | null
    stamp_book_id: number | null
    stamp_image_url: string | null
    stamped_at: Date | null
    source: string | null
    note: string | null
    latitude: number | null
    longitude: number | null
  }

  export type StampCountAggregateOutputType = {
    id: number
    stamp_book_id: number
    stamp_image_url: number
    stamped_at: number
    source: number
    note: number
    latitude: number
    longitude: number
    _all: number
  }


  export type StampAvgAggregateInputType = {
    id?: true
    stamp_book_id?: true
    latitude?: true
    longitude?: true
  }

  export type StampSumAggregateInputType = {
    id?: true
    stamp_book_id?: true
    latitude?: true
    longitude?: true
  }

  export type StampMinAggregateInputType = {
    id?: true
    stamp_book_id?: true
    stamp_image_url?: true
    stamped_at?: true
    source?: true
    note?: true
    latitude?: true
    longitude?: true
  }

  export type StampMaxAggregateInputType = {
    id?: true
    stamp_book_id?: true
    stamp_image_url?: true
    stamped_at?: true
    source?: true
    note?: true
    latitude?: true
    longitude?: true
  }

  export type StampCountAggregateInputType = {
    id?: true
    stamp_book_id?: true
    stamp_image_url?: true
    stamped_at?: true
    source?: true
    note?: true
    latitude?: true
    longitude?: true
    _all?: true
  }

  export type StampAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stamp to aggregate.
     */
    where?: StampWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stamps to fetch.
     */
    orderBy?: StampOrderByWithRelationInput | StampOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StampWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stamps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stamps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stamps
    **/
    _count?: true | StampCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StampAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StampSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StampMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StampMaxAggregateInputType
  }

  export type GetStampAggregateType<T extends StampAggregateArgs> = {
        [P in keyof T & keyof AggregateStamp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStamp[P]>
      : GetScalarType<T[P], AggregateStamp[P]>
  }




  export type StampGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StampWhereInput
    orderBy?: StampOrderByWithAggregationInput | StampOrderByWithAggregationInput[]
    by: StampScalarFieldEnum[] | StampScalarFieldEnum
    having?: StampScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StampCountAggregateInputType | true
    _avg?: StampAvgAggregateInputType
    _sum?: StampSumAggregateInputType
    _min?: StampMinAggregateInputType
    _max?: StampMaxAggregateInputType
  }

  export type StampGroupByOutputType = {
    id: number
    stamp_book_id: number
    stamp_image_url: string
    stamped_at: Date
    source: string
    note: string
    latitude: number
    longitude: number
    _count: StampCountAggregateOutputType | null
    _avg: StampAvgAggregateOutputType | null
    _sum: StampSumAggregateOutputType | null
    _min: StampMinAggregateOutputType | null
    _max: StampMaxAggregateOutputType | null
  }

  type GetStampGroupByPayload<T extends StampGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StampGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StampGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StampGroupByOutputType[P]>
            : GetScalarType<T[P], StampGroupByOutputType[P]>
        }
      >
    >


  export type StampSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stamp_book_id?: boolean
    stamp_image_url?: boolean
    stamped_at?: boolean
    source?: boolean
    note?: boolean
    latitude?: boolean
    longitude?: boolean
    stamp_book?: boolean | StampBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stamp"]>

  export type StampSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stamp_book_id?: boolean
    stamp_image_url?: boolean
    stamped_at?: boolean
    source?: boolean
    note?: boolean
    latitude?: boolean
    longitude?: boolean
    stamp_book?: boolean | StampBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stamp"]>

  export type StampSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stamp_book_id?: boolean
    stamp_image_url?: boolean
    stamped_at?: boolean
    source?: boolean
    note?: boolean
    latitude?: boolean
    longitude?: boolean
    stamp_book?: boolean | StampBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stamp"]>

  export type StampSelectScalar = {
    id?: boolean
    stamp_book_id?: boolean
    stamp_image_url?: boolean
    stamped_at?: boolean
    source?: boolean
    note?: boolean
    latitude?: boolean
    longitude?: boolean
  }

  export type StampOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stamp_book_id" | "stamp_image_url" | "stamped_at" | "source" | "note" | "latitude" | "longitude", ExtArgs["result"]["stamp"]>
  export type StampInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stamp_book?: boolean | StampBookDefaultArgs<ExtArgs>
  }
  export type StampIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stamp_book?: boolean | StampBookDefaultArgs<ExtArgs>
  }
  export type StampIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stamp_book?: boolean | StampBookDefaultArgs<ExtArgs>
  }

  export type $StampPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stamp"
    objects: {
      stamp_book: Prisma.$StampBookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      stamp_book_id: number
      stamp_image_url: string
      stamped_at: Date
      source: string
      note: string
      latitude: number
      longitude: number
    }, ExtArgs["result"]["stamp"]>
    composites: {}
  }

  type StampGetPayload<S extends boolean | null | undefined | StampDefaultArgs> = $Result.GetResult<Prisma.$StampPayload, S>

  type StampCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StampFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StampCountAggregateInputType | true
    }

  export interface StampDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stamp'], meta: { name: 'Stamp' } }
    /**
     * Find zero or one Stamp that matches the filter.
     * @param {StampFindUniqueArgs} args - Arguments to find a Stamp
     * @example
     * // Get one Stamp
     * const stamp = await prisma.stamp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StampFindUniqueArgs>(args: SelectSubset<T, StampFindUniqueArgs<ExtArgs>>): Prisma__StampClient<$Result.GetResult<Prisma.$StampPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stamp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StampFindUniqueOrThrowArgs} args - Arguments to find a Stamp
     * @example
     * // Get one Stamp
     * const stamp = await prisma.stamp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StampFindUniqueOrThrowArgs>(args: SelectSubset<T, StampFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StampClient<$Result.GetResult<Prisma.$StampPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stamp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampFindFirstArgs} args - Arguments to find a Stamp
     * @example
     * // Get one Stamp
     * const stamp = await prisma.stamp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StampFindFirstArgs>(args?: SelectSubset<T, StampFindFirstArgs<ExtArgs>>): Prisma__StampClient<$Result.GetResult<Prisma.$StampPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stamp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampFindFirstOrThrowArgs} args - Arguments to find a Stamp
     * @example
     * // Get one Stamp
     * const stamp = await prisma.stamp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StampFindFirstOrThrowArgs>(args?: SelectSubset<T, StampFindFirstOrThrowArgs<ExtArgs>>): Prisma__StampClient<$Result.GetResult<Prisma.$StampPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stamps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stamps
     * const stamps = await prisma.stamp.findMany()
     * 
     * // Get first 10 Stamps
     * const stamps = await prisma.stamp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stampWithIdOnly = await prisma.stamp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StampFindManyArgs>(args?: SelectSubset<T, StampFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StampPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stamp.
     * @param {StampCreateArgs} args - Arguments to create a Stamp.
     * @example
     * // Create one Stamp
     * const Stamp = await prisma.stamp.create({
     *   data: {
     *     // ... data to create a Stamp
     *   }
     * })
     * 
     */
    create<T extends StampCreateArgs>(args: SelectSubset<T, StampCreateArgs<ExtArgs>>): Prisma__StampClient<$Result.GetResult<Prisma.$StampPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stamps.
     * @param {StampCreateManyArgs} args - Arguments to create many Stamps.
     * @example
     * // Create many Stamps
     * const stamp = await prisma.stamp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StampCreateManyArgs>(args?: SelectSubset<T, StampCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stamps and returns the data saved in the database.
     * @param {StampCreateManyAndReturnArgs} args - Arguments to create many Stamps.
     * @example
     * // Create many Stamps
     * const stamp = await prisma.stamp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stamps and only return the `id`
     * const stampWithIdOnly = await prisma.stamp.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StampCreateManyAndReturnArgs>(args?: SelectSubset<T, StampCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StampPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Stamp.
     * @param {StampDeleteArgs} args - Arguments to delete one Stamp.
     * @example
     * // Delete one Stamp
     * const Stamp = await prisma.stamp.delete({
     *   where: {
     *     // ... filter to delete one Stamp
     *   }
     * })
     * 
     */
    delete<T extends StampDeleteArgs>(args: SelectSubset<T, StampDeleteArgs<ExtArgs>>): Prisma__StampClient<$Result.GetResult<Prisma.$StampPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stamp.
     * @param {StampUpdateArgs} args - Arguments to update one Stamp.
     * @example
     * // Update one Stamp
     * const stamp = await prisma.stamp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StampUpdateArgs>(args: SelectSubset<T, StampUpdateArgs<ExtArgs>>): Prisma__StampClient<$Result.GetResult<Prisma.$StampPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stamps.
     * @param {StampDeleteManyArgs} args - Arguments to filter Stamps to delete.
     * @example
     * // Delete a few Stamps
     * const { count } = await prisma.stamp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StampDeleteManyArgs>(args?: SelectSubset<T, StampDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stamps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stamps
     * const stamp = await prisma.stamp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StampUpdateManyArgs>(args: SelectSubset<T, StampUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stamps and returns the data updated in the database.
     * @param {StampUpdateManyAndReturnArgs} args - Arguments to update many Stamps.
     * @example
     * // Update many Stamps
     * const stamp = await prisma.stamp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stamps and only return the `id`
     * const stampWithIdOnly = await prisma.stamp.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StampUpdateManyAndReturnArgs>(args: SelectSubset<T, StampUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StampPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Stamp.
     * @param {StampUpsertArgs} args - Arguments to update or create a Stamp.
     * @example
     * // Update or create a Stamp
     * const stamp = await prisma.stamp.upsert({
     *   create: {
     *     // ... data to create a Stamp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stamp we want to update
     *   }
     * })
     */
    upsert<T extends StampUpsertArgs>(args: SelectSubset<T, StampUpsertArgs<ExtArgs>>): Prisma__StampClient<$Result.GetResult<Prisma.$StampPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stamps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampCountArgs} args - Arguments to filter Stamps to count.
     * @example
     * // Count the number of Stamps
     * const count = await prisma.stamp.count({
     *   where: {
     *     // ... the filter for the Stamps we want to count
     *   }
     * })
    **/
    count<T extends StampCountArgs>(
      args?: Subset<T, StampCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StampCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stamp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StampAggregateArgs>(args: Subset<T, StampAggregateArgs>): Prisma.PrismaPromise<GetStampAggregateType<T>>

    /**
     * Group by Stamp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StampGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StampGroupByArgs['orderBy'] }
        : { orderBy?: StampGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StampGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStampGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stamp model
   */
  readonly fields: StampFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stamp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StampClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stamp_book<T extends StampBookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StampBookDefaultArgs<ExtArgs>>): Prisma__StampBookClient<$Result.GetResult<Prisma.$StampBookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stamp model
   */
  interface StampFieldRefs {
    readonly id: FieldRef<"Stamp", 'Int'>
    readonly stamp_book_id: FieldRef<"Stamp", 'Int'>
    readonly stamp_image_url: FieldRef<"Stamp", 'String'>
    readonly stamped_at: FieldRef<"Stamp", 'DateTime'>
    readonly source: FieldRef<"Stamp", 'String'>
    readonly note: FieldRef<"Stamp", 'String'>
    readonly latitude: FieldRef<"Stamp", 'Float'>
    readonly longitude: FieldRef<"Stamp", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Stamp findUnique
   */
  export type StampFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stamp
     */
    omit?: StampOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampInclude<ExtArgs> | null
    /**
     * Filter, which Stamp to fetch.
     */
    where: StampWhereUniqueInput
  }

  /**
   * Stamp findUniqueOrThrow
   */
  export type StampFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stamp
     */
    omit?: StampOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampInclude<ExtArgs> | null
    /**
     * Filter, which Stamp to fetch.
     */
    where: StampWhereUniqueInput
  }

  /**
   * Stamp findFirst
   */
  export type StampFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stamp
     */
    omit?: StampOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampInclude<ExtArgs> | null
    /**
     * Filter, which Stamp to fetch.
     */
    where?: StampWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stamps to fetch.
     */
    orderBy?: StampOrderByWithRelationInput | StampOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stamps.
     */
    cursor?: StampWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stamps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stamps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stamps.
     */
    distinct?: StampScalarFieldEnum | StampScalarFieldEnum[]
  }

  /**
   * Stamp findFirstOrThrow
   */
  export type StampFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stamp
     */
    omit?: StampOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampInclude<ExtArgs> | null
    /**
     * Filter, which Stamp to fetch.
     */
    where?: StampWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stamps to fetch.
     */
    orderBy?: StampOrderByWithRelationInput | StampOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stamps.
     */
    cursor?: StampWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stamps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stamps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stamps.
     */
    distinct?: StampScalarFieldEnum | StampScalarFieldEnum[]
  }

  /**
   * Stamp findMany
   */
  export type StampFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stamp
     */
    omit?: StampOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampInclude<ExtArgs> | null
    /**
     * Filter, which Stamps to fetch.
     */
    where?: StampWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stamps to fetch.
     */
    orderBy?: StampOrderByWithRelationInput | StampOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stamps.
     */
    cursor?: StampWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stamps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stamps.
     */
    skip?: number
    distinct?: StampScalarFieldEnum | StampScalarFieldEnum[]
  }

  /**
   * Stamp create
   */
  export type StampCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stamp
     */
    omit?: StampOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampInclude<ExtArgs> | null
    /**
     * The data needed to create a Stamp.
     */
    data: XOR<StampCreateInput, StampUncheckedCreateInput>
  }

  /**
   * Stamp createMany
   */
  export type StampCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stamps.
     */
    data: StampCreateManyInput | StampCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stamp createManyAndReturn
   */
  export type StampCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stamp
     */
    omit?: StampOmit<ExtArgs> | null
    /**
     * The data used to create many Stamps.
     */
    data: StampCreateManyInput | StampCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stamp update
   */
  export type StampUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stamp
     */
    omit?: StampOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampInclude<ExtArgs> | null
    /**
     * The data needed to update a Stamp.
     */
    data: XOR<StampUpdateInput, StampUncheckedUpdateInput>
    /**
     * Choose, which Stamp to update.
     */
    where: StampWhereUniqueInput
  }

  /**
   * Stamp updateMany
   */
  export type StampUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stamps.
     */
    data: XOR<StampUpdateManyMutationInput, StampUncheckedUpdateManyInput>
    /**
     * Filter which Stamps to update
     */
    where?: StampWhereInput
    /**
     * Limit how many Stamps to update.
     */
    limit?: number
  }

  /**
   * Stamp updateManyAndReturn
   */
  export type StampUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stamp
     */
    omit?: StampOmit<ExtArgs> | null
    /**
     * The data used to update Stamps.
     */
    data: XOR<StampUpdateManyMutationInput, StampUncheckedUpdateManyInput>
    /**
     * Filter which Stamps to update
     */
    where?: StampWhereInput
    /**
     * Limit how many Stamps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stamp upsert
   */
  export type StampUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stamp
     */
    omit?: StampOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampInclude<ExtArgs> | null
    /**
     * The filter to search for the Stamp to update in case it exists.
     */
    where: StampWhereUniqueInput
    /**
     * In case the Stamp found by the `where` argument doesn't exist, create a new Stamp with this data.
     */
    create: XOR<StampCreateInput, StampUncheckedCreateInput>
    /**
     * In case the Stamp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StampUpdateInput, StampUncheckedUpdateInput>
  }

  /**
   * Stamp delete
   */
  export type StampDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stamp
     */
    omit?: StampOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampInclude<ExtArgs> | null
    /**
     * Filter which Stamp to delete.
     */
    where: StampWhereUniqueInput
  }

  /**
   * Stamp deleteMany
   */
  export type StampDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stamps to delete
     */
    where?: StampWhereInput
    /**
     * Limit how many Stamps to delete.
     */
    limit?: number
  }

  /**
   * Stamp without action
   */
  export type StampDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stamp
     */
    omit?: StampOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampInclude<ExtArgs> | null
  }


  /**
   * Model PointTransaction
   */

  export type AggregatePointTransaction = {
    _count: PointTransactionCountAggregateOutputType | null
    _avg: PointTransactionAvgAggregateOutputType | null
    _sum: PointTransactionSumAggregateOutputType | null
    _min: PointTransactionMinAggregateOutputType | null
    _max: PointTransactionMaxAggregateOutputType | null
  }

  export type PointTransactionAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    stamp_book_id: number | null
    point: number | null
  }

  export type PointTransactionSumAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    stamp_book_id: number | null
    point: number | null
  }

  export type PointTransactionMinAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    stamp_book_id: number | null
    point: number | null
    type: string | null
    description: string | null
    created_at: Date | null
  }

  export type PointTransactionMaxAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    stamp_book_id: number | null
    point: number | null
    type: string | null
    description: string | null
    created_at: Date | null
  }

  export type PointTransactionCountAggregateOutputType = {
    id: number
    user_id: number
    stamp_book_id: number
    point: number
    type: number
    description: number
    created_at: number
    _all: number
  }


  export type PointTransactionAvgAggregateInputType = {
    id?: true
    user_id?: true
    stamp_book_id?: true
    point?: true
  }

  export type PointTransactionSumAggregateInputType = {
    id?: true
    user_id?: true
    stamp_book_id?: true
    point?: true
  }

  export type PointTransactionMinAggregateInputType = {
    id?: true
    user_id?: true
    stamp_book_id?: true
    point?: true
    type?: true
    description?: true
    created_at?: true
  }

  export type PointTransactionMaxAggregateInputType = {
    id?: true
    user_id?: true
    stamp_book_id?: true
    point?: true
    type?: true
    description?: true
    created_at?: true
  }

  export type PointTransactionCountAggregateInputType = {
    id?: true
    user_id?: true
    stamp_book_id?: true
    point?: true
    type?: true
    description?: true
    created_at?: true
    _all?: true
  }

  export type PointTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointTransaction to aggregate.
     */
    where?: PointTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointTransactions to fetch.
     */
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PointTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PointTransactions
    **/
    _count?: true | PointTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PointTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PointTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PointTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PointTransactionMaxAggregateInputType
  }

  export type GetPointTransactionAggregateType<T extends PointTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregatePointTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePointTransaction[P]>
      : GetScalarType<T[P], AggregatePointTransaction[P]>
  }




  export type PointTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointTransactionWhereInput
    orderBy?: PointTransactionOrderByWithAggregationInput | PointTransactionOrderByWithAggregationInput[]
    by: PointTransactionScalarFieldEnum[] | PointTransactionScalarFieldEnum
    having?: PointTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PointTransactionCountAggregateInputType | true
    _avg?: PointTransactionAvgAggregateInputType
    _sum?: PointTransactionSumAggregateInputType
    _min?: PointTransactionMinAggregateInputType
    _max?: PointTransactionMaxAggregateInputType
  }

  export type PointTransactionGroupByOutputType = {
    id: number
    user_id: bigint
    stamp_book_id: number
    point: number
    type: string
    description: string
    created_at: Date
    _count: PointTransactionCountAggregateOutputType | null
    _avg: PointTransactionAvgAggregateOutputType | null
    _sum: PointTransactionSumAggregateOutputType | null
    _min: PointTransactionMinAggregateOutputType | null
    _max: PointTransactionMaxAggregateOutputType | null
  }

  type GetPointTransactionGroupByPayload<T extends PointTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PointTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PointTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PointTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], PointTransactionGroupByOutputType[P]>
        }
      >
    >


  export type PointTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    stamp_book_id?: boolean
    point?: boolean
    type?: boolean
    description?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    stamp_book?: boolean | StampBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointTransaction"]>

  export type PointTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    stamp_book_id?: boolean
    point?: boolean
    type?: boolean
    description?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    stamp_book?: boolean | StampBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointTransaction"]>

  export type PointTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    stamp_book_id?: boolean
    point?: boolean
    type?: boolean
    description?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    stamp_book?: boolean | StampBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointTransaction"]>

  export type PointTransactionSelectScalar = {
    id?: boolean
    user_id?: boolean
    stamp_book_id?: boolean
    point?: boolean
    type?: boolean
    description?: boolean
    created_at?: boolean
  }

  export type PointTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "stamp_book_id" | "point" | "type" | "description" | "created_at", ExtArgs["result"]["pointTransaction"]>
  export type PointTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    stamp_book?: boolean | StampBookDefaultArgs<ExtArgs>
  }
  export type PointTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    stamp_book?: boolean | StampBookDefaultArgs<ExtArgs>
  }
  export type PointTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    stamp_book?: boolean | StampBookDefaultArgs<ExtArgs>
  }

  export type $PointTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PointTransaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      stamp_book: Prisma.$StampBookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: bigint
      stamp_book_id: number
      point: number
      type: string
      description: string
      created_at: Date
    }, ExtArgs["result"]["pointTransaction"]>
    composites: {}
  }

  type PointTransactionGetPayload<S extends boolean | null | undefined | PointTransactionDefaultArgs> = $Result.GetResult<Prisma.$PointTransactionPayload, S>

  type PointTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PointTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PointTransactionCountAggregateInputType | true
    }

  export interface PointTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PointTransaction'], meta: { name: 'PointTransaction' } }
    /**
     * Find zero or one PointTransaction that matches the filter.
     * @param {PointTransactionFindUniqueArgs} args - Arguments to find a PointTransaction
     * @example
     * // Get one PointTransaction
     * const pointTransaction = await prisma.pointTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PointTransactionFindUniqueArgs>(args: SelectSubset<T, PointTransactionFindUniqueArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PointTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PointTransactionFindUniqueOrThrowArgs} args - Arguments to find a PointTransaction
     * @example
     * // Get one PointTransaction
     * const pointTransaction = await prisma.pointTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PointTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, PointTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PointTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionFindFirstArgs} args - Arguments to find a PointTransaction
     * @example
     * // Get one PointTransaction
     * const pointTransaction = await prisma.pointTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PointTransactionFindFirstArgs>(args?: SelectSubset<T, PointTransactionFindFirstArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PointTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionFindFirstOrThrowArgs} args - Arguments to find a PointTransaction
     * @example
     * // Get one PointTransaction
     * const pointTransaction = await prisma.pointTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PointTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, PointTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PointTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PointTransactions
     * const pointTransactions = await prisma.pointTransaction.findMany()
     * 
     * // Get first 10 PointTransactions
     * const pointTransactions = await prisma.pointTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pointTransactionWithIdOnly = await prisma.pointTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PointTransactionFindManyArgs>(args?: SelectSubset<T, PointTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PointTransaction.
     * @param {PointTransactionCreateArgs} args - Arguments to create a PointTransaction.
     * @example
     * // Create one PointTransaction
     * const PointTransaction = await prisma.pointTransaction.create({
     *   data: {
     *     // ... data to create a PointTransaction
     *   }
     * })
     * 
     */
    create<T extends PointTransactionCreateArgs>(args: SelectSubset<T, PointTransactionCreateArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PointTransactions.
     * @param {PointTransactionCreateManyArgs} args - Arguments to create many PointTransactions.
     * @example
     * // Create many PointTransactions
     * const pointTransaction = await prisma.pointTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PointTransactionCreateManyArgs>(args?: SelectSubset<T, PointTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PointTransactions and returns the data saved in the database.
     * @param {PointTransactionCreateManyAndReturnArgs} args - Arguments to create many PointTransactions.
     * @example
     * // Create many PointTransactions
     * const pointTransaction = await prisma.pointTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PointTransactions and only return the `id`
     * const pointTransactionWithIdOnly = await prisma.pointTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PointTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, PointTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PointTransaction.
     * @param {PointTransactionDeleteArgs} args - Arguments to delete one PointTransaction.
     * @example
     * // Delete one PointTransaction
     * const PointTransaction = await prisma.pointTransaction.delete({
     *   where: {
     *     // ... filter to delete one PointTransaction
     *   }
     * })
     * 
     */
    delete<T extends PointTransactionDeleteArgs>(args: SelectSubset<T, PointTransactionDeleteArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PointTransaction.
     * @param {PointTransactionUpdateArgs} args - Arguments to update one PointTransaction.
     * @example
     * // Update one PointTransaction
     * const pointTransaction = await prisma.pointTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PointTransactionUpdateArgs>(args: SelectSubset<T, PointTransactionUpdateArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PointTransactions.
     * @param {PointTransactionDeleteManyArgs} args - Arguments to filter PointTransactions to delete.
     * @example
     * // Delete a few PointTransactions
     * const { count } = await prisma.pointTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PointTransactionDeleteManyArgs>(args?: SelectSubset<T, PointTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PointTransactions
     * const pointTransaction = await prisma.pointTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PointTransactionUpdateManyArgs>(args: SelectSubset<T, PointTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointTransactions and returns the data updated in the database.
     * @param {PointTransactionUpdateManyAndReturnArgs} args - Arguments to update many PointTransactions.
     * @example
     * // Update many PointTransactions
     * const pointTransaction = await prisma.pointTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PointTransactions and only return the `id`
     * const pointTransactionWithIdOnly = await prisma.pointTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PointTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, PointTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PointTransaction.
     * @param {PointTransactionUpsertArgs} args - Arguments to update or create a PointTransaction.
     * @example
     * // Update or create a PointTransaction
     * const pointTransaction = await prisma.pointTransaction.upsert({
     *   create: {
     *     // ... data to create a PointTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PointTransaction we want to update
     *   }
     * })
     */
    upsert<T extends PointTransactionUpsertArgs>(args: SelectSubset<T, PointTransactionUpsertArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PointTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionCountArgs} args - Arguments to filter PointTransactions to count.
     * @example
     * // Count the number of PointTransactions
     * const count = await prisma.pointTransaction.count({
     *   where: {
     *     // ... the filter for the PointTransactions we want to count
     *   }
     * })
    **/
    count<T extends PointTransactionCountArgs>(
      args?: Subset<T, PointTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PointTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PointTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PointTransactionAggregateArgs>(args: Subset<T, PointTransactionAggregateArgs>): Prisma.PrismaPromise<GetPointTransactionAggregateType<T>>

    /**
     * Group by PointTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PointTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PointTransactionGroupByArgs['orderBy'] }
        : { orderBy?: PointTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PointTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPointTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PointTransaction model
   */
  readonly fields: PointTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PointTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PointTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stamp_book<T extends StampBookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StampBookDefaultArgs<ExtArgs>>): Prisma__StampBookClient<$Result.GetResult<Prisma.$StampBookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PointTransaction model
   */
  interface PointTransactionFieldRefs {
    readonly id: FieldRef<"PointTransaction", 'Int'>
    readonly user_id: FieldRef<"PointTransaction", 'BigInt'>
    readonly stamp_book_id: FieldRef<"PointTransaction", 'Int'>
    readonly point: FieldRef<"PointTransaction", 'Int'>
    readonly type: FieldRef<"PointTransaction", 'String'>
    readonly description: FieldRef<"PointTransaction", 'String'>
    readonly created_at: FieldRef<"PointTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PointTransaction findUnique
   */
  export type PointTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointTransaction to fetch.
     */
    where: PointTransactionWhereUniqueInput
  }

  /**
   * PointTransaction findUniqueOrThrow
   */
  export type PointTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointTransaction to fetch.
     */
    where: PointTransactionWhereUniqueInput
  }

  /**
   * PointTransaction findFirst
   */
  export type PointTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointTransaction to fetch.
     */
    where?: PointTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointTransactions to fetch.
     */
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointTransactions.
     */
    cursor?: PointTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointTransactions.
     */
    distinct?: PointTransactionScalarFieldEnum | PointTransactionScalarFieldEnum[]
  }

  /**
   * PointTransaction findFirstOrThrow
   */
  export type PointTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointTransaction to fetch.
     */
    where?: PointTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointTransactions to fetch.
     */
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointTransactions.
     */
    cursor?: PointTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointTransactions.
     */
    distinct?: PointTransactionScalarFieldEnum | PointTransactionScalarFieldEnum[]
  }

  /**
   * PointTransaction findMany
   */
  export type PointTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointTransactions to fetch.
     */
    where?: PointTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointTransactions to fetch.
     */
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PointTransactions.
     */
    cursor?: PointTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointTransactions.
     */
    skip?: number
    distinct?: PointTransactionScalarFieldEnum | PointTransactionScalarFieldEnum[]
  }

  /**
   * PointTransaction create
   */
  export type PointTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a PointTransaction.
     */
    data: XOR<PointTransactionCreateInput, PointTransactionUncheckedCreateInput>
  }

  /**
   * PointTransaction createMany
   */
  export type PointTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PointTransactions.
     */
    data: PointTransactionCreateManyInput | PointTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PointTransaction createManyAndReturn
   */
  export type PointTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many PointTransactions.
     */
    data: PointTransactionCreateManyInput | PointTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PointTransaction update
   */
  export type PointTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a PointTransaction.
     */
    data: XOR<PointTransactionUpdateInput, PointTransactionUncheckedUpdateInput>
    /**
     * Choose, which PointTransaction to update.
     */
    where: PointTransactionWhereUniqueInput
  }

  /**
   * PointTransaction updateMany
   */
  export type PointTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PointTransactions.
     */
    data: XOR<PointTransactionUpdateManyMutationInput, PointTransactionUncheckedUpdateManyInput>
    /**
     * Filter which PointTransactions to update
     */
    where?: PointTransactionWhereInput
    /**
     * Limit how many PointTransactions to update.
     */
    limit?: number
  }

  /**
   * PointTransaction updateManyAndReturn
   */
  export type PointTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * The data used to update PointTransactions.
     */
    data: XOR<PointTransactionUpdateManyMutationInput, PointTransactionUncheckedUpdateManyInput>
    /**
     * Filter which PointTransactions to update
     */
    where?: PointTransactionWhereInput
    /**
     * Limit how many PointTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PointTransaction upsert
   */
  export type PointTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the PointTransaction to update in case it exists.
     */
    where: PointTransactionWhereUniqueInput
    /**
     * In case the PointTransaction found by the `where` argument doesn't exist, create a new PointTransaction with this data.
     */
    create: XOR<PointTransactionCreateInput, PointTransactionUncheckedCreateInput>
    /**
     * In case the PointTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PointTransactionUpdateInput, PointTransactionUncheckedUpdateInput>
  }

  /**
   * PointTransaction delete
   */
  export type PointTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter which PointTransaction to delete.
     */
    where: PointTransactionWhereUniqueInput
  }

  /**
   * PointTransaction deleteMany
   */
  export type PointTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointTransactions to delete
     */
    where?: PointTransactionWhereInput
    /**
     * Limit how many PointTransactions to delete.
     */
    limit?: number
  }

  /**
   * PointTransaction without action
   */
  export type PointTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Cafe
   */

  export type AggregateCafe = {
    _count: CafeCountAggregateOutputType | null
    _avg: CafeAvgAggregateOutputType | null
    _sum: CafeSumAggregateOutputType | null
    _min: CafeMinAggregateOutputType | null
    _max: CafeMaxAggregateOutputType | null
  }

  export type CafeAvgAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
  }

  export type CafeSumAggregateOutputType = {
    id: bigint | null
    latitude: number | null
    longitude: number | null
  }

  export type CafeMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    address: string | null
    region: string | null
    latitude: number | null
    longitude: number | null
    owner_name: string | null
    business_hours: string | null
    phone: string | null
    website_url: string | null
    description: string | null
    status: $Enums.CafeStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CafeMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    address: string | null
    region: string | null
    latitude: number | null
    longitude: number | null
    owner_name: string | null
    business_hours: string | null
    phone: string | null
    website_url: string | null
    description: string | null
    status: $Enums.CafeStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CafeCountAggregateOutputType = {
    id: number
    name: number
    address: number
    region: number
    latitude: number
    longitude: number
    owner_name: number
    business_hours: number
    phone: number
    website_url: number
    description: number
    store_filters: number
    take_out_filters: number
    menu_filters: number
    keywords: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CafeAvgAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
  }

  export type CafeSumAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
  }

  export type CafeMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    region?: true
    latitude?: true
    longitude?: true
    owner_name?: true
    business_hours?: true
    phone?: true
    website_url?: true
    description?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type CafeMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    region?: true
    latitude?: true
    longitude?: true
    owner_name?: true
    business_hours?: true
    phone?: true
    website_url?: true
    description?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type CafeCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    region?: true
    latitude?: true
    longitude?: true
    owner_name?: true
    business_hours?: true
    phone?: true
    website_url?: true
    description?: true
    store_filters?: true
    take_out_filters?: true
    menu_filters?: true
    keywords?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CafeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cafe to aggregate.
     */
    where?: CafeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cafes to fetch.
     */
    orderBy?: CafeOrderByWithRelationInput | CafeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CafeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cafes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cafes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cafes
    **/
    _count?: true | CafeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeMaxAggregateInputType
  }

  export type GetCafeAggregateType<T extends CafeAggregateArgs> = {
        [P in keyof T & keyof AggregateCafe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafe[P]>
      : GetScalarType<T[P], AggregateCafe[P]>
  }




  export type CafeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeWhereInput
    orderBy?: CafeOrderByWithAggregationInput | CafeOrderByWithAggregationInput[]
    by: CafeScalarFieldEnum[] | CafeScalarFieldEnum
    having?: CafeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeCountAggregateInputType | true
    _avg?: CafeAvgAggregateInputType
    _sum?: CafeSumAggregateInputType
    _min?: CafeMinAggregateInputType
    _max?: CafeMaxAggregateInputType
  }

  export type CafeGroupByOutputType = {
    id: bigint
    name: string
    address: string
    region: string
    latitude: number
    longitude: number
    owner_name: string
    business_hours: string
    phone: string
    website_url: string
    description: string
    store_filters: JsonValue
    take_out_filters: JsonValue
    menu_filters: JsonValue
    keywords: JsonValue
    status: $Enums.CafeStatus
    created_at: Date
    updated_at: Date
    _count: CafeCountAggregateOutputType | null
    _avg: CafeAvgAggregateOutputType | null
    _sum: CafeSumAggregateOutputType | null
    _min: CafeMinAggregateOutputType | null
    _max: CafeMaxAggregateOutputType | null
  }

  type GetCafeGroupByPayload<T extends CafeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CafeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeGroupByOutputType[P]>
            : GetScalarType<T[P], CafeGroupByOutputType[P]>
        }
      >
    >


  export type CafeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    region?: boolean
    latitude?: boolean
    longitude?: boolean
    owner_name?: boolean
    business_hours?: boolean
    phone?: boolean
    website_url?: boolean
    description?: boolean
    store_filters?: boolean
    take_out_filters?: boolean
    menu_filters?: boolean
    keywords?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    menu?: boolean | Cafe$menuArgs<ExtArgs>
    photos?: boolean | Cafe$photosArgs<ExtArgs>
    available_challenges?: boolean | Cafe$available_challengesArgs<ExtArgs>
    stamp_books?: boolean | Cafe$stamp_booksArgs<ExtArgs>
    reviews?: boolean | Cafe$reviewsArgs<ExtArgs>
    notifications?: boolean | Cafe$notificationsArgs<ExtArgs>
    coupons?: boolean | Cafe$couponsArgs<ExtArgs>
    _count?: boolean | CafeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafe"]>

  export type CafeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    region?: boolean
    latitude?: boolean
    longitude?: boolean
    owner_name?: boolean
    business_hours?: boolean
    phone?: boolean
    website_url?: boolean
    description?: boolean
    store_filters?: boolean
    take_out_filters?: boolean
    menu_filters?: boolean
    keywords?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["cafe"]>

  export type CafeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    region?: boolean
    latitude?: boolean
    longitude?: boolean
    owner_name?: boolean
    business_hours?: boolean
    phone?: boolean
    website_url?: boolean
    description?: boolean
    store_filters?: boolean
    take_out_filters?: boolean
    menu_filters?: boolean
    keywords?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["cafe"]>

  export type CafeSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    region?: boolean
    latitude?: boolean
    longitude?: boolean
    owner_name?: boolean
    business_hours?: boolean
    phone?: boolean
    website_url?: boolean
    description?: boolean
    store_filters?: boolean
    take_out_filters?: boolean
    menu_filters?: boolean
    keywords?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CafeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "region" | "latitude" | "longitude" | "owner_name" | "business_hours" | "phone" | "website_url" | "description" | "store_filters" | "take_out_filters" | "menu_filters" | "keywords" | "status" | "created_at" | "updated_at", ExtArgs["result"]["cafe"]>
  export type CafeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu?: boolean | Cafe$menuArgs<ExtArgs>
    photos?: boolean | Cafe$photosArgs<ExtArgs>
    available_challenges?: boolean | Cafe$available_challengesArgs<ExtArgs>
    stamp_books?: boolean | Cafe$stamp_booksArgs<ExtArgs>
    reviews?: boolean | Cafe$reviewsArgs<ExtArgs>
    notifications?: boolean | Cafe$notificationsArgs<ExtArgs>
    coupons?: boolean | Cafe$couponsArgs<ExtArgs>
    _count?: boolean | CafeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CafeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CafeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CafePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cafe"
    objects: {
      menu: Prisma.$CafeMenuPayload<ExtArgs>[]
      photos: Prisma.$CafePhotoPayload<ExtArgs>[]
      available_challenges: Prisma.$ChallengeAvailableCafePayload<ExtArgs>[]
      stamp_books: Prisma.$StampBookPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      coupons: Prisma.$CouponPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      address: string
      region: string
      latitude: number
      longitude: number
      owner_name: string
      business_hours: string
      phone: string
      website_url: string
      description: string
      store_filters: Prisma.JsonValue
      take_out_filters: Prisma.JsonValue
      menu_filters: Prisma.JsonValue
      keywords: Prisma.JsonValue
      status: $Enums.CafeStatus
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["cafe"]>
    composites: {}
  }

  type CafeGetPayload<S extends boolean | null | undefined | CafeDefaultArgs> = $Result.GetResult<Prisma.$CafePayload, S>

  type CafeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CafeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CafeCountAggregateInputType | true
    }

  export interface CafeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cafe'], meta: { name: 'Cafe' } }
    /**
     * Find zero or one Cafe that matches the filter.
     * @param {CafeFindUniqueArgs} args - Arguments to find a Cafe
     * @example
     * // Get one Cafe
     * const cafe = await prisma.cafe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CafeFindUniqueArgs>(args: SelectSubset<T, CafeFindUniqueArgs<ExtArgs>>): Prisma__CafeClient<$Result.GetResult<Prisma.$CafePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cafe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CafeFindUniqueOrThrowArgs} args - Arguments to find a Cafe
     * @example
     * // Get one Cafe
     * const cafe = await prisma.cafe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CafeFindUniqueOrThrowArgs>(args: SelectSubset<T, CafeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CafeClient<$Result.GetResult<Prisma.$CafePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cafe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeFindFirstArgs} args - Arguments to find a Cafe
     * @example
     * // Get one Cafe
     * const cafe = await prisma.cafe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CafeFindFirstArgs>(args?: SelectSubset<T, CafeFindFirstArgs<ExtArgs>>): Prisma__CafeClient<$Result.GetResult<Prisma.$CafePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cafe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeFindFirstOrThrowArgs} args - Arguments to find a Cafe
     * @example
     * // Get one Cafe
     * const cafe = await prisma.cafe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CafeFindFirstOrThrowArgs>(args?: SelectSubset<T, CafeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CafeClient<$Result.GetResult<Prisma.$CafePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cafes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cafes
     * const cafes = await prisma.cafe.findMany()
     * 
     * // Get first 10 Cafes
     * const cafes = await prisma.cafe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafeWithIdOnly = await prisma.cafe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CafeFindManyArgs>(args?: SelectSubset<T, CafeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cafe.
     * @param {CafeCreateArgs} args - Arguments to create a Cafe.
     * @example
     * // Create one Cafe
     * const Cafe = await prisma.cafe.create({
     *   data: {
     *     // ... data to create a Cafe
     *   }
     * })
     * 
     */
    create<T extends CafeCreateArgs>(args: SelectSubset<T, CafeCreateArgs<ExtArgs>>): Prisma__CafeClient<$Result.GetResult<Prisma.$CafePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cafes.
     * @param {CafeCreateManyArgs} args - Arguments to create many Cafes.
     * @example
     * // Create many Cafes
     * const cafe = await prisma.cafe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CafeCreateManyArgs>(args?: SelectSubset<T, CafeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cafes and returns the data saved in the database.
     * @param {CafeCreateManyAndReturnArgs} args - Arguments to create many Cafes.
     * @example
     * // Create many Cafes
     * const cafe = await prisma.cafe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cafes and only return the `id`
     * const cafeWithIdOnly = await prisma.cafe.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CafeCreateManyAndReturnArgs>(args?: SelectSubset<T, CafeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cafe.
     * @param {CafeDeleteArgs} args - Arguments to delete one Cafe.
     * @example
     * // Delete one Cafe
     * const Cafe = await prisma.cafe.delete({
     *   where: {
     *     // ... filter to delete one Cafe
     *   }
     * })
     * 
     */
    delete<T extends CafeDeleteArgs>(args: SelectSubset<T, CafeDeleteArgs<ExtArgs>>): Prisma__CafeClient<$Result.GetResult<Prisma.$CafePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cafe.
     * @param {CafeUpdateArgs} args - Arguments to update one Cafe.
     * @example
     * // Update one Cafe
     * const cafe = await prisma.cafe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CafeUpdateArgs>(args: SelectSubset<T, CafeUpdateArgs<ExtArgs>>): Prisma__CafeClient<$Result.GetResult<Prisma.$CafePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cafes.
     * @param {CafeDeleteManyArgs} args - Arguments to filter Cafes to delete.
     * @example
     * // Delete a few Cafes
     * const { count } = await prisma.cafe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CafeDeleteManyArgs>(args?: SelectSubset<T, CafeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cafes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cafes
     * const cafe = await prisma.cafe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CafeUpdateManyArgs>(args: SelectSubset<T, CafeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cafes and returns the data updated in the database.
     * @param {CafeUpdateManyAndReturnArgs} args - Arguments to update many Cafes.
     * @example
     * // Update many Cafes
     * const cafe = await prisma.cafe.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cafes and only return the `id`
     * const cafeWithIdOnly = await prisma.cafe.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CafeUpdateManyAndReturnArgs>(args: SelectSubset<T, CafeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cafe.
     * @param {CafeUpsertArgs} args - Arguments to update or create a Cafe.
     * @example
     * // Update or create a Cafe
     * const cafe = await prisma.cafe.upsert({
     *   create: {
     *     // ... data to create a Cafe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cafe we want to update
     *   }
     * })
     */
    upsert<T extends CafeUpsertArgs>(args: SelectSubset<T, CafeUpsertArgs<ExtArgs>>): Prisma__CafeClient<$Result.GetResult<Prisma.$CafePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cafes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeCountArgs} args - Arguments to filter Cafes to count.
     * @example
     * // Count the number of Cafes
     * const count = await prisma.cafe.count({
     *   where: {
     *     // ... the filter for the Cafes we want to count
     *   }
     * })
    **/
    count<T extends CafeCountArgs>(
      args?: Subset<T, CafeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cafe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeAggregateArgs>(args: Subset<T, CafeAggregateArgs>): Prisma.PrismaPromise<GetCafeAggregateType<T>>

    /**
     * Group by Cafe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeGroupByArgs['orderBy'] }
        : { orderBy?: CafeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cafe model
   */
  readonly fields: CafeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cafe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CafeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    menu<T extends Cafe$menuArgs<ExtArgs> = {}>(args?: Subset<T, Cafe$menuArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeMenuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photos<T extends Cafe$photosArgs<ExtArgs> = {}>(args?: Subset<T, Cafe$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafePhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    available_challenges<T extends Cafe$available_challengesArgs<ExtArgs> = {}>(args?: Subset<T, Cafe$available_challengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeAvailableCafePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stamp_books<T extends Cafe$stamp_booksArgs<ExtArgs> = {}>(args?: Subset<T, Cafe$stamp_booksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StampBookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Cafe$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Cafe$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Cafe$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Cafe$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coupons<T extends Cafe$couponsArgs<ExtArgs> = {}>(args?: Subset<T, Cafe$couponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cafe model
   */
  interface CafeFieldRefs {
    readonly id: FieldRef<"Cafe", 'BigInt'>
    readonly name: FieldRef<"Cafe", 'String'>
    readonly address: FieldRef<"Cafe", 'String'>
    readonly region: FieldRef<"Cafe", 'String'>
    readonly latitude: FieldRef<"Cafe", 'Float'>
    readonly longitude: FieldRef<"Cafe", 'Float'>
    readonly owner_name: FieldRef<"Cafe", 'String'>
    readonly business_hours: FieldRef<"Cafe", 'String'>
    readonly phone: FieldRef<"Cafe", 'String'>
    readonly website_url: FieldRef<"Cafe", 'String'>
    readonly description: FieldRef<"Cafe", 'String'>
    readonly store_filters: FieldRef<"Cafe", 'Json'>
    readonly take_out_filters: FieldRef<"Cafe", 'Json'>
    readonly menu_filters: FieldRef<"Cafe", 'Json'>
    readonly keywords: FieldRef<"Cafe", 'Json'>
    readonly status: FieldRef<"Cafe", 'CafeStatus'>
    readonly created_at: FieldRef<"Cafe", 'DateTime'>
    readonly updated_at: FieldRef<"Cafe", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cafe findUnique
   */
  export type CafeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cafe
     */
    select?: CafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cafe
     */
    omit?: CafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInclude<ExtArgs> | null
    /**
     * Filter, which Cafe to fetch.
     */
    where: CafeWhereUniqueInput
  }

  /**
   * Cafe findUniqueOrThrow
   */
  export type CafeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cafe
     */
    select?: CafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cafe
     */
    omit?: CafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInclude<ExtArgs> | null
    /**
     * Filter, which Cafe to fetch.
     */
    where: CafeWhereUniqueInput
  }

  /**
   * Cafe findFirst
   */
  export type CafeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cafe
     */
    select?: CafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cafe
     */
    omit?: CafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInclude<ExtArgs> | null
    /**
     * Filter, which Cafe to fetch.
     */
    where?: CafeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cafes to fetch.
     */
    orderBy?: CafeOrderByWithRelationInput | CafeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cafes.
     */
    cursor?: CafeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cafes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cafes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cafes.
     */
    distinct?: CafeScalarFieldEnum | CafeScalarFieldEnum[]
  }

  /**
   * Cafe findFirstOrThrow
   */
  export type CafeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cafe
     */
    select?: CafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cafe
     */
    omit?: CafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInclude<ExtArgs> | null
    /**
     * Filter, which Cafe to fetch.
     */
    where?: CafeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cafes to fetch.
     */
    orderBy?: CafeOrderByWithRelationInput | CafeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cafes.
     */
    cursor?: CafeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cafes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cafes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cafes.
     */
    distinct?: CafeScalarFieldEnum | CafeScalarFieldEnum[]
  }

  /**
   * Cafe findMany
   */
  export type CafeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cafe
     */
    select?: CafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cafe
     */
    omit?: CafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInclude<ExtArgs> | null
    /**
     * Filter, which Cafes to fetch.
     */
    where?: CafeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cafes to fetch.
     */
    orderBy?: CafeOrderByWithRelationInput | CafeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cafes.
     */
    cursor?: CafeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cafes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cafes.
     */
    skip?: number
    distinct?: CafeScalarFieldEnum | CafeScalarFieldEnum[]
  }

  /**
   * Cafe create
   */
  export type CafeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cafe
     */
    select?: CafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cafe
     */
    omit?: CafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInclude<ExtArgs> | null
    /**
     * The data needed to create a Cafe.
     */
    data: XOR<CafeCreateInput, CafeUncheckedCreateInput>
  }

  /**
   * Cafe createMany
   */
  export type CafeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cafes.
     */
    data: CafeCreateManyInput | CafeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cafe createManyAndReturn
   */
  export type CafeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cafe
     */
    select?: CafeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cafe
     */
    omit?: CafeOmit<ExtArgs> | null
    /**
     * The data used to create many Cafes.
     */
    data: CafeCreateManyInput | CafeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cafe update
   */
  export type CafeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cafe
     */
    select?: CafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cafe
     */
    omit?: CafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInclude<ExtArgs> | null
    /**
     * The data needed to update a Cafe.
     */
    data: XOR<CafeUpdateInput, CafeUncheckedUpdateInput>
    /**
     * Choose, which Cafe to update.
     */
    where: CafeWhereUniqueInput
  }

  /**
   * Cafe updateMany
   */
  export type CafeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cafes.
     */
    data: XOR<CafeUpdateManyMutationInput, CafeUncheckedUpdateManyInput>
    /**
     * Filter which Cafes to update
     */
    where?: CafeWhereInput
    /**
     * Limit how many Cafes to update.
     */
    limit?: number
  }

  /**
   * Cafe updateManyAndReturn
   */
  export type CafeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cafe
     */
    select?: CafeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cafe
     */
    omit?: CafeOmit<ExtArgs> | null
    /**
     * The data used to update Cafes.
     */
    data: XOR<CafeUpdateManyMutationInput, CafeUncheckedUpdateManyInput>
    /**
     * Filter which Cafes to update
     */
    where?: CafeWhereInput
    /**
     * Limit how many Cafes to update.
     */
    limit?: number
  }

  /**
   * Cafe upsert
   */
  export type CafeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cafe
     */
    select?: CafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cafe
     */
    omit?: CafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInclude<ExtArgs> | null
    /**
     * The filter to search for the Cafe to update in case it exists.
     */
    where: CafeWhereUniqueInput
    /**
     * In case the Cafe found by the `where` argument doesn't exist, create a new Cafe with this data.
     */
    create: XOR<CafeCreateInput, CafeUncheckedCreateInput>
    /**
     * In case the Cafe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CafeUpdateInput, CafeUncheckedUpdateInput>
  }

  /**
   * Cafe delete
   */
  export type CafeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cafe
     */
    select?: CafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cafe
     */
    omit?: CafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInclude<ExtArgs> | null
    /**
     * Filter which Cafe to delete.
     */
    where: CafeWhereUniqueInput
  }

  /**
   * Cafe deleteMany
   */
  export type CafeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cafes to delete
     */
    where?: CafeWhereInput
    /**
     * Limit how many Cafes to delete.
     */
    limit?: number
  }

  /**
   * Cafe.menu
   */
  export type Cafe$menuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeMenu
     */
    select?: CafeMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeMenu
     */
    omit?: CafeMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeMenuInclude<ExtArgs> | null
    where?: CafeMenuWhereInput
    orderBy?: CafeMenuOrderByWithRelationInput | CafeMenuOrderByWithRelationInput[]
    cursor?: CafeMenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CafeMenuScalarFieldEnum | CafeMenuScalarFieldEnum[]
  }

  /**
   * Cafe.photos
   */
  export type Cafe$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafePhoto
     */
    select?: CafePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafePhoto
     */
    omit?: CafePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafePhotoInclude<ExtArgs> | null
    where?: CafePhotoWhereInput
    orderBy?: CafePhotoOrderByWithRelationInput | CafePhotoOrderByWithRelationInput[]
    cursor?: CafePhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CafePhotoScalarFieldEnum | CafePhotoScalarFieldEnum[]
  }

  /**
   * Cafe.available_challenges
   */
  export type Cafe$available_challengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeAvailableCafe
     */
    select?: ChallengeAvailableCafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeAvailableCafe
     */
    omit?: ChallengeAvailableCafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeAvailableCafeInclude<ExtArgs> | null
    where?: ChallengeAvailableCafeWhereInput
    orderBy?: ChallengeAvailableCafeOrderByWithRelationInput | ChallengeAvailableCafeOrderByWithRelationInput[]
    cursor?: ChallengeAvailableCafeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeAvailableCafeScalarFieldEnum | ChallengeAvailableCafeScalarFieldEnum[]
  }

  /**
   * Cafe.stamp_books
   */
  export type Cafe$stamp_booksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StampBook
     */
    select?: StampBookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StampBook
     */
    omit?: StampBookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StampBookInclude<ExtArgs> | null
    where?: StampBookWhereInput
    orderBy?: StampBookOrderByWithRelationInput | StampBookOrderByWithRelationInput[]
    cursor?: StampBookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StampBookScalarFieldEnum | StampBookScalarFieldEnum[]
  }

  /**
   * Cafe.reviews
   */
  export type Cafe$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Cafe.notifications
   */
  export type Cafe$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Cafe.coupons
   */
  export type Cafe$couponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    cursor?: CouponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Cafe without action
   */
  export type CafeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cafe
     */
    select?: CafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cafe
     */
    omit?: CafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeInclude<ExtArgs> | null
  }


  /**
   * Model CafeMenu
   */

  export type AggregateCafeMenu = {
    _count: CafeMenuCountAggregateOutputType | null
    _avg: CafeMenuAvgAggregateOutputType | null
    _sum: CafeMenuSumAggregateOutputType | null
    _min: CafeMenuMinAggregateOutputType | null
    _max: CafeMenuMaxAggregateOutputType | null
  }

  export type CafeMenuAvgAggregateOutputType = {
    id: number | null
    cafe_id: number | null
    price: number | null
  }

  export type CafeMenuSumAggregateOutputType = {
    id: bigint | null
    cafe_id: bigint | null
    price: number | null
  }

  export type CafeMenuMinAggregateOutputType = {
    id: bigint | null
    cafe_id: bigint | null
    category: string | null
    name: string | null
    description: string | null
    price: number | null
    is_sold_out: boolean | null
    photo_url: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CafeMenuMaxAggregateOutputType = {
    id: bigint | null
    cafe_id: bigint | null
    category: string | null
    name: string | null
    description: string | null
    price: number | null
    is_sold_out: boolean | null
    photo_url: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CafeMenuCountAggregateOutputType = {
    id: number
    cafe_id: number
    category: number
    name: number
    description: number
    price: number
    is_sold_out: number
    photo_url: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CafeMenuAvgAggregateInputType = {
    id?: true
    cafe_id?: true
    price?: true
  }

  export type CafeMenuSumAggregateInputType = {
    id?: true
    cafe_id?: true
    price?: true
  }

  export type CafeMenuMinAggregateInputType = {
    id?: true
    cafe_id?: true
    category?: true
    name?: true
    description?: true
    price?: true
    is_sold_out?: true
    photo_url?: true
    created_at?: true
    updated_at?: true
  }

  export type CafeMenuMaxAggregateInputType = {
    id?: true
    cafe_id?: true
    category?: true
    name?: true
    description?: true
    price?: true
    is_sold_out?: true
    photo_url?: true
    created_at?: true
    updated_at?: true
  }

  export type CafeMenuCountAggregateInputType = {
    id?: true
    cafe_id?: true
    category?: true
    name?: true
    description?: true
    price?: true
    is_sold_out?: true
    photo_url?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CafeMenuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeMenu to aggregate.
     */
    where?: CafeMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeMenus to fetch.
     */
    orderBy?: CafeMenuOrderByWithRelationInput | CafeMenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CafeMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafeMenus
    **/
    _count?: true | CafeMenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafeMenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafeMenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafeMenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafeMenuMaxAggregateInputType
  }

  export type GetCafeMenuAggregateType<T extends CafeMenuAggregateArgs> = {
        [P in keyof T & keyof AggregateCafeMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafeMenu[P]>
      : GetScalarType<T[P], AggregateCafeMenu[P]>
  }




  export type CafeMenuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafeMenuWhereInput
    orderBy?: CafeMenuOrderByWithAggregationInput | CafeMenuOrderByWithAggregationInput[]
    by: CafeMenuScalarFieldEnum[] | CafeMenuScalarFieldEnum
    having?: CafeMenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafeMenuCountAggregateInputType | true
    _avg?: CafeMenuAvgAggregateInputType
    _sum?: CafeMenuSumAggregateInputType
    _min?: CafeMenuMinAggregateInputType
    _max?: CafeMenuMaxAggregateInputType
  }

  export type CafeMenuGroupByOutputType = {
    id: bigint
    cafe_id: bigint
    category: string
    name: string
    description: string
    price: number
    is_sold_out: boolean
    photo_url: string
    created_at: Date
    updated_at: Date
    _count: CafeMenuCountAggregateOutputType | null
    _avg: CafeMenuAvgAggregateOutputType | null
    _sum: CafeMenuSumAggregateOutputType | null
    _min: CafeMenuMinAggregateOutputType | null
    _max: CafeMenuMaxAggregateOutputType | null
  }

  type GetCafeMenuGroupByPayload<T extends CafeMenuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CafeMenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafeMenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafeMenuGroupByOutputType[P]>
            : GetScalarType<T[P], CafeMenuGroupByOutputType[P]>
        }
      >
    >


  export type CafeMenuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cafe_id?: boolean
    category?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    is_sold_out?: boolean
    photo_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeMenu"]>

  export type CafeMenuSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cafe_id?: boolean
    category?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    is_sold_out?: boolean
    photo_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeMenu"]>

  export type CafeMenuSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cafe_id?: boolean
    category?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    is_sold_out?: boolean
    photo_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafeMenu"]>

  export type CafeMenuSelectScalar = {
    id?: boolean
    cafe_id?: boolean
    category?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    is_sold_out?: boolean
    photo_url?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CafeMenuOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cafe_id" | "category" | "name" | "description" | "price" | "is_sold_out" | "photo_url" | "created_at" | "updated_at", ExtArgs["result"]["cafeMenu"]>
  export type CafeMenuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }
  export type CafeMenuIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }
  export type CafeMenuIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }

  export type $CafeMenuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CafeMenu"
    objects: {
      cafe: Prisma.$CafePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      cafe_id: bigint
      category: string
      name: string
      description: string
      price: number
      is_sold_out: boolean
      photo_url: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["cafeMenu"]>
    composites: {}
  }

  type CafeMenuGetPayload<S extends boolean | null | undefined | CafeMenuDefaultArgs> = $Result.GetResult<Prisma.$CafeMenuPayload, S>

  type CafeMenuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CafeMenuFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CafeMenuCountAggregateInputType | true
    }

  export interface CafeMenuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CafeMenu'], meta: { name: 'CafeMenu' } }
    /**
     * Find zero or one CafeMenu that matches the filter.
     * @param {CafeMenuFindUniqueArgs} args - Arguments to find a CafeMenu
     * @example
     * // Get one CafeMenu
     * const cafeMenu = await prisma.cafeMenu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CafeMenuFindUniqueArgs>(args: SelectSubset<T, CafeMenuFindUniqueArgs<ExtArgs>>): Prisma__CafeMenuClient<$Result.GetResult<Prisma.$CafeMenuPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CafeMenu that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CafeMenuFindUniqueOrThrowArgs} args - Arguments to find a CafeMenu
     * @example
     * // Get one CafeMenu
     * const cafeMenu = await prisma.cafeMenu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CafeMenuFindUniqueOrThrowArgs>(args: SelectSubset<T, CafeMenuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CafeMenuClient<$Result.GetResult<Prisma.$CafeMenuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeMenu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeMenuFindFirstArgs} args - Arguments to find a CafeMenu
     * @example
     * // Get one CafeMenu
     * const cafeMenu = await prisma.cafeMenu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CafeMenuFindFirstArgs>(args?: SelectSubset<T, CafeMenuFindFirstArgs<ExtArgs>>): Prisma__CafeMenuClient<$Result.GetResult<Prisma.$CafeMenuPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafeMenu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeMenuFindFirstOrThrowArgs} args - Arguments to find a CafeMenu
     * @example
     * // Get one CafeMenu
     * const cafeMenu = await prisma.cafeMenu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CafeMenuFindFirstOrThrowArgs>(args?: SelectSubset<T, CafeMenuFindFirstOrThrowArgs<ExtArgs>>): Prisma__CafeMenuClient<$Result.GetResult<Prisma.$CafeMenuPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CafeMenus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeMenuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafeMenus
     * const cafeMenus = await prisma.cafeMenu.findMany()
     * 
     * // Get first 10 CafeMenus
     * const cafeMenus = await prisma.cafeMenu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafeMenuWithIdOnly = await prisma.cafeMenu.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CafeMenuFindManyArgs>(args?: SelectSubset<T, CafeMenuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeMenuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CafeMenu.
     * @param {CafeMenuCreateArgs} args - Arguments to create a CafeMenu.
     * @example
     * // Create one CafeMenu
     * const CafeMenu = await prisma.cafeMenu.create({
     *   data: {
     *     // ... data to create a CafeMenu
     *   }
     * })
     * 
     */
    create<T extends CafeMenuCreateArgs>(args: SelectSubset<T, CafeMenuCreateArgs<ExtArgs>>): Prisma__CafeMenuClient<$Result.GetResult<Prisma.$CafeMenuPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CafeMenus.
     * @param {CafeMenuCreateManyArgs} args - Arguments to create many CafeMenus.
     * @example
     * // Create many CafeMenus
     * const cafeMenu = await prisma.cafeMenu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CafeMenuCreateManyArgs>(args?: SelectSubset<T, CafeMenuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CafeMenus and returns the data saved in the database.
     * @param {CafeMenuCreateManyAndReturnArgs} args - Arguments to create many CafeMenus.
     * @example
     * // Create many CafeMenus
     * const cafeMenu = await prisma.cafeMenu.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CafeMenus and only return the `id`
     * const cafeMenuWithIdOnly = await prisma.cafeMenu.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CafeMenuCreateManyAndReturnArgs>(args?: SelectSubset<T, CafeMenuCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeMenuPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CafeMenu.
     * @param {CafeMenuDeleteArgs} args - Arguments to delete one CafeMenu.
     * @example
     * // Delete one CafeMenu
     * const CafeMenu = await prisma.cafeMenu.delete({
     *   where: {
     *     // ... filter to delete one CafeMenu
     *   }
     * })
     * 
     */
    delete<T extends CafeMenuDeleteArgs>(args: SelectSubset<T, CafeMenuDeleteArgs<ExtArgs>>): Prisma__CafeMenuClient<$Result.GetResult<Prisma.$CafeMenuPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CafeMenu.
     * @param {CafeMenuUpdateArgs} args - Arguments to update one CafeMenu.
     * @example
     * // Update one CafeMenu
     * const cafeMenu = await prisma.cafeMenu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CafeMenuUpdateArgs>(args: SelectSubset<T, CafeMenuUpdateArgs<ExtArgs>>): Prisma__CafeMenuClient<$Result.GetResult<Prisma.$CafeMenuPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CafeMenus.
     * @param {CafeMenuDeleteManyArgs} args - Arguments to filter CafeMenus to delete.
     * @example
     * // Delete a few CafeMenus
     * const { count } = await prisma.cafeMenu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CafeMenuDeleteManyArgs>(args?: SelectSubset<T, CafeMenuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeMenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeMenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafeMenus
     * const cafeMenu = await prisma.cafeMenu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CafeMenuUpdateManyArgs>(args: SelectSubset<T, CafeMenuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafeMenus and returns the data updated in the database.
     * @param {CafeMenuUpdateManyAndReturnArgs} args - Arguments to update many CafeMenus.
     * @example
     * // Update many CafeMenus
     * const cafeMenu = await prisma.cafeMenu.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CafeMenus and only return the `id`
     * const cafeMenuWithIdOnly = await prisma.cafeMenu.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CafeMenuUpdateManyAndReturnArgs>(args: SelectSubset<T, CafeMenuUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafeMenuPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CafeMenu.
     * @param {CafeMenuUpsertArgs} args - Arguments to update or create a CafeMenu.
     * @example
     * // Update or create a CafeMenu
     * const cafeMenu = await prisma.cafeMenu.upsert({
     *   create: {
     *     // ... data to create a CafeMenu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafeMenu we want to update
     *   }
     * })
     */
    upsert<T extends CafeMenuUpsertArgs>(args: SelectSubset<T, CafeMenuUpsertArgs<ExtArgs>>): Prisma__CafeMenuClient<$Result.GetResult<Prisma.$CafeMenuPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CafeMenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeMenuCountArgs} args - Arguments to filter CafeMenus to count.
     * @example
     * // Count the number of CafeMenus
     * const count = await prisma.cafeMenu.count({
     *   where: {
     *     // ... the filter for the CafeMenus we want to count
     *   }
     * })
    **/
    count<T extends CafeMenuCountArgs>(
      args?: Subset<T, CafeMenuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafeMenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafeMenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeMenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafeMenuAggregateArgs>(args: Subset<T, CafeMenuAggregateArgs>): Prisma.PrismaPromise<GetCafeMenuAggregateType<T>>

    /**
     * Group by CafeMenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafeMenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafeMenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafeMenuGroupByArgs['orderBy'] }
        : { orderBy?: CafeMenuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafeMenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafeMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CafeMenu model
   */
  readonly fields: CafeMenuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CafeMenu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CafeMenuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cafe<T extends CafeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CafeDefaultArgs<ExtArgs>>): Prisma__CafeClient<$Result.GetResult<Prisma.$CafePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CafeMenu model
   */
  interface CafeMenuFieldRefs {
    readonly id: FieldRef<"CafeMenu", 'BigInt'>
    readonly cafe_id: FieldRef<"CafeMenu", 'BigInt'>
    readonly category: FieldRef<"CafeMenu", 'String'>
    readonly name: FieldRef<"CafeMenu", 'String'>
    readonly description: FieldRef<"CafeMenu", 'String'>
    readonly price: FieldRef<"CafeMenu", 'Int'>
    readonly is_sold_out: FieldRef<"CafeMenu", 'Boolean'>
    readonly photo_url: FieldRef<"CafeMenu", 'String'>
    readonly created_at: FieldRef<"CafeMenu", 'DateTime'>
    readonly updated_at: FieldRef<"CafeMenu", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CafeMenu findUnique
   */
  export type CafeMenuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeMenu
     */
    select?: CafeMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeMenu
     */
    omit?: CafeMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeMenuInclude<ExtArgs> | null
    /**
     * Filter, which CafeMenu to fetch.
     */
    where: CafeMenuWhereUniqueInput
  }

  /**
   * CafeMenu findUniqueOrThrow
   */
  export type CafeMenuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeMenu
     */
    select?: CafeMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeMenu
     */
    omit?: CafeMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeMenuInclude<ExtArgs> | null
    /**
     * Filter, which CafeMenu to fetch.
     */
    where: CafeMenuWhereUniqueInput
  }

  /**
   * CafeMenu findFirst
   */
  export type CafeMenuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeMenu
     */
    select?: CafeMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeMenu
     */
    omit?: CafeMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeMenuInclude<ExtArgs> | null
    /**
     * Filter, which CafeMenu to fetch.
     */
    where?: CafeMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeMenus to fetch.
     */
    orderBy?: CafeMenuOrderByWithRelationInput | CafeMenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeMenus.
     */
    cursor?: CafeMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeMenus.
     */
    distinct?: CafeMenuScalarFieldEnum | CafeMenuScalarFieldEnum[]
  }

  /**
   * CafeMenu findFirstOrThrow
   */
  export type CafeMenuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeMenu
     */
    select?: CafeMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeMenu
     */
    omit?: CafeMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeMenuInclude<ExtArgs> | null
    /**
     * Filter, which CafeMenu to fetch.
     */
    where?: CafeMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeMenus to fetch.
     */
    orderBy?: CafeMenuOrderByWithRelationInput | CafeMenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafeMenus.
     */
    cursor?: CafeMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafeMenus.
     */
    distinct?: CafeMenuScalarFieldEnum | CafeMenuScalarFieldEnum[]
  }

  /**
   * CafeMenu findMany
   */
  export type CafeMenuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeMenu
     */
    select?: CafeMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeMenu
     */
    omit?: CafeMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeMenuInclude<ExtArgs> | null
    /**
     * Filter, which CafeMenus to fetch.
     */
    where?: CafeMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafeMenus to fetch.
     */
    orderBy?: CafeMenuOrderByWithRelationInput | CafeMenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafeMenus.
     */
    cursor?: CafeMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafeMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafeMenus.
     */
    skip?: number
    distinct?: CafeMenuScalarFieldEnum | CafeMenuScalarFieldEnum[]
  }

  /**
   * CafeMenu create
   */
  export type CafeMenuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeMenu
     */
    select?: CafeMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeMenu
     */
    omit?: CafeMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeMenuInclude<ExtArgs> | null
    /**
     * The data needed to create a CafeMenu.
     */
    data: XOR<CafeMenuCreateInput, CafeMenuUncheckedCreateInput>
  }

  /**
   * CafeMenu createMany
   */
  export type CafeMenuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CafeMenus.
     */
    data: CafeMenuCreateManyInput | CafeMenuCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CafeMenu createManyAndReturn
   */
  export type CafeMenuCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeMenu
     */
    select?: CafeMenuSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeMenu
     */
    omit?: CafeMenuOmit<ExtArgs> | null
    /**
     * The data used to create many CafeMenus.
     */
    data: CafeMenuCreateManyInput | CafeMenuCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeMenuIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeMenu update
   */
  export type CafeMenuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeMenu
     */
    select?: CafeMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeMenu
     */
    omit?: CafeMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeMenuInclude<ExtArgs> | null
    /**
     * The data needed to update a CafeMenu.
     */
    data: XOR<CafeMenuUpdateInput, CafeMenuUncheckedUpdateInput>
    /**
     * Choose, which CafeMenu to update.
     */
    where: CafeMenuWhereUniqueInput
  }

  /**
   * CafeMenu updateMany
   */
  export type CafeMenuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CafeMenus.
     */
    data: XOR<CafeMenuUpdateManyMutationInput, CafeMenuUncheckedUpdateManyInput>
    /**
     * Filter which CafeMenus to update
     */
    where?: CafeMenuWhereInput
    /**
     * Limit how many CafeMenus to update.
     */
    limit?: number
  }

  /**
   * CafeMenu updateManyAndReturn
   */
  export type CafeMenuUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeMenu
     */
    select?: CafeMenuSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafeMenu
     */
    omit?: CafeMenuOmit<ExtArgs> | null
    /**
     * The data used to update CafeMenus.
     */
    data: XOR<CafeMenuUpdateManyMutationInput, CafeMenuUncheckedUpdateManyInput>
    /**
     * Filter which CafeMenus to update
     */
    where?: CafeMenuWhereInput
    /**
     * Limit how many CafeMenus to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeMenuIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafeMenu upsert
   */
  export type CafeMenuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeMenu
     */
    select?: CafeMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeMenu
     */
    omit?: CafeMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeMenuInclude<ExtArgs> | null
    /**
     * The filter to search for the CafeMenu to update in case it exists.
     */
    where: CafeMenuWhereUniqueInput
    /**
     * In case the CafeMenu found by the `where` argument doesn't exist, create a new CafeMenu with this data.
     */
    create: XOR<CafeMenuCreateInput, CafeMenuUncheckedCreateInput>
    /**
     * In case the CafeMenu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CafeMenuUpdateInput, CafeMenuUncheckedUpdateInput>
  }

  /**
   * CafeMenu delete
   */
  export type CafeMenuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeMenu
     */
    select?: CafeMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeMenu
     */
    omit?: CafeMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeMenuInclude<ExtArgs> | null
    /**
     * Filter which CafeMenu to delete.
     */
    where: CafeMenuWhereUniqueInput
  }

  /**
   * CafeMenu deleteMany
   */
  export type CafeMenuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafeMenus to delete
     */
    where?: CafeMenuWhereInput
    /**
     * Limit how many CafeMenus to delete.
     */
    limit?: number
  }

  /**
   * CafeMenu without action
   */
  export type CafeMenuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafeMenu
     */
    select?: CafeMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafeMenu
     */
    omit?: CafeMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafeMenuInclude<ExtArgs> | null
  }


  /**
   * Model CafePhoto
   */

  export type AggregateCafePhoto = {
    _count: CafePhotoCountAggregateOutputType | null
    _avg: CafePhotoAvgAggregateOutputType | null
    _sum: CafePhotoSumAggregateOutputType | null
    _min: CafePhotoMinAggregateOutputType | null
    _max: CafePhotoMaxAggregateOutputType | null
  }

  export type CafePhotoAvgAggregateOutputType = {
    id: number | null
    cafe_id: number | null
    display_order: number | null
  }

  export type CafePhotoSumAggregateOutputType = {
    id: bigint | null
    cafe_id: bigint | null
    display_order: number | null
  }

  export type CafePhotoMinAggregateOutputType = {
    id: bigint | null
    cafe_id: bigint | null
    photo_url: string | null
    display_order: number | null
    created_at: Date | null
  }

  export type CafePhotoMaxAggregateOutputType = {
    id: bigint | null
    cafe_id: bigint | null
    photo_url: string | null
    display_order: number | null
    created_at: Date | null
  }

  export type CafePhotoCountAggregateOutputType = {
    id: number
    cafe_id: number
    photo_url: number
    display_order: number
    created_at: number
    _all: number
  }


  export type CafePhotoAvgAggregateInputType = {
    id?: true
    cafe_id?: true
    display_order?: true
  }

  export type CafePhotoSumAggregateInputType = {
    id?: true
    cafe_id?: true
    display_order?: true
  }

  export type CafePhotoMinAggregateInputType = {
    id?: true
    cafe_id?: true
    photo_url?: true
    display_order?: true
    created_at?: true
  }

  export type CafePhotoMaxAggregateInputType = {
    id?: true
    cafe_id?: true
    photo_url?: true
    display_order?: true
    created_at?: true
  }

  export type CafePhotoCountAggregateInputType = {
    id?: true
    cafe_id?: true
    photo_url?: true
    display_order?: true
    created_at?: true
    _all?: true
  }

  export type CafePhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafePhoto to aggregate.
     */
    where?: CafePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafePhotos to fetch.
     */
    orderBy?: CafePhotoOrderByWithRelationInput | CafePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CafePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CafePhotos
    **/
    _count?: true | CafePhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CafePhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CafePhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CafePhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CafePhotoMaxAggregateInputType
  }

  export type GetCafePhotoAggregateType<T extends CafePhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateCafePhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCafePhoto[P]>
      : GetScalarType<T[P], AggregateCafePhoto[P]>
  }




  export type CafePhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CafePhotoWhereInput
    orderBy?: CafePhotoOrderByWithAggregationInput | CafePhotoOrderByWithAggregationInput[]
    by: CafePhotoScalarFieldEnum[] | CafePhotoScalarFieldEnum
    having?: CafePhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CafePhotoCountAggregateInputType | true
    _avg?: CafePhotoAvgAggregateInputType
    _sum?: CafePhotoSumAggregateInputType
    _min?: CafePhotoMinAggregateInputType
    _max?: CafePhotoMaxAggregateInputType
  }

  export type CafePhotoGroupByOutputType = {
    id: bigint
    cafe_id: bigint
    photo_url: string
    display_order: number
    created_at: Date
    _count: CafePhotoCountAggregateOutputType | null
    _avg: CafePhotoAvgAggregateOutputType | null
    _sum: CafePhotoSumAggregateOutputType | null
    _min: CafePhotoMinAggregateOutputType | null
    _max: CafePhotoMaxAggregateOutputType | null
  }

  type GetCafePhotoGroupByPayload<T extends CafePhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CafePhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CafePhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CafePhotoGroupByOutputType[P]>
            : GetScalarType<T[P], CafePhotoGroupByOutputType[P]>
        }
      >
    >


  export type CafePhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cafe_id?: boolean
    photo_url?: boolean
    display_order?: boolean
    created_at?: boolean
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafePhoto"]>

  export type CafePhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cafe_id?: boolean
    photo_url?: boolean
    display_order?: boolean
    created_at?: boolean
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafePhoto"]>

  export type CafePhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cafe_id?: boolean
    photo_url?: boolean
    display_order?: boolean
    created_at?: boolean
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cafePhoto"]>

  export type CafePhotoSelectScalar = {
    id?: boolean
    cafe_id?: boolean
    photo_url?: boolean
    display_order?: boolean
    created_at?: boolean
  }

  export type CafePhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cafe_id" | "photo_url" | "display_order" | "created_at", ExtArgs["result"]["cafePhoto"]>
  export type CafePhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }
  export type CafePhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }
  export type CafePhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }

  export type $CafePhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CafePhoto"
    objects: {
      cafe: Prisma.$CafePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      cafe_id: bigint
      photo_url: string
      display_order: number
      created_at: Date
    }, ExtArgs["result"]["cafePhoto"]>
    composites: {}
  }

  type CafePhotoGetPayload<S extends boolean | null | undefined | CafePhotoDefaultArgs> = $Result.GetResult<Prisma.$CafePhotoPayload, S>

  type CafePhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CafePhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CafePhotoCountAggregateInputType | true
    }

  export interface CafePhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CafePhoto'], meta: { name: 'CafePhoto' } }
    /**
     * Find zero or one CafePhoto that matches the filter.
     * @param {CafePhotoFindUniqueArgs} args - Arguments to find a CafePhoto
     * @example
     * // Get one CafePhoto
     * const cafePhoto = await prisma.cafePhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CafePhotoFindUniqueArgs>(args: SelectSubset<T, CafePhotoFindUniqueArgs<ExtArgs>>): Prisma__CafePhotoClient<$Result.GetResult<Prisma.$CafePhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CafePhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CafePhotoFindUniqueOrThrowArgs} args - Arguments to find a CafePhoto
     * @example
     * // Get one CafePhoto
     * const cafePhoto = await prisma.cafePhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CafePhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, CafePhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CafePhotoClient<$Result.GetResult<Prisma.$CafePhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafePhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafePhotoFindFirstArgs} args - Arguments to find a CafePhoto
     * @example
     * // Get one CafePhoto
     * const cafePhoto = await prisma.cafePhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CafePhotoFindFirstArgs>(args?: SelectSubset<T, CafePhotoFindFirstArgs<ExtArgs>>): Prisma__CafePhotoClient<$Result.GetResult<Prisma.$CafePhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CafePhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafePhotoFindFirstOrThrowArgs} args - Arguments to find a CafePhoto
     * @example
     * // Get one CafePhoto
     * const cafePhoto = await prisma.cafePhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CafePhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, CafePhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CafePhotoClient<$Result.GetResult<Prisma.$CafePhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CafePhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafePhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CafePhotos
     * const cafePhotos = await prisma.cafePhoto.findMany()
     * 
     * // Get first 10 CafePhotos
     * const cafePhotos = await prisma.cafePhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cafePhotoWithIdOnly = await prisma.cafePhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CafePhotoFindManyArgs>(args?: SelectSubset<T, CafePhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafePhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CafePhoto.
     * @param {CafePhotoCreateArgs} args - Arguments to create a CafePhoto.
     * @example
     * // Create one CafePhoto
     * const CafePhoto = await prisma.cafePhoto.create({
     *   data: {
     *     // ... data to create a CafePhoto
     *   }
     * })
     * 
     */
    create<T extends CafePhotoCreateArgs>(args: SelectSubset<T, CafePhotoCreateArgs<ExtArgs>>): Prisma__CafePhotoClient<$Result.GetResult<Prisma.$CafePhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CafePhotos.
     * @param {CafePhotoCreateManyArgs} args - Arguments to create many CafePhotos.
     * @example
     * // Create many CafePhotos
     * const cafePhoto = await prisma.cafePhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CafePhotoCreateManyArgs>(args?: SelectSubset<T, CafePhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CafePhotos and returns the data saved in the database.
     * @param {CafePhotoCreateManyAndReturnArgs} args - Arguments to create many CafePhotos.
     * @example
     * // Create many CafePhotos
     * const cafePhoto = await prisma.cafePhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CafePhotos and only return the `id`
     * const cafePhotoWithIdOnly = await prisma.cafePhoto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CafePhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, CafePhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafePhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CafePhoto.
     * @param {CafePhotoDeleteArgs} args - Arguments to delete one CafePhoto.
     * @example
     * // Delete one CafePhoto
     * const CafePhoto = await prisma.cafePhoto.delete({
     *   where: {
     *     // ... filter to delete one CafePhoto
     *   }
     * })
     * 
     */
    delete<T extends CafePhotoDeleteArgs>(args: SelectSubset<T, CafePhotoDeleteArgs<ExtArgs>>): Prisma__CafePhotoClient<$Result.GetResult<Prisma.$CafePhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CafePhoto.
     * @param {CafePhotoUpdateArgs} args - Arguments to update one CafePhoto.
     * @example
     * // Update one CafePhoto
     * const cafePhoto = await prisma.cafePhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CafePhotoUpdateArgs>(args: SelectSubset<T, CafePhotoUpdateArgs<ExtArgs>>): Prisma__CafePhotoClient<$Result.GetResult<Prisma.$CafePhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CafePhotos.
     * @param {CafePhotoDeleteManyArgs} args - Arguments to filter CafePhotos to delete.
     * @example
     * // Delete a few CafePhotos
     * const { count } = await prisma.cafePhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CafePhotoDeleteManyArgs>(args?: SelectSubset<T, CafePhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafePhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafePhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CafePhotos
     * const cafePhoto = await prisma.cafePhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CafePhotoUpdateManyArgs>(args: SelectSubset<T, CafePhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CafePhotos and returns the data updated in the database.
     * @param {CafePhotoUpdateManyAndReturnArgs} args - Arguments to update many CafePhotos.
     * @example
     * // Update many CafePhotos
     * const cafePhoto = await prisma.cafePhoto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CafePhotos and only return the `id`
     * const cafePhotoWithIdOnly = await prisma.cafePhoto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CafePhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, CafePhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CafePhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CafePhoto.
     * @param {CafePhotoUpsertArgs} args - Arguments to update or create a CafePhoto.
     * @example
     * // Update or create a CafePhoto
     * const cafePhoto = await prisma.cafePhoto.upsert({
     *   create: {
     *     // ... data to create a CafePhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CafePhoto we want to update
     *   }
     * })
     */
    upsert<T extends CafePhotoUpsertArgs>(args: SelectSubset<T, CafePhotoUpsertArgs<ExtArgs>>): Prisma__CafePhotoClient<$Result.GetResult<Prisma.$CafePhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CafePhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafePhotoCountArgs} args - Arguments to filter CafePhotos to count.
     * @example
     * // Count the number of CafePhotos
     * const count = await prisma.cafePhoto.count({
     *   where: {
     *     // ... the filter for the CafePhotos we want to count
     *   }
     * })
    **/
    count<T extends CafePhotoCountArgs>(
      args?: Subset<T, CafePhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CafePhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CafePhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafePhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CafePhotoAggregateArgs>(args: Subset<T, CafePhotoAggregateArgs>): Prisma.PrismaPromise<GetCafePhotoAggregateType<T>>

    /**
     * Group by CafePhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CafePhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CafePhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CafePhotoGroupByArgs['orderBy'] }
        : { orderBy?: CafePhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CafePhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCafePhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CafePhoto model
   */
  readonly fields: CafePhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CafePhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CafePhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cafe<T extends CafeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CafeDefaultArgs<ExtArgs>>): Prisma__CafeClient<$Result.GetResult<Prisma.$CafePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CafePhoto model
   */
  interface CafePhotoFieldRefs {
    readonly id: FieldRef<"CafePhoto", 'BigInt'>
    readonly cafe_id: FieldRef<"CafePhoto", 'BigInt'>
    readonly photo_url: FieldRef<"CafePhoto", 'String'>
    readonly display_order: FieldRef<"CafePhoto", 'Int'>
    readonly created_at: FieldRef<"CafePhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CafePhoto findUnique
   */
  export type CafePhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafePhoto
     */
    select?: CafePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafePhoto
     */
    omit?: CafePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafePhotoInclude<ExtArgs> | null
    /**
     * Filter, which CafePhoto to fetch.
     */
    where: CafePhotoWhereUniqueInput
  }

  /**
   * CafePhoto findUniqueOrThrow
   */
  export type CafePhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafePhoto
     */
    select?: CafePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafePhoto
     */
    omit?: CafePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafePhotoInclude<ExtArgs> | null
    /**
     * Filter, which CafePhoto to fetch.
     */
    where: CafePhotoWhereUniqueInput
  }

  /**
   * CafePhoto findFirst
   */
  export type CafePhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafePhoto
     */
    select?: CafePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafePhoto
     */
    omit?: CafePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafePhotoInclude<ExtArgs> | null
    /**
     * Filter, which CafePhoto to fetch.
     */
    where?: CafePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafePhotos to fetch.
     */
    orderBy?: CafePhotoOrderByWithRelationInput | CafePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafePhotos.
     */
    cursor?: CafePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafePhotos.
     */
    distinct?: CafePhotoScalarFieldEnum | CafePhotoScalarFieldEnum[]
  }

  /**
   * CafePhoto findFirstOrThrow
   */
  export type CafePhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafePhoto
     */
    select?: CafePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafePhoto
     */
    omit?: CafePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafePhotoInclude<ExtArgs> | null
    /**
     * Filter, which CafePhoto to fetch.
     */
    where?: CafePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafePhotos to fetch.
     */
    orderBy?: CafePhotoOrderByWithRelationInput | CafePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CafePhotos.
     */
    cursor?: CafePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CafePhotos.
     */
    distinct?: CafePhotoScalarFieldEnum | CafePhotoScalarFieldEnum[]
  }

  /**
   * CafePhoto findMany
   */
  export type CafePhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafePhoto
     */
    select?: CafePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafePhoto
     */
    omit?: CafePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafePhotoInclude<ExtArgs> | null
    /**
     * Filter, which CafePhotos to fetch.
     */
    where?: CafePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CafePhotos to fetch.
     */
    orderBy?: CafePhotoOrderByWithRelationInput | CafePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CafePhotos.
     */
    cursor?: CafePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CafePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CafePhotos.
     */
    skip?: number
    distinct?: CafePhotoScalarFieldEnum | CafePhotoScalarFieldEnum[]
  }

  /**
   * CafePhoto create
   */
  export type CafePhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafePhoto
     */
    select?: CafePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafePhoto
     */
    omit?: CafePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafePhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a CafePhoto.
     */
    data: XOR<CafePhotoCreateInput, CafePhotoUncheckedCreateInput>
  }

  /**
   * CafePhoto createMany
   */
  export type CafePhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CafePhotos.
     */
    data: CafePhotoCreateManyInput | CafePhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CafePhoto createManyAndReturn
   */
  export type CafePhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafePhoto
     */
    select?: CafePhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafePhoto
     */
    omit?: CafePhotoOmit<ExtArgs> | null
    /**
     * The data used to create many CafePhotos.
     */
    data: CafePhotoCreateManyInput | CafePhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafePhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafePhoto update
   */
  export type CafePhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafePhoto
     */
    select?: CafePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafePhoto
     */
    omit?: CafePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafePhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a CafePhoto.
     */
    data: XOR<CafePhotoUpdateInput, CafePhotoUncheckedUpdateInput>
    /**
     * Choose, which CafePhoto to update.
     */
    where: CafePhotoWhereUniqueInput
  }

  /**
   * CafePhoto updateMany
   */
  export type CafePhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CafePhotos.
     */
    data: XOR<CafePhotoUpdateManyMutationInput, CafePhotoUncheckedUpdateManyInput>
    /**
     * Filter which CafePhotos to update
     */
    where?: CafePhotoWhereInput
    /**
     * Limit how many CafePhotos to update.
     */
    limit?: number
  }

  /**
   * CafePhoto updateManyAndReturn
   */
  export type CafePhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafePhoto
     */
    select?: CafePhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CafePhoto
     */
    omit?: CafePhotoOmit<ExtArgs> | null
    /**
     * The data used to update CafePhotos.
     */
    data: XOR<CafePhotoUpdateManyMutationInput, CafePhotoUncheckedUpdateManyInput>
    /**
     * Filter which CafePhotos to update
     */
    where?: CafePhotoWhereInput
    /**
     * Limit how many CafePhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafePhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CafePhoto upsert
   */
  export type CafePhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafePhoto
     */
    select?: CafePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafePhoto
     */
    omit?: CafePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafePhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the CafePhoto to update in case it exists.
     */
    where: CafePhotoWhereUniqueInput
    /**
     * In case the CafePhoto found by the `where` argument doesn't exist, create a new CafePhoto with this data.
     */
    create: XOR<CafePhotoCreateInput, CafePhotoUncheckedCreateInput>
    /**
     * In case the CafePhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CafePhotoUpdateInput, CafePhotoUncheckedUpdateInput>
  }

  /**
   * CafePhoto delete
   */
  export type CafePhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafePhoto
     */
    select?: CafePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafePhoto
     */
    omit?: CafePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafePhotoInclude<ExtArgs> | null
    /**
     * Filter which CafePhoto to delete.
     */
    where: CafePhotoWhereUniqueInput
  }

  /**
   * CafePhoto deleteMany
   */
  export type CafePhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CafePhotos to delete
     */
    where?: CafePhotoWhereInput
    /**
     * Limit how many CafePhotos to delete.
     */
    limit?: number
  }

  /**
   * CafePhoto without action
   */
  export type CafePhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CafePhoto
     */
    select?: CafePhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CafePhoto
     */
    omit?: CafePhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CafePhotoInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    cafe_id: number | null
  }

  export type ReviewSumAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    cafe_id: bigint | null
  }

  export type ReviewMinAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    cafe_id: bigint | null
    title: string | null
    content: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    cafe_id: bigint | null
    title: string | null
    content: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    user_id: number
    cafe_id: number
    title: number
    content: number
    images: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    id?: true
    user_id?: true
    cafe_id?: true
  }

  export type ReviewSumAggregateInputType = {
    id?: true
    user_id?: true
    cafe_id?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    user_id?: true
    cafe_id?: true
    title?: true
    content?: true
    created_at?: true
    updated_at?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    user_id?: true
    cafe_id?: true
    title?: true
    content?: true
    created_at?: true
    updated_at?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    user_id?: true
    cafe_id?: true
    title?: true
    content?: true
    images?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: number
    user_id: bigint
    cafe_id: bigint
    title: string
    content: string
    images: JsonValue
    created_at: Date
    updated_at: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    cafe_id?: boolean
    title?: boolean
    content?: boolean
    images?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    cafe_id?: boolean
    title?: boolean
    content?: boolean
    images?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    cafe_id?: boolean
    title?: boolean
    content?: boolean
    images?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    user_id?: boolean
    cafe_id?: boolean
    title?: boolean
    content?: boolean
    images?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "cafe_id" | "title" | "content" | "images" | "created_at" | "updated_at", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      cafe: Prisma.$CafePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: bigint
      cafe_id: bigint
      title: string
      content: string
      images: Prisma.JsonValue
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cafe<T extends CafeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CafeDefaultArgs<ExtArgs>>): Prisma__CafeClient<$Result.GetResult<Prisma.$CafePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'Int'>
    readonly user_id: FieldRef<"Review", 'BigInt'>
    readonly cafe_id: FieldRef<"Review", 'BigInt'>
    readonly title: FieldRef<"Review", 'String'>
    readonly content: FieldRef<"Review", 'String'>
    readonly images: FieldRef<"Review", 'Json'>
    readonly created_at: FieldRef<"Review", 'DateTime'>
    readonly updated_at: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    cafe_id: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    cafe_id: bigint | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    cafe_id: bigint | null
    type: string | null
    title: string | null
    content: string | null
    is_read: boolean | null
    created_at: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    cafe_id: bigint | null
    type: string | null
    title: string | null
    content: string | null
    is_read: boolean | null
    created_at: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    user_id: number
    cafe_id: number
    type: number
    title: number
    content: number
    is_read: number
    created_at: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    user_id?: true
    cafe_id?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    user_id?: true
    cafe_id?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    user_id?: true
    cafe_id?: true
    type?: true
    title?: true
    content?: true
    is_read?: true
    created_at?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    user_id?: true
    cafe_id?: true
    type?: true
    title?: true
    content?: true
    is_read?: true
    created_at?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    user_id?: true
    cafe_id?: true
    type?: true
    title?: true
    content?: true
    is_read?: true
    created_at?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    user_id: bigint
    cafe_id: bigint
    type: string
    title: string
    content: string
    is_read: boolean
    created_at: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    cafe_id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    is_read?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    cafe_id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    is_read?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    cafe_id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    is_read?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    user_id?: boolean
    cafe_id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    is_read?: boolean
    created_at?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "cafe_id" | "type" | "title" | "content" | "is_read" | "created_at", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      cafe: Prisma.$CafePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: bigint
      cafe_id: bigint
      type: string
      title: string
      content: string
      is_read: boolean
      created_at: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cafe<T extends CafeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CafeDefaultArgs<ExtArgs>>): Prisma__CafeClient<$Result.GetResult<Prisma.$CafePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly user_id: FieldRef<"Notification", 'BigInt'>
    readonly cafe_id: FieldRef<"Notification", 'BigInt'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly is_read: FieldRef<"Notification", 'Boolean'>
    readonly created_at: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Coupon
   */

  export type AggregateCoupon = {
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  export type CouponAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    cafe_id: number | null
  }

  export type CouponSumAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    cafe_id: bigint | null
  }

  export type CouponMinAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    cafe_id: bigint | null
    type: string | null
    name: string | null
    status: string | null
    issued_at: Date | null
    expired_at: Date | null
    used_at: Date | null
  }

  export type CouponMaxAggregateOutputType = {
    id: number | null
    user_id: bigint | null
    cafe_id: bigint | null
    type: string | null
    name: string | null
    status: string | null
    issued_at: Date | null
    expired_at: Date | null
    used_at: Date | null
  }

  export type CouponCountAggregateOutputType = {
    id: number
    user_id: number
    cafe_id: number
    type: number
    name: number
    status: number
    issued_at: number
    expired_at: number
    used_at: number
    _all: number
  }


  export type CouponAvgAggregateInputType = {
    id?: true
    user_id?: true
    cafe_id?: true
  }

  export type CouponSumAggregateInputType = {
    id?: true
    user_id?: true
    cafe_id?: true
  }

  export type CouponMinAggregateInputType = {
    id?: true
    user_id?: true
    cafe_id?: true
    type?: true
    name?: true
    status?: true
    issued_at?: true
    expired_at?: true
    used_at?: true
  }

  export type CouponMaxAggregateInputType = {
    id?: true
    user_id?: true
    cafe_id?: true
    type?: true
    name?: true
    status?: true
    issued_at?: true
    expired_at?: true
    used_at?: true
  }

  export type CouponCountAggregateInputType = {
    id?: true
    user_id?: true
    cafe_id?: true
    type?: true
    name?: true
    status?: true
    issued_at?: true
    expired_at?: true
    used_at?: true
    _all?: true
  }

  export type CouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupon to aggregate.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coupons
    **/
    _count?: true | CouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponMaxAggregateInputType
  }

  export type GetCouponAggregateType<T extends CouponAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupon[P]>
      : GetScalarType<T[P], AggregateCoupon[P]>
  }




  export type CouponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithAggregationInput | CouponOrderByWithAggregationInput[]
    by: CouponScalarFieldEnum[] | CouponScalarFieldEnum
    having?: CouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponCountAggregateInputType | true
    _avg?: CouponAvgAggregateInputType
    _sum?: CouponSumAggregateInputType
    _min?: CouponMinAggregateInputType
    _max?: CouponMaxAggregateInputType
  }

  export type CouponGroupByOutputType = {
    id: number
    user_id: bigint
    cafe_id: bigint
    type: string
    name: string
    status: string
    issued_at: Date
    expired_at: Date
    used_at: Date
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  type GetCouponGroupByPayload<T extends CouponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponGroupByOutputType[P]>
            : GetScalarType<T[P], CouponGroupByOutputType[P]>
        }
      >
    >


  export type CouponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    cafe_id?: boolean
    type?: boolean
    name?: boolean
    status?: boolean
    issued_at?: boolean
    expired_at?: boolean
    used_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    cafe_id?: boolean
    type?: boolean
    name?: boolean
    status?: boolean
    issued_at?: boolean
    expired_at?: boolean
    used_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    cafe_id?: boolean
    type?: boolean
    name?: boolean
    status?: boolean
    issued_at?: boolean
    expired_at?: boolean
    used_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectScalar = {
    id?: boolean
    user_id?: boolean
    cafe_id?: boolean
    type?: boolean
    name?: boolean
    status?: boolean
    issued_at?: boolean
    expired_at?: boolean
    used_at?: boolean
  }

  export type CouponOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "cafe_id" | "type" | "name" | "status" | "issued_at" | "expired_at" | "used_at", ExtArgs["result"]["coupon"]>
  export type CouponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }
  export type CouponIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }
  export type CouponIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    cafe?: boolean | CafeDefaultArgs<ExtArgs>
  }

  export type $CouponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Coupon"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      cafe: Prisma.$CafePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: bigint
      cafe_id: bigint
      type: string
      name: string
      status: string
      issued_at: Date
      expired_at: Date
      used_at: Date
    }, ExtArgs["result"]["coupon"]>
    composites: {}
  }

  type CouponGetPayload<S extends boolean | null | undefined | CouponDefaultArgs> = $Result.GetResult<Prisma.$CouponPayload, S>

  type CouponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CouponFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CouponCountAggregateInputType | true
    }

  export interface CouponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Coupon'], meta: { name: 'Coupon' } }
    /**
     * Find zero or one Coupon that matches the filter.
     * @param {CouponFindUniqueArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouponFindUniqueArgs>(args: SelectSubset<T, CouponFindUniqueArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Coupon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CouponFindUniqueOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouponFindUniqueOrThrowArgs>(args: SelectSubset<T, CouponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouponFindFirstArgs>(args?: SelectSubset<T, CouponFindFirstArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouponFindFirstOrThrowArgs>(args?: SelectSubset<T, CouponFindFirstOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupon.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponWithIdOnly = await prisma.coupon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CouponFindManyArgs>(args?: SelectSubset<T, CouponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Coupon.
     * @param {CouponCreateArgs} args - Arguments to create a Coupon.
     * @example
     * // Create one Coupon
     * const Coupon = await prisma.coupon.create({
     *   data: {
     *     // ... data to create a Coupon
     *   }
     * })
     * 
     */
    create<T extends CouponCreateArgs>(args: SelectSubset<T, CouponCreateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Coupons.
     * @param {CouponCreateManyArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CouponCreateManyArgs>(args?: SelectSubset<T, CouponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Coupons and returns the data saved in the database.
     * @param {CouponCreateManyAndReturnArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CouponCreateManyAndReturnArgs>(args?: SelectSubset<T, CouponCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Coupon.
     * @param {CouponDeleteArgs} args - Arguments to delete one Coupon.
     * @example
     * // Delete one Coupon
     * const Coupon = await prisma.coupon.delete({
     *   where: {
     *     // ... filter to delete one Coupon
     *   }
     * })
     * 
     */
    delete<T extends CouponDeleteArgs>(args: SelectSubset<T, CouponDeleteArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Coupon.
     * @param {CouponUpdateArgs} args - Arguments to update one Coupon.
     * @example
     * // Update one Coupon
     * const coupon = await prisma.coupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CouponUpdateArgs>(args: SelectSubset<T, CouponUpdateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Coupons.
     * @param {CouponDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CouponDeleteManyArgs>(args?: SelectSubset<T, CouponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CouponUpdateManyArgs>(args: SelectSubset<T, CouponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons and returns the data updated in the database.
     * @param {CouponUpdateManyAndReturnArgs} args - Arguments to update many Coupons.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CouponUpdateManyAndReturnArgs>(args: SelectSubset<T, CouponUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Coupon.
     * @param {CouponUpsertArgs} args - Arguments to update or create a Coupon.
     * @example
     * // Update or create a Coupon
     * const coupon = await prisma.coupon.upsert({
     *   create: {
     *     // ... data to create a Coupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupon we want to update
     *   }
     * })
     */
    upsert<T extends CouponUpsertArgs>(args: SelectSubset<T, CouponUpsertArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupon.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends CouponCountArgs>(
      args?: Subset<T, CouponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponAggregateArgs>(args: Subset<T, CouponAggregateArgs>): Prisma.PrismaPromise<GetCouponAggregateType<T>>

    /**
     * Group by Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponGroupByArgs['orderBy'] }
        : { orderBy?: CouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Coupon model
   */
  readonly fields: CouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cafe<T extends CafeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CafeDefaultArgs<ExtArgs>>): Prisma__CafeClient<$Result.GetResult<Prisma.$CafePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Coupon model
   */
  interface CouponFieldRefs {
    readonly id: FieldRef<"Coupon", 'Int'>
    readonly user_id: FieldRef<"Coupon", 'BigInt'>
    readonly cafe_id: FieldRef<"Coupon", 'BigInt'>
    readonly type: FieldRef<"Coupon", 'String'>
    readonly name: FieldRef<"Coupon", 'String'>
    readonly status: FieldRef<"Coupon", 'String'>
    readonly issued_at: FieldRef<"Coupon", 'DateTime'>
    readonly expired_at: FieldRef<"Coupon", 'DateTime'>
    readonly used_at: FieldRef<"Coupon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Coupon findUnique
   */
  export type CouponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findUniqueOrThrow
   */
  export type CouponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findFirst
   */
  export type CouponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findFirstOrThrow
   */
  export type CouponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findMany
   */
  export type CouponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupons to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon create
   */
  export type CouponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to create a Coupon.
     */
    data: XOR<CouponCreateInput, CouponUncheckedCreateInput>
  }

  /**
   * Coupon createMany
   */
  export type CouponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coupon createManyAndReturn
   */
  export type CouponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Coupon update
   */
  export type CouponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to update a Coupon.
     */
    data: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
    /**
     * Choose, which Coupon to update.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon updateMany
   */
  export type CouponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to update.
     */
    limit?: number
  }

  /**
   * Coupon updateManyAndReturn
   */
  export type CouponUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Coupon upsert
   */
  export type CouponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The filter to search for the Coupon to update in case it exists.
     */
    where: CouponWhereUniqueInput
    /**
     * In case the Coupon found by the `where` argument doesn't exist, create a new Coupon with this data.
     */
    create: XOR<CouponCreateInput, CouponUncheckedCreateInput>
    /**
     * In case the Coupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
  }

  /**
   * Coupon delete
   */
  export type CouponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter which Coupon to delete.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon deleteMany
   */
  export type CouponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupons to delete
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to delete.
     */
    limit?: number
  }

  /**
   * Coupon without action
   */
  export type CouponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    kakao_id: 'kakao_id',
    password_hash: 'password_hash',
    phone_number: 'phone_number',
    nickname: 'nickname',
    role: 'role',
    allow_kakao_alert: 'allow_kakao_alert',
    status: 'status',
    fcm_token: 'fcm_token',
    profile_image_url: 'profile_image_url',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const KakaoAccountScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    social_id: 'social_id',
    created_at: 'created_at'
  };

  export type KakaoAccountScalarFieldEnum = (typeof KakaoAccountScalarFieldEnum)[keyof typeof KakaoAccountScalarFieldEnum]


  export const UserPreferenceScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    preferred_area: 'preferred_area',
    preferred_keywords: 'preferred_keywords',
    created_at: 'created_at'
  };

  export type UserPreferenceScalarFieldEnum = (typeof UserPreferenceScalarFieldEnum)[keyof typeof UserPreferenceScalarFieldEnum]


  export const VerificationCodeScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    phone_number: 'phone_number',
    code: 'code',
    expires_at: 'expires_at',
    verified: 'verified',
    created_at: 'created_at'
  };

  export type VerificationCodeScalarFieldEnum = (typeof VerificationCodeScalarFieldEnum)[keyof typeof VerificationCodeScalarFieldEnum]


  export const UserAgreementScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    terms_agreed: 'terms_agreed',
    privacy_policy_agreed: 'privacy_policy_agreed',
    marketing_agreed: 'marketing_agreed',
    location_permission: 'location_permission',
    agreed_at: 'agreed_at'
  };

  export type UserAgreementScalarFieldEnum = (typeof UserAgreementScalarFieldEnum)[keyof typeof UserAgreementScalarFieldEnum]


  export const ChallengeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    thumbnail_url: 'thumbnail_url',
    start_date: 'start_date',
    end_date: 'end_date',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ChallengeScalarFieldEnum = (typeof ChallengeScalarFieldEnum)[keyof typeof ChallengeScalarFieldEnum]


  export const ChallengeParticipantScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    challenge_id: 'challenge_id',
    status: 'status',
    joined_at: 'joined_at',
    completed_at: 'completed_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ChallengeParticipantScalarFieldEnum = (typeof ChallengeParticipantScalarFieldEnum)[keyof typeof ChallengeParticipantScalarFieldEnum]


  export const ChallengeAvailableCafeScalarFieldEnum: {
    id: 'id',
    challenge_id: 'challenge_id',
    cafe_id: 'cafe_id',
    created_at: 'created_at'
  };

  export type ChallengeAvailableCafeScalarFieldEnum = (typeof ChallengeAvailableCafeScalarFieldEnum)[keyof typeof ChallengeAvailableCafeScalarFieldEnum]


  export const BadgeTypeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    image_url: 'image_url',
    created_at: 'created_at'
  };

  export type BadgeTypeScalarFieldEnum = (typeof BadgeTypeScalarFieldEnum)[keyof typeof BadgeTypeScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    challenge_id: 'challenge_id',
    badge_type_id: 'badge_type_id',
    earned_at: 'earned_at'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const StampBookScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    cafe_id: 'cafe_id',
    current_count: 'current_count',
    goal_count: 'goal_count',
    reward_detail: 'reward_detail',
    started_at: 'started_at',
    last_visited_at: 'last_visited_at',
    expires_at: 'expires_at',
    extended_at: 'extended_at',
    expired_at: 'expired_at',
    completed_at: 'completed_at',
    converted_at: 'converted_at',
    status: 'status',
    is_completed: 'is_completed',
    is_converted: 'is_converted',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type StampBookScalarFieldEnum = (typeof StampBookScalarFieldEnum)[keyof typeof StampBookScalarFieldEnum]


  export const StampScalarFieldEnum: {
    id: 'id',
    stamp_book_id: 'stamp_book_id',
    stamp_image_url: 'stamp_image_url',
    stamped_at: 'stamped_at',
    source: 'source',
    note: 'note',
    latitude: 'latitude',
    longitude: 'longitude'
  };

  export type StampScalarFieldEnum = (typeof StampScalarFieldEnum)[keyof typeof StampScalarFieldEnum]


  export const PointTransactionScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    stamp_book_id: 'stamp_book_id',
    point: 'point',
    type: 'type',
    description: 'description',
    created_at: 'created_at'
  };

  export type PointTransactionScalarFieldEnum = (typeof PointTransactionScalarFieldEnum)[keyof typeof PointTransactionScalarFieldEnum]


  export const CafeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    region: 'region',
    latitude: 'latitude',
    longitude: 'longitude',
    owner_name: 'owner_name',
    business_hours: 'business_hours',
    phone: 'phone',
    website_url: 'website_url',
    description: 'description',
    store_filters: 'store_filters',
    take_out_filters: 'take_out_filters',
    menu_filters: 'menu_filters',
    keywords: 'keywords',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CafeScalarFieldEnum = (typeof CafeScalarFieldEnum)[keyof typeof CafeScalarFieldEnum]


  export const CafeMenuScalarFieldEnum: {
    id: 'id',
    cafe_id: 'cafe_id',
    category: 'category',
    name: 'name',
    description: 'description',
    price: 'price',
    is_sold_out: 'is_sold_out',
    photo_url: 'photo_url',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CafeMenuScalarFieldEnum = (typeof CafeMenuScalarFieldEnum)[keyof typeof CafeMenuScalarFieldEnum]


  export const CafePhotoScalarFieldEnum: {
    id: 'id',
    cafe_id: 'cafe_id',
    photo_url: 'photo_url',
    display_order: 'display_order',
    created_at: 'created_at'
  };

  export type CafePhotoScalarFieldEnum = (typeof CafePhotoScalarFieldEnum)[keyof typeof CafePhotoScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    cafe_id: 'cafe_id',
    title: 'title',
    content: 'content',
    images: 'images',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    cafe_id: 'cafe_id',
    type: 'type',
    title: 'title',
    content: 'content',
    is_read: 'is_read',
    created_at: 'created_at'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const CouponScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    cafe_id: 'cafe_id',
    type: 'type',
    name: 'name',
    status: 'status',
    issued_at: 'issued_at',
    expired_at: 'expired_at',
    used_at: 'used_at'
  };

  export type CouponScalarFieldEnum = (typeof CouponScalarFieldEnum)[keyof typeof CouponScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'CafeStatus'
   */
  export type EnumCafeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CafeStatus'>
    


  /**
   * Reference to a field of type 'CafeStatus[]'
   */
  export type ListEnumCafeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CafeStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: BigIntFilter<"User"> | bigint | number
    email?: StringNullableFilter<"User"> | string | null
    kakao_id?: BigIntNullableFilter<"User"> | bigint | number | null
    password_hash?: StringNullableFilter<"User"> | string | null
    phone_number?: StringFilter<"User"> | string
    nickname?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    allow_kakao_alert?: BoolFilter<"User"> | boolean
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    fcm_token?: StringNullableFilter<"User"> | string | null
    profile_image_url?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    kakao_accounts?: KakaoAccountListRelationFilter
    user_agreements?: XOR<UserAgreementNullableScalarRelationFilter, UserAgreementWhereInput> | null
    user_preferences?: UserPreferenceListRelationFilter
    verification_codes?: VerificationCodeListRelationFilter
    challenge_participants?: ChallengeParticipantListRelationFilter
    badges?: BadgeListRelationFilter
    stamp_books?: StampBookListRelationFilter
    point_transactions?: PointTransactionListRelationFilter
    reviews?: ReviewListRelationFilter
    notifications?: NotificationListRelationFilter
    coupons?: CouponListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    kakao_id?: SortOrderInput | SortOrder
    password_hash?: SortOrderInput | SortOrder
    phone_number?: SortOrder
    nickname?: SortOrder
    role?: SortOrder
    allow_kakao_alert?: SortOrder
    status?: SortOrder
    fcm_token?: SortOrderInput | SortOrder
    profile_image_url?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    kakao_accounts?: KakaoAccountOrderByRelationAggregateInput
    user_agreements?: UserAgreementOrderByWithRelationInput
    user_preferences?: UserPreferenceOrderByRelationAggregateInput
    verification_codes?: VerificationCodeOrderByRelationAggregateInput
    challenge_participants?: ChallengeParticipantOrderByRelationAggregateInput
    badges?: BadgeOrderByRelationAggregateInput
    stamp_books?: StampBookOrderByRelationAggregateInput
    point_transactions?: PointTransactionOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    coupons?: CouponOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    email?: string
    phone_number?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    kakao_id?: BigIntNullableFilter<"User"> | bigint | number | null
    password_hash?: StringNullableFilter<"User"> | string | null
    nickname?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    allow_kakao_alert?: BoolFilter<"User"> | boolean
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    fcm_token?: StringNullableFilter<"User"> | string | null
    profile_image_url?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    kakao_accounts?: KakaoAccountListRelationFilter
    user_agreements?: XOR<UserAgreementNullableScalarRelationFilter, UserAgreementWhereInput> | null
    user_preferences?: UserPreferenceListRelationFilter
    verification_codes?: VerificationCodeListRelationFilter
    challenge_participants?: ChallengeParticipantListRelationFilter
    badges?: BadgeListRelationFilter
    stamp_books?: StampBookListRelationFilter
    point_transactions?: PointTransactionListRelationFilter
    reviews?: ReviewListRelationFilter
    notifications?: NotificationListRelationFilter
    coupons?: CouponListRelationFilter
  }, "id" | "email" | "phone_number">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    kakao_id?: SortOrderInput | SortOrder
    password_hash?: SortOrderInput | SortOrder
    phone_number?: SortOrder
    nickname?: SortOrder
    role?: SortOrder
    allow_kakao_alert?: SortOrder
    status?: SortOrder
    fcm_token?: SortOrderInput | SortOrder
    profile_image_url?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"User"> | bigint | number
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    kakao_id?: BigIntNullableWithAggregatesFilter<"User"> | bigint | number | null
    password_hash?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone_number?: StringWithAggregatesFilter<"User"> | string
    nickname?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    allow_kakao_alert?: BoolWithAggregatesFilter<"User"> | boolean
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    fcm_token?: StringNullableWithAggregatesFilter<"User"> | string | null
    profile_image_url?: StringNullableWithAggregatesFilter<"User"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type KakaoAccountWhereInput = {
    AND?: KakaoAccountWhereInput | KakaoAccountWhereInput[]
    OR?: KakaoAccountWhereInput[]
    NOT?: KakaoAccountWhereInput | KakaoAccountWhereInput[]
    id?: BigIntFilter<"KakaoAccount"> | bigint | number
    user_id?: BigIntFilter<"KakaoAccount"> | bigint | number
    social_id?: StringFilter<"KakaoAccount"> | string
    created_at?: DateTimeFilter<"KakaoAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type KakaoAccountOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    social_id?: SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type KakaoAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    user_id?: bigint | number
    AND?: KakaoAccountWhereInput | KakaoAccountWhereInput[]
    OR?: KakaoAccountWhereInput[]
    NOT?: KakaoAccountWhereInput | KakaoAccountWhereInput[]
    social_id?: StringFilter<"KakaoAccount"> | string
    created_at?: DateTimeFilter<"KakaoAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "user_id">

  export type KakaoAccountOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    social_id?: SortOrder
    created_at?: SortOrder
    _count?: KakaoAccountCountOrderByAggregateInput
    _avg?: KakaoAccountAvgOrderByAggregateInput
    _max?: KakaoAccountMaxOrderByAggregateInput
    _min?: KakaoAccountMinOrderByAggregateInput
    _sum?: KakaoAccountSumOrderByAggregateInput
  }

  export type KakaoAccountScalarWhereWithAggregatesInput = {
    AND?: KakaoAccountScalarWhereWithAggregatesInput | KakaoAccountScalarWhereWithAggregatesInput[]
    OR?: KakaoAccountScalarWhereWithAggregatesInput[]
    NOT?: KakaoAccountScalarWhereWithAggregatesInput | KakaoAccountScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"KakaoAccount"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"KakaoAccount"> | bigint | number
    social_id?: StringWithAggregatesFilter<"KakaoAccount"> | string
    created_at?: DateTimeWithAggregatesFilter<"KakaoAccount"> | Date | string
  }

  export type UserPreferenceWhereInput = {
    AND?: UserPreferenceWhereInput | UserPreferenceWhereInput[]
    OR?: UserPreferenceWhereInput[]
    NOT?: UserPreferenceWhereInput | UserPreferenceWhereInput[]
    id?: BigIntFilter<"UserPreference"> | bigint | number
    user_id?: BigIntFilter<"UserPreference"> | bigint | number
    preferred_area?: StringFilter<"UserPreference"> | string
    preferred_keywords?: JsonFilter<"UserPreference">
    created_at?: DateTimeFilter<"UserPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    preferred_area?: SortOrder
    preferred_keywords?: SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: UserPreferenceWhereInput | UserPreferenceWhereInput[]
    OR?: UserPreferenceWhereInput[]
    NOT?: UserPreferenceWhereInput | UserPreferenceWhereInput[]
    user_id?: BigIntFilter<"UserPreference"> | bigint | number
    preferred_area?: StringFilter<"UserPreference"> | string
    preferred_keywords?: JsonFilter<"UserPreference">
    created_at?: DateTimeFilter<"UserPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    preferred_area?: SortOrder
    preferred_keywords?: SortOrder
    created_at?: SortOrder
    _count?: UserPreferenceCountOrderByAggregateInput
    _avg?: UserPreferenceAvgOrderByAggregateInput
    _max?: UserPreferenceMaxOrderByAggregateInput
    _min?: UserPreferenceMinOrderByAggregateInput
    _sum?: UserPreferenceSumOrderByAggregateInput
  }

  export type UserPreferenceScalarWhereWithAggregatesInput = {
    AND?: UserPreferenceScalarWhereWithAggregatesInput | UserPreferenceScalarWhereWithAggregatesInput[]
    OR?: UserPreferenceScalarWhereWithAggregatesInput[]
    NOT?: UserPreferenceScalarWhereWithAggregatesInput | UserPreferenceScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"UserPreference"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"UserPreference"> | bigint | number
    preferred_area?: StringWithAggregatesFilter<"UserPreference"> | string
    preferred_keywords?: JsonWithAggregatesFilter<"UserPreference">
    created_at?: DateTimeWithAggregatesFilter<"UserPreference"> | Date | string
  }

  export type VerificationCodeWhereInput = {
    AND?: VerificationCodeWhereInput | VerificationCodeWhereInput[]
    OR?: VerificationCodeWhereInput[]
    NOT?: VerificationCodeWhereInput | VerificationCodeWhereInput[]
    id?: BigIntFilter<"VerificationCode"> | bigint | number
    user_id?: BigIntNullableFilter<"VerificationCode"> | bigint | number | null
    phone_number?: StringFilter<"VerificationCode"> | string
    code?: StringFilter<"VerificationCode"> | string
    expires_at?: DateTimeFilter<"VerificationCode"> | Date | string
    verified?: BoolFilter<"VerificationCode"> | boolean
    created_at?: DateTimeFilter<"VerificationCode"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type VerificationCodeOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    phone_number?: SortOrder
    code?: SortOrder
    expires_at?: SortOrder
    verified?: SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type VerificationCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: VerificationCodeWhereInput | VerificationCodeWhereInput[]
    OR?: VerificationCodeWhereInput[]
    NOT?: VerificationCodeWhereInput | VerificationCodeWhereInput[]
    user_id?: BigIntNullableFilter<"VerificationCode"> | bigint | number | null
    phone_number?: StringFilter<"VerificationCode"> | string
    code?: StringFilter<"VerificationCode"> | string
    expires_at?: DateTimeFilter<"VerificationCode"> | Date | string
    verified?: BoolFilter<"VerificationCode"> | boolean
    created_at?: DateTimeFilter<"VerificationCode"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type VerificationCodeOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    phone_number?: SortOrder
    code?: SortOrder
    expires_at?: SortOrder
    verified?: SortOrder
    created_at?: SortOrder
    _count?: VerificationCodeCountOrderByAggregateInput
    _avg?: VerificationCodeAvgOrderByAggregateInput
    _max?: VerificationCodeMaxOrderByAggregateInput
    _min?: VerificationCodeMinOrderByAggregateInput
    _sum?: VerificationCodeSumOrderByAggregateInput
  }

  export type VerificationCodeScalarWhereWithAggregatesInput = {
    AND?: VerificationCodeScalarWhereWithAggregatesInput | VerificationCodeScalarWhereWithAggregatesInput[]
    OR?: VerificationCodeScalarWhereWithAggregatesInput[]
    NOT?: VerificationCodeScalarWhereWithAggregatesInput | VerificationCodeScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"VerificationCode"> | bigint | number
    user_id?: BigIntNullableWithAggregatesFilter<"VerificationCode"> | bigint | number | null
    phone_number?: StringWithAggregatesFilter<"VerificationCode"> | string
    code?: StringWithAggregatesFilter<"VerificationCode"> | string
    expires_at?: DateTimeWithAggregatesFilter<"VerificationCode"> | Date | string
    verified?: BoolWithAggregatesFilter<"VerificationCode"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"VerificationCode"> | Date | string
  }

  export type UserAgreementWhereInput = {
    AND?: UserAgreementWhereInput | UserAgreementWhereInput[]
    OR?: UserAgreementWhereInput[]
    NOT?: UserAgreementWhereInput | UserAgreementWhereInput[]
    id?: BigIntFilter<"UserAgreement"> | bigint | number
    user_id?: BigIntFilter<"UserAgreement"> | bigint | number
    terms_agreed?: BoolFilter<"UserAgreement"> | boolean
    privacy_policy_agreed?: BoolFilter<"UserAgreement"> | boolean
    marketing_agreed?: BoolFilter<"UserAgreement"> | boolean
    location_permission?: BoolFilter<"UserAgreement"> | boolean
    agreed_at?: DateTimeFilter<"UserAgreement"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserAgreementOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    terms_agreed?: SortOrder
    privacy_policy_agreed?: SortOrder
    marketing_agreed?: SortOrder
    location_permission?: SortOrder
    agreed_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserAgreementWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    user_id?: bigint | number
    AND?: UserAgreementWhereInput | UserAgreementWhereInput[]
    OR?: UserAgreementWhereInput[]
    NOT?: UserAgreementWhereInput | UserAgreementWhereInput[]
    terms_agreed?: BoolFilter<"UserAgreement"> | boolean
    privacy_policy_agreed?: BoolFilter<"UserAgreement"> | boolean
    marketing_agreed?: BoolFilter<"UserAgreement"> | boolean
    location_permission?: BoolFilter<"UserAgreement"> | boolean
    agreed_at?: DateTimeFilter<"UserAgreement"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "user_id">

  export type UserAgreementOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    terms_agreed?: SortOrder
    privacy_policy_agreed?: SortOrder
    marketing_agreed?: SortOrder
    location_permission?: SortOrder
    agreed_at?: SortOrder
    _count?: UserAgreementCountOrderByAggregateInput
    _avg?: UserAgreementAvgOrderByAggregateInput
    _max?: UserAgreementMaxOrderByAggregateInput
    _min?: UserAgreementMinOrderByAggregateInput
    _sum?: UserAgreementSumOrderByAggregateInput
  }

  export type UserAgreementScalarWhereWithAggregatesInput = {
    AND?: UserAgreementScalarWhereWithAggregatesInput | UserAgreementScalarWhereWithAggregatesInput[]
    OR?: UserAgreementScalarWhereWithAggregatesInput[]
    NOT?: UserAgreementScalarWhereWithAggregatesInput | UserAgreementScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"UserAgreement"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"UserAgreement"> | bigint | number
    terms_agreed?: BoolWithAggregatesFilter<"UserAgreement"> | boolean
    privacy_policy_agreed?: BoolWithAggregatesFilter<"UserAgreement"> | boolean
    marketing_agreed?: BoolWithAggregatesFilter<"UserAgreement"> | boolean
    location_permission?: BoolWithAggregatesFilter<"UserAgreement"> | boolean
    agreed_at?: DateTimeWithAggregatesFilter<"UserAgreement"> | Date | string
  }

  export type ChallengeWhereInput = {
    AND?: ChallengeWhereInput | ChallengeWhereInput[]
    OR?: ChallengeWhereInput[]
    NOT?: ChallengeWhereInput | ChallengeWhereInput[]
    id?: IntFilter<"Challenge"> | number
    title?: StringFilter<"Challenge"> | string
    description?: StringFilter<"Challenge"> | string
    thumbnail_url?: StringFilter<"Challenge"> | string
    start_date?: DateTimeFilter<"Challenge"> | Date | string
    end_date?: DateTimeFilter<"Challenge"> | Date | string
    is_active?: BoolFilter<"Challenge"> | boolean
    created_at?: DateTimeFilter<"Challenge"> | Date | string
    updated_at?: DateTimeFilter<"Challenge"> | Date | string
    participants?: ChallengeParticipantListRelationFilter
    available_cafes?: ChallengeAvailableCafeListRelationFilter
    badges?: BadgeListRelationFilter
  }

  export type ChallengeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail_url?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    participants?: ChallengeParticipantOrderByRelationAggregateInput
    available_cafes?: ChallengeAvailableCafeOrderByRelationAggregateInput
    badges?: BadgeOrderByRelationAggregateInput
  }

  export type ChallengeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChallengeWhereInput | ChallengeWhereInput[]
    OR?: ChallengeWhereInput[]
    NOT?: ChallengeWhereInput | ChallengeWhereInput[]
    title?: StringFilter<"Challenge"> | string
    description?: StringFilter<"Challenge"> | string
    thumbnail_url?: StringFilter<"Challenge"> | string
    start_date?: DateTimeFilter<"Challenge"> | Date | string
    end_date?: DateTimeFilter<"Challenge"> | Date | string
    is_active?: BoolFilter<"Challenge"> | boolean
    created_at?: DateTimeFilter<"Challenge"> | Date | string
    updated_at?: DateTimeFilter<"Challenge"> | Date | string
    participants?: ChallengeParticipantListRelationFilter
    available_cafes?: ChallengeAvailableCafeListRelationFilter
    badges?: BadgeListRelationFilter
  }, "id">

  export type ChallengeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail_url?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ChallengeCountOrderByAggregateInput
    _avg?: ChallengeAvgOrderByAggregateInput
    _max?: ChallengeMaxOrderByAggregateInput
    _min?: ChallengeMinOrderByAggregateInput
    _sum?: ChallengeSumOrderByAggregateInput
  }

  export type ChallengeScalarWhereWithAggregatesInput = {
    AND?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[]
    OR?: ChallengeScalarWhereWithAggregatesInput[]
    NOT?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Challenge"> | number
    title?: StringWithAggregatesFilter<"Challenge"> | string
    description?: StringWithAggregatesFilter<"Challenge"> | string
    thumbnail_url?: StringWithAggregatesFilter<"Challenge"> | string
    start_date?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
    is_active?: BoolWithAggregatesFilter<"Challenge"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
  }

  export type ChallengeParticipantWhereInput = {
    AND?: ChallengeParticipantWhereInput | ChallengeParticipantWhereInput[]
    OR?: ChallengeParticipantWhereInput[]
    NOT?: ChallengeParticipantWhereInput | ChallengeParticipantWhereInput[]
    id?: IntFilter<"ChallengeParticipant"> | number
    user_id?: BigIntFilter<"ChallengeParticipant"> | bigint | number
    challenge_id?: IntFilter<"ChallengeParticipant"> | number
    status?: StringFilter<"ChallengeParticipant"> | string
    joined_at?: DateTimeFilter<"ChallengeParticipant"> | Date | string
    completed_at?: DateTimeFilter<"ChallengeParticipant"> | Date | string
    created_at?: DateTimeFilter<"ChallengeParticipant"> | Date | string
    updated_at?: DateTimeFilter<"ChallengeParticipant"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }

  export type ChallengeParticipantOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    status?: SortOrder
    joined_at?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    challenge?: ChallengeOrderByWithRelationInput
  }

  export type ChallengeParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChallengeParticipantWhereInput | ChallengeParticipantWhereInput[]
    OR?: ChallengeParticipantWhereInput[]
    NOT?: ChallengeParticipantWhereInput | ChallengeParticipantWhereInput[]
    user_id?: BigIntFilter<"ChallengeParticipant"> | bigint | number
    challenge_id?: IntFilter<"ChallengeParticipant"> | number
    status?: StringFilter<"ChallengeParticipant"> | string
    joined_at?: DateTimeFilter<"ChallengeParticipant"> | Date | string
    completed_at?: DateTimeFilter<"ChallengeParticipant"> | Date | string
    created_at?: DateTimeFilter<"ChallengeParticipant"> | Date | string
    updated_at?: DateTimeFilter<"ChallengeParticipant"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
  }, "id">

  export type ChallengeParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    status?: SortOrder
    joined_at?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ChallengeParticipantCountOrderByAggregateInput
    _avg?: ChallengeParticipantAvgOrderByAggregateInput
    _max?: ChallengeParticipantMaxOrderByAggregateInput
    _min?: ChallengeParticipantMinOrderByAggregateInput
    _sum?: ChallengeParticipantSumOrderByAggregateInput
  }

  export type ChallengeParticipantScalarWhereWithAggregatesInput = {
    AND?: ChallengeParticipantScalarWhereWithAggregatesInput | ChallengeParticipantScalarWhereWithAggregatesInput[]
    OR?: ChallengeParticipantScalarWhereWithAggregatesInput[]
    NOT?: ChallengeParticipantScalarWhereWithAggregatesInput | ChallengeParticipantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChallengeParticipant"> | number
    user_id?: BigIntWithAggregatesFilter<"ChallengeParticipant"> | bigint | number
    challenge_id?: IntWithAggregatesFilter<"ChallengeParticipant"> | number
    status?: StringWithAggregatesFilter<"ChallengeParticipant"> | string
    joined_at?: DateTimeWithAggregatesFilter<"ChallengeParticipant"> | Date | string
    completed_at?: DateTimeWithAggregatesFilter<"ChallengeParticipant"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"ChallengeParticipant"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ChallengeParticipant"> | Date | string
  }

  export type ChallengeAvailableCafeWhereInput = {
    AND?: ChallengeAvailableCafeWhereInput | ChallengeAvailableCafeWhereInput[]
    OR?: ChallengeAvailableCafeWhereInput[]
    NOT?: ChallengeAvailableCafeWhereInput | ChallengeAvailableCafeWhereInput[]
    id?: IntFilter<"ChallengeAvailableCafe"> | number
    challenge_id?: IntFilter<"ChallengeAvailableCafe"> | number
    cafe_id?: BigIntFilter<"ChallengeAvailableCafe"> | bigint | number
    created_at?: DateTimeFilter<"ChallengeAvailableCafe"> | Date | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
    cafe?: XOR<CafeScalarRelationFilter, CafeWhereInput>
  }

  export type ChallengeAvailableCafeOrderByWithRelationInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    cafe_id?: SortOrder
    created_at?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
    cafe?: CafeOrderByWithRelationInput
  }

  export type ChallengeAvailableCafeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChallengeAvailableCafeWhereInput | ChallengeAvailableCafeWhereInput[]
    OR?: ChallengeAvailableCafeWhereInput[]
    NOT?: ChallengeAvailableCafeWhereInput | ChallengeAvailableCafeWhereInput[]
    challenge_id?: IntFilter<"ChallengeAvailableCafe"> | number
    cafe_id?: BigIntFilter<"ChallengeAvailableCafe"> | bigint | number
    created_at?: DateTimeFilter<"ChallengeAvailableCafe"> | Date | string
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
    cafe?: XOR<CafeScalarRelationFilter, CafeWhereInput>
  }, "id">

  export type ChallengeAvailableCafeOrderByWithAggregationInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    cafe_id?: SortOrder
    created_at?: SortOrder
    _count?: ChallengeAvailableCafeCountOrderByAggregateInput
    _avg?: ChallengeAvailableCafeAvgOrderByAggregateInput
    _max?: ChallengeAvailableCafeMaxOrderByAggregateInput
    _min?: ChallengeAvailableCafeMinOrderByAggregateInput
    _sum?: ChallengeAvailableCafeSumOrderByAggregateInput
  }

  export type ChallengeAvailableCafeScalarWhereWithAggregatesInput = {
    AND?: ChallengeAvailableCafeScalarWhereWithAggregatesInput | ChallengeAvailableCafeScalarWhereWithAggregatesInput[]
    OR?: ChallengeAvailableCafeScalarWhereWithAggregatesInput[]
    NOT?: ChallengeAvailableCafeScalarWhereWithAggregatesInput | ChallengeAvailableCafeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChallengeAvailableCafe"> | number
    challenge_id?: IntWithAggregatesFilter<"ChallengeAvailableCafe"> | number
    cafe_id?: BigIntWithAggregatesFilter<"ChallengeAvailableCafe"> | bigint | number
    created_at?: DateTimeWithAggregatesFilter<"ChallengeAvailableCafe"> | Date | string
  }

  export type BadgeTypeWhereInput = {
    AND?: BadgeTypeWhereInput | BadgeTypeWhereInput[]
    OR?: BadgeTypeWhereInput[]
    NOT?: BadgeTypeWhereInput | BadgeTypeWhereInput[]
    id?: IntFilter<"BadgeType"> | number
    title?: StringFilter<"BadgeType"> | string
    image_url?: StringFilter<"BadgeType"> | string
    created_at?: DateTimeFilter<"BadgeType"> | Date | string
    badges?: BadgeListRelationFilter
  }

  export type BadgeTypeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    image_url?: SortOrder
    created_at?: SortOrder
    badges?: BadgeOrderByRelationAggregateInput
  }

  export type BadgeTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BadgeTypeWhereInput | BadgeTypeWhereInput[]
    OR?: BadgeTypeWhereInput[]
    NOT?: BadgeTypeWhereInput | BadgeTypeWhereInput[]
    title?: StringFilter<"BadgeType"> | string
    image_url?: StringFilter<"BadgeType"> | string
    created_at?: DateTimeFilter<"BadgeType"> | Date | string
    badges?: BadgeListRelationFilter
  }, "id">

  export type BadgeTypeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    image_url?: SortOrder
    created_at?: SortOrder
    _count?: BadgeTypeCountOrderByAggregateInput
    _avg?: BadgeTypeAvgOrderByAggregateInput
    _max?: BadgeTypeMaxOrderByAggregateInput
    _min?: BadgeTypeMinOrderByAggregateInput
    _sum?: BadgeTypeSumOrderByAggregateInput
  }

  export type BadgeTypeScalarWhereWithAggregatesInput = {
    AND?: BadgeTypeScalarWhereWithAggregatesInput | BadgeTypeScalarWhereWithAggregatesInput[]
    OR?: BadgeTypeScalarWhereWithAggregatesInput[]
    NOT?: BadgeTypeScalarWhereWithAggregatesInput | BadgeTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BadgeType"> | number
    title?: StringWithAggregatesFilter<"BadgeType"> | string
    image_url?: StringWithAggregatesFilter<"BadgeType"> | string
    created_at?: DateTimeWithAggregatesFilter<"BadgeType"> | Date | string
  }

  export type BadgeWhereInput = {
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    id?: IntFilter<"Badge"> | number
    user_id?: BigIntFilter<"Badge"> | bigint | number
    challenge_id?: IntFilter<"Badge"> | number
    badge_type_id?: IntFilter<"Badge"> | number
    earned_at?: DateTimeFilter<"Badge"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
    badge_type?: XOR<BadgeTypeScalarRelationFilter, BadgeTypeWhereInput>
  }

  export type BadgeOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    badge_type_id?: SortOrder
    earned_at?: SortOrder
    user?: UserOrderByWithRelationInput
    challenge?: ChallengeOrderByWithRelationInput
    badge_type?: BadgeTypeOrderByWithRelationInput
  }

  export type BadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    user_id?: BigIntFilter<"Badge"> | bigint | number
    challenge_id?: IntFilter<"Badge"> | number
    badge_type_id?: IntFilter<"Badge"> | number
    earned_at?: DateTimeFilter<"Badge"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    challenge?: XOR<ChallengeScalarRelationFilter, ChallengeWhereInput>
    badge_type?: XOR<BadgeTypeScalarRelationFilter, BadgeTypeWhereInput>
  }, "id">

  export type BadgeOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    badge_type_id?: SortOrder
    earned_at?: SortOrder
    _count?: BadgeCountOrderByAggregateInput
    _avg?: BadgeAvgOrderByAggregateInput
    _max?: BadgeMaxOrderByAggregateInput
    _min?: BadgeMinOrderByAggregateInput
    _sum?: BadgeSumOrderByAggregateInput
  }

  export type BadgeScalarWhereWithAggregatesInput = {
    AND?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    OR?: BadgeScalarWhereWithAggregatesInput[]
    NOT?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Badge"> | number
    user_id?: BigIntWithAggregatesFilter<"Badge"> | bigint | number
    challenge_id?: IntWithAggregatesFilter<"Badge"> | number
    badge_type_id?: IntWithAggregatesFilter<"Badge"> | number
    earned_at?: DateTimeWithAggregatesFilter<"Badge"> | Date | string
  }

  export type StampBookWhereInput = {
    AND?: StampBookWhereInput | StampBookWhereInput[]
    OR?: StampBookWhereInput[]
    NOT?: StampBookWhereInput | StampBookWhereInput[]
    id?: IntFilter<"StampBook"> | number
    user_id?: BigIntFilter<"StampBook"> | bigint | number
    cafe_id?: BigIntFilter<"StampBook"> | bigint | number
    current_count?: IntFilter<"StampBook"> | number
    goal_count?: IntFilter<"StampBook"> | number
    reward_detail?: StringFilter<"StampBook"> | string
    started_at?: DateTimeFilter<"StampBook"> | Date | string
    last_visited_at?: DateTimeFilter<"StampBook"> | Date | string
    expires_at?: DateTimeFilter<"StampBook"> | Date | string
    extended_at?: DateTimeFilter<"StampBook"> | Date | string
    expired_at?: DateTimeFilter<"StampBook"> | Date | string
    completed_at?: DateTimeFilter<"StampBook"> | Date | string
    converted_at?: DateTimeFilter<"StampBook"> | Date | string
    status?: StringFilter<"StampBook"> | string
    is_completed?: BoolFilter<"StampBook"> | boolean
    is_converted?: BoolFilter<"StampBook"> | boolean
    created_at?: DateTimeFilter<"StampBook"> | Date | string
    updated_at?: DateTimeFilter<"StampBook"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    cafe?: XOR<CafeScalarRelationFilter, CafeWhereInput>
    stamps?: StampListRelationFilter
    point_transactions?: PointTransactionListRelationFilter
  }

  export type StampBookOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    current_count?: SortOrder
    goal_count?: SortOrder
    reward_detail?: SortOrder
    started_at?: SortOrder
    last_visited_at?: SortOrder
    expires_at?: SortOrder
    extended_at?: SortOrder
    expired_at?: SortOrder
    completed_at?: SortOrder
    converted_at?: SortOrder
    status?: SortOrder
    is_completed?: SortOrder
    is_converted?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    cafe?: CafeOrderByWithRelationInput
    stamps?: StampOrderByRelationAggregateInput
    point_transactions?: PointTransactionOrderByRelationAggregateInput
  }

  export type StampBookWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StampBookWhereInput | StampBookWhereInput[]
    OR?: StampBookWhereInput[]
    NOT?: StampBookWhereInput | StampBookWhereInput[]
    user_id?: BigIntFilter<"StampBook"> | bigint | number
    cafe_id?: BigIntFilter<"StampBook"> | bigint | number
    current_count?: IntFilter<"StampBook"> | number
    goal_count?: IntFilter<"StampBook"> | number
    reward_detail?: StringFilter<"StampBook"> | string
    started_at?: DateTimeFilter<"StampBook"> | Date | string
    last_visited_at?: DateTimeFilter<"StampBook"> | Date | string
    expires_at?: DateTimeFilter<"StampBook"> | Date | string
    extended_at?: DateTimeFilter<"StampBook"> | Date | string
    expired_at?: DateTimeFilter<"StampBook"> | Date | string
    completed_at?: DateTimeFilter<"StampBook"> | Date | string
    converted_at?: DateTimeFilter<"StampBook"> | Date | string
    status?: StringFilter<"StampBook"> | string
    is_completed?: BoolFilter<"StampBook"> | boolean
    is_converted?: BoolFilter<"StampBook"> | boolean
    created_at?: DateTimeFilter<"StampBook"> | Date | string
    updated_at?: DateTimeFilter<"StampBook"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    cafe?: XOR<CafeScalarRelationFilter, CafeWhereInput>
    stamps?: StampListRelationFilter
    point_transactions?: PointTransactionListRelationFilter
  }, "id">

  export type StampBookOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    current_count?: SortOrder
    goal_count?: SortOrder
    reward_detail?: SortOrder
    started_at?: SortOrder
    last_visited_at?: SortOrder
    expires_at?: SortOrder
    extended_at?: SortOrder
    expired_at?: SortOrder
    completed_at?: SortOrder
    converted_at?: SortOrder
    status?: SortOrder
    is_completed?: SortOrder
    is_converted?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: StampBookCountOrderByAggregateInput
    _avg?: StampBookAvgOrderByAggregateInput
    _max?: StampBookMaxOrderByAggregateInput
    _min?: StampBookMinOrderByAggregateInput
    _sum?: StampBookSumOrderByAggregateInput
  }

  export type StampBookScalarWhereWithAggregatesInput = {
    AND?: StampBookScalarWhereWithAggregatesInput | StampBookScalarWhereWithAggregatesInput[]
    OR?: StampBookScalarWhereWithAggregatesInput[]
    NOT?: StampBookScalarWhereWithAggregatesInput | StampBookScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StampBook"> | number
    user_id?: BigIntWithAggregatesFilter<"StampBook"> | bigint | number
    cafe_id?: BigIntWithAggregatesFilter<"StampBook"> | bigint | number
    current_count?: IntWithAggregatesFilter<"StampBook"> | number
    goal_count?: IntWithAggregatesFilter<"StampBook"> | number
    reward_detail?: StringWithAggregatesFilter<"StampBook"> | string
    started_at?: DateTimeWithAggregatesFilter<"StampBook"> | Date | string
    last_visited_at?: DateTimeWithAggregatesFilter<"StampBook"> | Date | string
    expires_at?: DateTimeWithAggregatesFilter<"StampBook"> | Date | string
    extended_at?: DateTimeWithAggregatesFilter<"StampBook"> | Date | string
    expired_at?: DateTimeWithAggregatesFilter<"StampBook"> | Date | string
    completed_at?: DateTimeWithAggregatesFilter<"StampBook"> | Date | string
    converted_at?: DateTimeWithAggregatesFilter<"StampBook"> | Date | string
    status?: StringWithAggregatesFilter<"StampBook"> | string
    is_completed?: BoolWithAggregatesFilter<"StampBook"> | boolean
    is_converted?: BoolWithAggregatesFilter<"StampBook"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"StampBook"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"StampBook"> | Date | string
  }

  export type StampWhereInput = {
    AND?: StampWhereInput | StampWhereInput[]
    OR?: StampWhereInput[]
    NOT?: StampWhereInput | StampWhereInput[]
    id?: IntFilter<"Stamp"> | number
    stamp_book_id?: IntFilter<"Stamp"> | number
    stamp_image_url?: StringFilter<"Stamp"> | string
    stamped_at?: DateTimeFilter<"Stamp"> | Date | string
    source?: StringFilter<"Stamp"> | string
    note?: StringFilter<"Stamp"> | string
    latitude?: FloatFilter<"Stamp"> | number
    longitude?: FloatFilter<"Stamp"> | number
    stamp_book?: XOR<StampBookScalarRelationFilter, StampBookWhereInput>
  }

  export type StampOrderByWithRelationInput = {
    id?: SortOrder
    stamp_book_id?: SortOrder
    stamp_image_url?: SortOrder
    stamped_at?: SortOrder
    source?: SortOrder
    note?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    stamp_book?: StampBookOrderByWithRelationInput
  }

  export type StampWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StampWhereInput | StampWhereInput[]
    OR?: StampWhereInput[]
    NOT?: StampWhereInput | StampWhereInput[]
    stamp_book_id?: IntFilter<"Stamp"> | number
    stamp_image_url?: StringFilter<"Stamp"> | string
    stamped_at?: DateTimeFilter<"Stamp"> | Date | string
    source?: StringFilter<"Stamp"> | string
    note?: StringFilter<"Stamp"> | string
    latitude?: FloatFilter<"Stamp"> | number
    longitude?: FloatFilter<"Stamp"> | number
    stamp_book?: XOR<StampBookScalarRelationFilter, StampBookWhereInput>
  }, "id">

  export type StampOrderByWithAggregationInput = {
    id?: SortOrder
    stamp_book_id?: SortOrder
    stamp_image_url?: SortOrder
    stamped_at?: SortOrder
    source?: SortOrder
    note?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    _count?: StampCountOrderByAggregateInput
    _avg?: StampAvgOrderByAggregateInput
    _max?: StampMaxOrderByAggregateInput
    _min?: StampMinOrderByAggregateInput
    _sum?: StampSumOrderByAggregateInput
  }

  export type StampScalarWhereWithAggregatesInput = {
    AND?: StampScalarWhereWithAggregatesInput | StampScalarWhereWithAggregatesInput[]
    OR?: StampScalarWhereWithAggregatesInput[]
    NOT?: StampScalarWhereWithAggregatesInput | StampScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Stamp"> | number
    stamp_book_id?: IntWithAggregatesFilter<"Stamp"> | number
    stamp_image_url?: StringWithAggregatesFilter<"Stamp"> | string
    stamped_at?: DateTimeWithAggregatesFilter<"Stamp"> | Date | string
    source?: StringWithAggregatesFilter<"Stamp"> | string
    note?: StringWithAggregatesFilter<"Stamp"> | string
    latitude?: FloatWithAggregatesFilter<"Stamp"> | number
    longitude?: FloatWithAggregatesFilter<"Stamp"> | number
  }

  export type PointTransactionWhereInput = {
    AND?: PointTransactionWhereInput | PointTransactionWhereInput[]
    OR?: PointTransactionWhereInput[]
    NOT?: PointTransactionWhereInput | PointTransactionWhereInput[]
    id?: IntFilter<"PointTransaction"> | number
    user_id?: BigIntFilter<"PointTransaction"> | bigint | number
    stamp_book_id?: IntFilter<"PointTransaction"> | number
    point?: IntFilter<"PointTransaction"> | number
    type?: StringFilter<"PointTransaction"> | string
    description?: StringFilter<"PointTransaction"> | string
    created_at?: DateTimeFilter<"PointTransaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    stamp_book?: XOR<StampBookScalarRelationFilter, StampBookWhereInput>
  }

  export type PointTransactionOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    stamp_book_id?: SortOrder
    point?: SortOrder
    type?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
    stamp_book?: StampBookOrderByWithRelationInput
  }

  export type PointTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PointTransactionWhereInput | PointTransactionWhereInput[]
    OR?: PointTransactionWhereInput[]
    NOT?: PointTransactionWhereInput | PointTransactionWhereInput[]
    user_id?: BigIntFilter<"PointTransaction"> | bigint | number
    stamp_book_id?: IntFilter<"PointTransaction"> | number
    point?: IntFilter<"PointTransaction"> | number
    type?: StringFilter<"PointTransaction"> | string
    description?: StringFilter<"PointTransaction"> | string
    created_at?: DateTimeFilter<"PointTransaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    stamp_book?: XOR<StampBookScalarRelationFilter, StampBookWhereInput>
  }, "id">

  export type PointTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    stamp_book_id?: SortOrder
    point?: SortOrder
    type?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    _count?: PointTransactionCountOrderByAggregateInput
    _avg?: PointTransactionAvgOrderByAggregateInput
    _max?: PointTransactionMaxOrderByAggregateInput
    _min?: PointTransactionMinOrderByAggregateInput
    _sum?: PointTransactionSumOrderByAggregateInput
  }

  export type PointTransactionScalarWhereWithAggregatesInput = {
    AND?: PointTransactionScalarWhereWithAggregatesInput | PointTransactionScalarWhereWithAggregatesInput[]
    OR?: PointTransactionScalarWhereWithAggregatesInput[]
    NOT?: PointTransactionScalarWhereWithAggregatesInput | PointTransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PointTransaction"> | number
    user_id?: BigIntWithAggregatesFilter<"PointTransaction"> | bigint | number
    stamp_book_id?: IntWithAggregatesFilter<"PointTransaction"> | number
    point?: IntWithAggregatesFilter<"PointTransaction"> | number
    type?: StringWithAggregatesFilter<"PointTransaction"> | string
    description?: StringWithAggregatesFilter<"PointTransaction"> | string
    created_at?: DateTimeWithAggregatesFilter<"PointTransaction"> | Date | string
  }

  export type CafeWhereInput = {
    AND?: CafeWhereInput | CafeWhereInput[]
    OR?: CafeWhereInput[]
    NOT?: CafeWhereInput | CafeWhereInput[]
    id?: BigIntFilter<"Cafe"> | bigint | number
    name?: StringFilter<"Cafe"> | string
    address?: StringFilter<"Cafe"> | string
    region?: StringFilter<"Cafe"> | string
    latitude?: FloatFilter<"Cafe"> | number
    longitude?: FloatFilter<"Cafe"> | number
    owner_name?: StringFilter<"Cafe"> | string
    business_hours?: StringFilter<"Cafe"> | string
    phone?: StringFilter<"Cafe"> | string
    website_url?: StringFilter<"Cafe"> | string
    description?: StringFilter<"Cafe"> | string
    store_filters?: JsonFilter<"Cafe">
    take_out_filters?: JsonFilter<"Cafe">
    menu_filters?: JsonFilter<"Cafe">
    keywords?: JsonFilter<"Cafe">
    status?: EnumCafeStatusFilter<"Cafe"> | $Enums.CafeStatus
    created_at?: DateTimeFilter<"Cafe"> | Date | string
    updated_at?: DateTimeFilter<"Cafe"> | Date | string
    menu?: CafeMenuListRelationFilter
    photos?: CafePhotoListRelationFilter
    available_challenges?: ChallengeAvailableCafeListRelationFilter
    stamp_books?: StampBookListRelationFilter
    reviews?: ReviewListRelationFilter
    notifications?: NotificationListRelationFilter
    coupons?: CouponListRelationFilter
  }

  export type CafeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    owner_name?: SortOrder
    business_hours?: SortOrder
    phone?: SortOrder
    website_url?: SortOrder
    description?: SortOrder
    store_filters?: SortOrder
    take_out_filters?: SortOrder
    menu_filters?: SortOrder
    keywords?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    menu?: CafeMenuOrderByRelationAggregateInput
    photos?: CafePhotoOrderByRelationAggregateInput
    available_challenges?: ChallengeAvailableCafeOrderByRelationAggregateInput
    stamp_books?: StampBookOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    coupons?: CouponOrderByRelationAggregateInput
  }

  export type CafeWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: CafeWhereInput | CafeWhereInput[]
    OR?: CafeWhereInput[]
    NOT?: CafeWhereInput | CafeWhereInput[]
    name?: StringFilter<"Cafe"> | string
    address?: StringFilter<"Cafe"> | string
    region?: StringFilter<"Cafe"> | string
    latitude?: FloatFilter<"Cafe"> | number
    longitude?: FloatFilter<"Cafe"> | number
    owner_name?: StringFilter<"Cafe"> | string
    business_hours?: StringFilter<"Cafe"> | string
    phone?: StringFilter<"Cafe"> | string
    website_url?: StringFilter<"Cafe"> | string
    description?: StringFilter<"Cafe"> | string
    store_filters?: JsonFilter<"Cafe">
    take_out_filters?: JsonFilter<"Cafe">
    menu_filters?: JsonFilter<"Cafe">
    keywords?: JsonFilter<"Cafe">
    status?: EnumCafeStatusFilter<"Cafe"> | $Enums.CafeStatus
    created_at?: DateTimeFilter<"Cafe"> | Date | string
    updated_at?: DateTimeFilter<"Cafe"> | Date | string
    menu?: CafeMenuListRelationFilter
    photos?: CafePhotoListRelationFilter
    available_challenges?: ChallengeAvailableCafeListRelationFilter
    stamp_books?: StampBookListRelationFilter
    reviews?: ReviewListRelationFilter
    notifications?: NotificationListRelationFilter
    coupons?: CouponListRelationFilter
  }, "id">

  export type CafeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    owner_name?: SortOrder
    business_hours?: SortOrder
    phone?: SortOrder
    website_url?: SortOrder
    description?: SortOrder
    store_filters?: SortOrder
    take_out_filters?: SortOrder
    menu_filters?: SortOrder
    keywords?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CafeCountOrderByAggregateInput
    _avg?: CafeAvgOrderByAggregateInput
    _max?: CafeMaxOrderByAggregateInput
    _min?: CafeMinOrderByAggregateInput
    _sum?: CafeSumOrderByAggregateInput
  }

  export type CafeScalarWhereWithAggregatesInput = {
    AND?: CafeScalarWhereWithAggregatesInput | CafeScalarWhereWithAggregatesInput[]
    OR?: CafeScalarWhereWithAggregatesInput[]
    NOT?: CafeScalarWhereWithAggregatesInput | CafeScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Cafe"> | bigint | number
    name?: StringWithAggregatesFilter<"Cafe"> | string
    address?: StringWithAggregatesFilter<"Cafe"> | string
    region?: StringWithAggregatesFilter<"Cafe"> | string
    latitude?: FloatWithAggregatesFilter<"Cafe"> | number
    longitude?: FloatWithAggregatesFilter<"Cafe"> | number
    owner_name?: StringWithAggregatesFilter<"Cafe"> | string
    business_hours?: StringWithAggregatesFilter<"Cafe"> | string
    phone?: StringWithAggregatesFilter<"Cafe"> | string
    website_url?: StringWithAggregatesFilter<"Cafe"> | string
    description?: StringWithAggregatesFilter<"Cafe"> | string
    store_filters?: JsonWithAggregatesFilter<"Cafe">
    take_out_filters?: JsonWithAggregatesFilter<"Cafe">
    menu_filters?: JsonWithAggregatesFilter<"Cafe">
    keywords?: JsonWithAggregatesFilter<"Cafe">
    status?: EnumCafeStatusWithAggregatesFilter<"Cafe"> | $Enums.CafeStatus
    created_at?: DateTimeWithAggregatesFilter<"Cafe"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Cafe"> | Date | string
  }

  export type CafeMenuWhereInput = {
    AND?: CafeMenuWhereInput | CafeMenuWhereInput[]
    OR?: CafeMenuWhereInput[]
    NOT?: CafeMenuWhereInput | CafeMenuWhereInput[]
    id?: BigIntFilter<"CafeMenu"> | bigint | number
    cafe_id?: BigIntFilter<"CafeMenu"> | bigint | number
    category?: StringFilter<"CafeMenu"> | string
    name?: StringFilter<"CafeMenu"> | string
    description?: StringFilter<"CafeMenu"> | string
    price?: IntFilter<"CafeMenu"> | number
    is_sold_out?: BoolFilter<"CafeMenu"> | boolean
    photo_url?: StringFilter<"CafeMenu"> | string
    created_at?: DateTimeFilter<"CafeMenu"> | Date | string
    updated_at?: DateTimeFilter<"CafeMenu"> | Date | string
    cafe?: XOR<CafeScalarRelationFilter, CafeWhereInput>
  }

  export type CafeMenuOrderByWithRelationInput = {
    id?: SortOrder
    cafe_id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    is_sold_out?: SortOrder
    photo_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    cafe?: CafeOrderByWithRelationInput
  }

  export type CafeMenuWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: CafeMenuWhereInput | CafeMenuWhereInput[]
    OR?: CafeMenuWhereInput[]
    NOT?: CafeMenuWhereInput | CafeMenuWhereInput[]
    cafe_id?: BigIntFilter<"CafeMenu"> | bigint | number
    category?: StringFilter<"CafeMenu"> | string
    name?: StringFilter<"CafeMenu"> | string
    description?: StringFilter<"CafeMenu"> | string
    price?: IntFilter<"CafeMenu"> | number
    is_sold_out?: BoolFilter<"CafeMenu"> | boolean
    photo_url?: StringFilter<"CafeMenu"> | string
    created_at?: DateTimeFilter<"CafeMenu"> | Date | string
    updated_at?: DateTimeFilter<"CafeMenu"> | Date | string
    cafe?: XOR<CafeScalarRelationFilter, CafeWhereInput>
  }, "id">

  export type CafeMenuOrderByWithAggregationInput = {
    id?: SortOrder
    cafe_id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    is_sold_out?: SortOrder
    photo_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CafeMenuCountOrderByAggregateInput
    _avg?: CafeMenuAvgOrderByAggregateInput
    _max?: CafeMenuMaxOrderByAggregateInput
    _min?: CafeMenuMinOrderByAggregateInput
    _sum?: CafeMenuSumOrderByAggregateInput
  }

  export type CafeMenuScalarWhereWithAggregatesInput = {
    AND?: CafeMenuScalarWhereWithAggregatesInput | CafeMenuScalarWhereWithAggregatesInput[]
    OR?: CafeMenuScalarWhereWithAggregatesInput[]
    NOT?: CafeMenuScalarWhereWithAggregatesInput | CafeMenuScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"CafeMenu"> | bigint | number
    cafe_id?: BigIntWithAggregatesFilter<"CafeMenu"> | bigint | number
    category?: StringWithAggregatesFilter<"CafeMenu"> | string
    name?: StringWithAggregatesFilter<"CafeMenu"> | string
    description?: StringWithAggregatesFilter<"CafeMenu"> | string
    price?: IntWithAggregatesFilter<"CafeMenu"> | number
    is_sold_out?: BoolWithAggregatesFilter<"CafeMenu"> | boolean
    photo_url?: StringWithAggregatesFilter<"CafeMenu"> | string
    created_at?: DateTimeWithAggregatesFilter<"CafeMenu"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"CafeMenu"> | Date | string
  }

  export type CafePhotoWhereInput = {
    AND?: CafePhotoWhereInput | CafePhotoWhereInput[]
    OR?: CafePhotoWhereInput[]
    NOT?: CafePhotoWhereInput | CafePhotoWhereInput[]
    id?: BigIntFilter<"CafePhoto"> | bigint | number
    cafe_id?: BigIntFilter<"CafePhoto"> | bigint | number
    photo_url?: StringFilter<"CafePhoto"> | string
    display_order?: IntFilter<"CafePhoto"> | number
    created_at?: DateTimeFilter<"CafePhoto"> | Date | string
    cafe?: XOR<CafeScalarRelationFilter, CafeWhereInput>
  }

  export type CafePhotoOrderByWithRelationInput = {
    id?: SortOrder
    cafe_id?: SortOrder
    photo_url?: SortOrder
    display_order?: SortOrder
    created_at?: SortOrder
    cafe?: CafeOrderByWithRelationInput
  }

  export type CafePhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: CafePhotoWhereInput | CafePhotoWhereInput[]
    OR?: CafePhotoWhereInput[]
    NOT?: CafePhotoWhereInput | CafePhotoWhereInput[]
    cafe_id?: BigIntFilter<"CafePhoto"> | bigint | number
    photo_url?: StringFilter<"CafePhoto"> | string
    display_order?: IntFilter<"CafePhoto"> | number
    created_at?: DateTimeFilter<"CafePhoto"> | Date | string
    cafe?: XOR<CafeScalarRelationFilter, CafeWhereInput>
  }, "id">

  export type CafePhotoOrderByWithAggregationInput = {
    id?: SortOrder
    cafe_id?: SortOrder
    photo_url?: SortOrder
    display_order?: SortOrder
    created_at?: SortOrder
    _count?: CafePhotoCountOrderByAggregateInput
    _avg?: CafePhotoAvgOrderByAggregateInput
    _max?: CafePhotoMaxOrderByAggregateInput
    _min?: CafePhotoMinOrderByAggregateInput
    _sum?: CafePhotoSumOrderByAggregateInput
  }

  export type CafePhotoScalarWhereWithAggregatesInput = {
    AND?: CafePhotoScalarWhereWithAggregatesInput | CafePhotoScalarWhereWithAggregatesInput[]
    OR?: CafePhotoScalarWhereWithAggregatesInput[]
    NOT?: CafePhotoScalarWhereWithAggregatesInput | CafePhotoScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"CafePhoto"> | bigint | number
    cafe_id?: BigIntWithAggregatesFilter<"CafePhoto"> | bigint | number
    photo_url?: StringWithAggregatesFilter<"CafePhoto"> | string
    display_order?: IntWithAggregatesFilter<"CafePhoto"> | number
    created_at?: DateTimeWithAggregatesFilter<"CafePhoto"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: IntFilter<"Review"> | number
    user_id?: BigIntFilter<"Review"> | bigint | number
    cafe_id?: BigIntFilter<"Review"> | bigint | number
    title?: StringFilter<"Review"> | string
    content?: StringFilter<"Review"> | string
    images?: JsonFilter<"Review">
    created_at?: DateTimeFilter<"Review"> | Date | string
    updated_at?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    cafe?: XOR<CafeScalarRelationFilter, CafeWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    images?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    cafe?: CafeOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    user_id?: BigIntFilter<"Review"> | bigint | number
    cafe_id?: BigIntFilter<"Review"> | bigint | number
    title?: StringFilter<"Review"> | string
    content?: StringFilter<"Review"> | string
    images?: JsonFilter<"Review">
    created_at?: DateTimeFilter<"Review"> | Date | string
    updated_at?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    cafe?: XOR<CafeScalarRelationFilter, CafeWhereInput>
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    images?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Review"> | number
    user_id?: BigIntWithAggregatesFilter<"Review"> | bigint | number
    cafe_id?: BigIntWithAggregatesFilter<"Review"> | bigint | number
    title?: StringWithAggregatesFilter<"Review"> | string
    content?: StringWithAggregatesFilter<"Review"> | string
    images?: JsonWithAggregatesFilter<"Review">
    created_at?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    user_id?: BigIntFilter<"Notification"> | bigint | number
    cafe_id?: BigIntFilter<"Notification"> | bigint | number
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    is_read?: BoolFilter<"Notification"> | boolean
    created_at?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    cafe?: XOR<CafeScalarRelationFilter, CafeWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    is_read?: SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
    cafe?: CafeOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    user_id?: BigIntFilter<"Notification"> | bigint | number
    cafe_id?: BigIntFilter<"Notification"> | bigint | number
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    is_read?: BoolFilter<"Notification"> | boolean
    created_at?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    cafe?: XOR<CafeScalarRelationFilter, CafeWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    is_read?: SortOrder
    created_at?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    user_id?: BigIntWithAggregatesFilter<"Notification"> | bigint | number
    cafe_id?: BigIntWithAggregatesFilter<"Notification"> | bigint | number
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    content?: StringWithAggregatesFilter<"Notification"> | string
    is_read?: BoolWithAggregatesFilter<"Notification"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type CouponWhereInput = {
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    id?: IntFilter<"Coupon"> | number
    user_id?: BigIntFilter<"Coupon"> | bigint | number
    cafe_id?: BigIntFilter<"Coupon"> | bigint | number
    type?: StringFilter<"Coupon"> | string
    name?: StringFilter<"Coupon"> | string
    status?: StringFilter<"Coupon"> | string
    issued_at?: DateTimeFilter<"Coupon"> | Date | string
    expired_at?: DateTimeFilter<"Coupon"> | Date | string
    used_at?: DateTimeFilter<"Coupon"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    cafe?: XOR<CafeScalarRelationFilter, CafeWhereInput>
  }

  export type CouponOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    status?: SortOrder
    issued_at?: SortOrder
    expired_at?: SortOrder
    used_at?: SortOrder
    user?: UserOrderByWithRelationInput
    cafe?: CafeOrderByWithRelationInput
  }

  export type CouponWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    user_id?: BigIntFilter<"Coupon"> | bigint | number
    cafe_id?: BigIntFilter<"Coupon"> | bigint | number
    type?: StringFilter<"Coupon"> | string
    name?: StringFilter<"Coupon"> | string
    status?: StringFilter<"Coupon"> | string
    issued_at?: DateTimeFilter<"Coupon"> | Date | string
    expired_at?: DateTimeFilter<"Coupon"> | Date | string
    used_at?: DateTimeFilter<"Coupon"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    cafe?: XOR<CafeScalarRelationFilter, CafeWhereInput>
  }, "id">

  export type CouponOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    status?: SortOrder
    issued_at?: SortOrder
    expired_at?: SortOrder
    used_at?: SortOrder
    _count?: CouponCountOrderByAggregateInput
    _avg?: CouponAvgOrderByAggregateInput
    _max?: CouponMaxOrderByAggregateInput
    _min?: CouponMinOrderByAggregateInput
    _sum?: CouponSumOrderByAggregateInput
  }

  export type CouponScalarWhereWithAggregatesInput = {
    AND?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    OR?: CouponScalarWhereWithAggregatesInput[]
    NOT?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Coupon"> | number
    user_id?: BigIntWithAggregatesFilter<"Coupon"> | bigint | number
    cafe_id?: BigIntWithAggregatesFilter<"Coupon"> | bigint | number
    type?: StringWithAggregatesFilter<"Coupon"> | string
    name?: StringWithAggregatesFilter<"Coupon"> | string
    status?: StringWithAggregatesFilter<"Coupon"> | string
    issued_at?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
    expired_at?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
    used_at?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
  }

  export type UserCreateInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountCreateNestedManyWithoutUserInput
    user_agreements?: UserAgreementCreateNestedOneWithoutUserInput
    user_preferences?: UserPreferenceCreateNestedManyWithoutUserInput
    verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    stamp_books?: StampBookCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    coupons?: CouponCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountUncheckedCreateNestedManyWithoutUserInput
    user_agreements?: UserAgreementUncheckedCreateNestedOneWithoutUserInput
    user_preferences?: UserPreferenceUncheckedCreateNestedManyWithoutUserInput
    verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    stamp_books?: StampBookUncheckedCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    coupons?: CouponUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUpdateManyWithoutUserNestedInput
    user_agreements?: UserAgreementUpdateOneWithoutUserNestedInput
    user_preferences?: UserPreferenceUpdateManyWithoutUserNestedInput
    verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    coupons?: CouponUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUncheckedUpdateManyWithoutUserNestedInput
    user_agreements?: UserAgreementUncheckedUpdateOneWithoutUserNestedInput
    user_preferences?: UserPreferenceUncheckedUpdateManyWithoutUserNestedInput
    verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUncheckedUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KakaoAccountCreateInput = {
    id?: bigint | number
    social_id: string
    created_at?: Date | string
    user: UserCreateNestedOneWithoutKakao_accountsInput
  }

  export type KakaoAccountUncheckedCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    social_id: string
    created_at?: Date | string
  }

  export type KakaoAccountUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    social_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutKakao_accountsNestedInput
  }

  export type KakaoAccountUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    social_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KakaoAccountCreateManyInput = {
    id?: bigint | number
    user_id: bigint | number
    social_id: string
    created_at?: Date | string
  }

  export type KakaoAccountUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    social_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KakaoAccountUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    social_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferenceCreateInput = {
    id?: bigint | number
    preferred_area: string
    preferred_keywords: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    user: UserCreateNestedOneWithoutUser_preferencesInput
  }

  export type UserPreferenceUncheckedCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    preferred_area: string
    preferred_keywords: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type UserPreferenceUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_area?: StringFieldUpdateOperationsInput | string
    preferred_keywords?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUser_preferencesNestedInput
  }

  export type UserPreferenceUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_area?: StringFieldUpdateOperationsInput | string
    preferred_keywords?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferenceCreateManyInput = {
    id?: bigint | number
    user_id: bigint | number
    preferred_area: string
    preferred_keywords: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type UserPreferenceUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_area?: StringFieldUpdateOperationsInput | string
    preferred_keywords?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferenceUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_area?: StringFieldUpdateOperationsInput | string
    preferred_keywords?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCodeCreateInput = {
    id?: bigint | number
    phone_number: string
    code: string
    expires_at: Date | string
    verified: boolean
    created_at?: Date | string
    user?: UserCreateNestedOneWithoutVerification_codesInput
  }

  export type VerificationCodeUncheckedCreateInput = {
    id?: bigint | number
    user_id?: bigint | number | null
    phone_number: string
    code: string
    expires_at: Date | string
    verified: boolean
    created_at?: Date | string
  }

  export type VerificationCodeUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone_number?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutVerification_codesNestedInput
  }

  export type VerificationCodeUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    phone_number?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCodeCreateManyInput = {
    id?: bigint | number
    user_id?: bigint | number | null
    phone_number: string
    code: string
    expires_at: Date | string
    verified: boolean
    created_at?: Date | string
  }

  export type VerificationCodeUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone_number?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCodeUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    phone_number?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAgreementCreateInput = {
    id?: bigint | number
    terms_agreed: boolean
    privacy_policy_agreed: boolean
    marketing_agreed: boolean
    location_permission: boolean
    agreed_at?: Date | string
    user: UserCreateNestedOneWithoutUser_agreementsInput
  }

  export type UserAgreementUncheckedCreateInput = {
    id?: bigint | number
    user_id: bigint | number
    terms_agreed: boolean
    privacy_policy_agreed: boolean
    marketing_agreed: boolean
    location_permission: boolean
    agreed_at?: Date | string
  }

  export type UserAgreementUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    terms_agreed?: BoolFieldUpdateOperationsInput | boolean
    privacy_policy_agreed?: BoolFieldUpdateOperationsInput | boolean
    marketing_agreed?: BoolFieldUpdateOperationsInput | boolean
    location_permission?: BoolFieldUpdateOperationsInput | boolean
    agreed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUser_agreementsNestedInput
  }

  export type UserAgreementUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    terms_agreed?: BoolFieldUpdateOperationsInput | boolean
    privacy_policy_agreed?: BoolFieldUpdateOperationsInput | boolean
    marketing_agreed?: BoolFieldUpdateOperationsInput | boolean
    location_permission?: BoolFieldUpdateOperationsInput | boolean
    agreed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAgreementCreateManyInput = {
    id?: bigint | number
    user_id: bigint | number
    terms_agreed: boolean
    privacy_policy_agreed: boolean
    marketing_agreed: boolean
    location_permission: boolean
    agreed_at?: Date | string
  }

  export type UserAgreementUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    terms_agreed?: BoolFieldUpdateOperationsInput | boolean
    privacy_policy_agreed?: BoolFieldUpdateOperationsInput | boolean
    marketing_agreed?: BoolFieldUpdateOperationsInput | boolean
    location_permission?: BoolFieldUpdateOperationsInput | boolean
    agreed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAgreementUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    terms_agreed?: BoolFieldUpdateOperationsInput | boolean
    privacy_policy_agreed?: BoolFieldUpdateOperationsInput | boolean
    marketing_agreed?: BoolFieldUpdateOperationsInput | boolean
    location_permission?: BoolFieldUpdateOperationsInput | boolean
    agreed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeCreateInput = {
    title: string
    description: string
    thumbnail_url: string
    start_date: Date | string
    end_date: Date | string
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    participants?: ChallengeParticipantCreateNestedManyWithoutChallengeInput
    available_cafes?: ChallengeAvailableCafeCreateNestedManyWithoutChallengeInput
    badges?: BadgeCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    thumbnail_url: string
    start_date: Date | string
    end_date: Date | string
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    participants?: ChallengeParticipantUncheckedCreateNestedManyWithoutChallengeInput
    available_cafes?: ChallengeAvailableCafeUncheckedCreateNestedManyWithoutChallengeInput
    badges?: BadgeUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail_url?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ChallengeParticipantUpdateManyWithoutChallengeNestedInput
    available_cafes?: ChallengeAvailableCafeUpdateManyWithoutChallengeNestedInput
    badges?: BadgeUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail_url?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ChallengeParticipantUncheckedUpdateManyWithoutChallengeNestedInput
    available_cafes?: ChallengeAvailableCafeUncheckedUpdateManyWithoutChallengeNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateManyInput = {
    id?: number
    title: string
    description: string
    thumbnail_url: string
    start_date: Date | string
    end_date: Date | string
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChallengeUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail_url?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail_url?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeParticipantCreateInput = {
    status: string
    joined_at: Date | string
    completed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutChallenge_participantsInput
    challenge: ChallengeCreateNestedOneWithoutParticipantsInput
  }

  export type ChallengeParticipantUncheckedCreateInput = {
    id?: number
    user_id: bigint | number
    challenge_id: number
    status: string
    joined_at: Date | string
    completed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChallengeParticipantUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChallenge_participantsNestedInput
    challenge?: ChallengeUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ChallengeParticipantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    challenge_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeParticipantCreateManyInput = {
    id?: number
    user_id: bigint | number
    challenge_id: number
    status: string
    joined_at: Date | string
    completed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChallengeParticipantUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeParticipantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    challenge_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeAvailableCafeCreateInput = {
    created_at?: Date | string
    challenge: ChallengeCreateNestedOneWithoutAvailable_cafesInput
    cafe: CafeCreateNestedOneWithoutAvailable_challengesInput
  }

  export type ChallengeAvailableCafeUncheckedCreateInput = {
    id?: number
    challenge_id: number
    cafe_id: bigint | number
    created_at?: Date | string
  }

  export type ChallengeAvailableCafeUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    challenge?: ChallengeUpdateOneRequiredWithoutAvailable_cafesNestedInput
    cafe?: CafeUpdateOneRequiredWithoutAvailable_challengesNestedInput
  }

  export type ChallengeAvailableCafeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    challenge_id?: IntFieldUpdateOperationsInput | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeAvailableCafeCreateManyInput = {
    id?: number
    challenge_id: number
    cafe_id: bigint | number
    created_at?: Date | string
  }

  export type ChallengeAvailableCafeUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeAvailableCafeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    challenge_id?: IntFieldUpdateOperationsInput | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeTypeCreateInput = {
    title: string
    image_url: string
    created_at?: Date | string
    badges?: BadgeCreateNestedManyWithoutBadge_typeInput
  }

  export type BadgeTypeUncheckedCreateInput = {
    id?: number
    title: string
    image_url: string
    created_at?: Date | string
    badges?: BadgeUncheckedCreateNestedManyWithoutBadge_typeInput
  }

  export type BadgeTypeUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    badges?: BadgeUpdateManyWithoutBadge_typeNestedInput
  }

  export type BadgeTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    badges?: BadgeUncheckedUpdateManyWithoutBadge_typeNestedInput
  }

  export type BadgeTypeCreateManyInput = {
    id?: number
    title: string
    image_url: string
    created_at?: Date | string
  }

  export type BadgeTypeUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeCreateInput = {
    earned_at?: Date | string
    user: UserCreateNestedOneWithoutBadgesInput
    challenge: ChallengeCreateNestedOneWithoutBadgesInput
    badge_type: BadgeTypeCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateInput = {
    id?: number
    user_id: bigint | number
    challenge_id: number
    badge_type_id: number
    earned_at?: Date | string
  }

  export type BadgeUpdateInput = {
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBadgesNestedInput
    challenge?: ChallengeUpdateOneRequiredWithoutBadgesNestedInput
    badge_type?: BadgeTypeUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type BadgeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    challenge_id?: IntFieldUpdateOperationsInput | number
    badge_type_id?: IntFieldUpdateOperationsInput | number
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeCreateManyInput = {
    id?: number
    user_id: bigint | number
    challenge_id: number
    badge_type_id: number
    earned_at?: Date | string
  }

  export type BadgeUpdateManyMutationInput = {
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    challenge_id?: IntFieldUpdateOperationsInput | number
    badge_type_id?: IntFieldUpdateOperationsInput | number
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StampBookCreateInput = {
    current_count: number
    goal_count: number
    reward_detail: string
    started_at: Date | string
    last_visited_at: Date | string
    expires_at: Date | string
    extended_at: Date | string
    expired_at: Date | string
    completed_at: Date | string
    converted_at: Date | string
    status: string
    is_completed: boolean
    is_converted: boolean
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutStamp_booksInput
    cafe: CafeCreateNestedOneWithoutStamp_booksInput
    stamps?: StampCreateNestedManyWithoutStamp_bookInput
    point_transactions?: PointTransactionCreateNestedManyWithoutStamp_bookInput
  }

  export type StampBookUncheckedCreateInput = {
    id?: number
    user_id: bigint | number
    cafe_id: bigint | number
    current_count: number
    goal_count: number
    reward_detail: string
    started_at: Date | string
    last_visited_at: Date | string
    expires_at: Date | string
    extended_at: Date | string
    expired_at: Date | string
    completed_at: Date | string
    converted_at: Date | string
    status: string
    is_completed: boolean
    is_converted: boolean
    created_at?: Date | string
    updated_at?: Date | string
    stamps?: StampUncheckedCreateNestedManyWithoutStamp_bookInput
    point_transactions?: PointTransactionUncheckedCreateNestedManyWithoutStamp_bookInput
  }

  export type StampBookUpdateInput = {
    current_count?: IntFieldUpdateOperationsInput | number
    goal_count?: IntFieldUpdateOperationsInput | number
    reward_detail?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_visited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    extended_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    converted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    is_converted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStamp_booksNestedInput
    cafe?: CafeUpdateOneRequiredWithoutStamp_booksNestedInput
    stamps?: StampUpdateManyWithoutStamp_bookNestedInput
    point_transactions?: PointTransactionUpdateManyWithoutStamp_bookNestedInput
  }

  export type StampBookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    current_count?: IntFieldUpdateOperationsInput | number
    goal_count?: IntFieldUpdateOperationsInput | number
    reward_detail?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_visited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    extended_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    converted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    is_converted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stamps?: StampUncheckedUpdateManyWithoutStamp_bookNestedInput
    point_transactions?: PointTransactionUncheckedUpdateManyWithoutStamp_bookNestedInput
  }

  export type StampBookCreateManyInput = {
    id?: number
    user_id: bigint | number
    cafe_id: bigint | number
    current_count: number
    goal_count: number
    reward_detail: string
    started_at: Date | string
    last_visited_at: Date | string
    expires_at: Date | string
    extended_at: Date | string
    expired_at: Date | string
    completed_at: Date | string
    converted_at: Date | string
    status: string
    is_completed: boolean
    is_converted: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StampBookUpdateManyMutationInput = {
    current_count?: IntFieldUpdateOperationsInput | number
    goal_count?: IntFieldUpdateOperationsInput | number
    reward_detail?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_visited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    extended_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    converted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    is_converted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StampBookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    current_count?: IntFieldUpdateOperationsInput | number
    goal_count?: IntFieldUpdateOperationsInput | number
    reward_detail?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_visited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    extended_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    converted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    is_converted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StampCreateInput = {
    stamp_image_url: string
    stamped_at?: Date | string
    source: string
    note: string
    latitude: number
    longitude: number
    stamp_book: StampBookCreateNestedOneWithoutStampsInput
  }

  export type StampUncheckedCreateInput = {
    id?: number
    stamp_book_id: number
    stamp_image_url: string
    stamped_at?: Date | string
    source: string
    note: string
    latitude: number
    longitude: number
  }

  export type StampUpdateInput = {
    stamp_image_url?: StringFieldUpdateOperationsInput | string
    stamped_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    stamp_book?: StampBookUpdateOneRequiredWithoutStampsNestedInput
  }

  export type StampUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    stamp_book_id?: IntFieldUpdateOperationsInput | number
    stamp_image_url?: StringFieldUpdateOperationsInput | string
    stamped_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type StampCreateManyInput = {
    id?: number
    stamp_book_id: number
    stamp_image_url: string
    stamped_at?: Date | string
    source: string
    note: string
    latitude: number
    longitude: number
  }

  export type StampUpdateManyMutationInput = {
    stamp_image_url?: StringFieldUpdateOperationsInput | string
    stamped_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type StampUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    stamp_book_id?: IntFieldUpdateOperationsInput | number
    stamp_image_url?: StringFieldUpdateOperationsInput | string
    stamped_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type PointTransactionCreateInput = {
    point: number
    type: string
    description: string
    created_at?: Date | string
    user: UserCreateNestedOneWithoutPoint_transactionsInput
    stamp_book: StampBookCreateNestedOneWithoutPoint_transactionsInput
  }

  export type PointTransactionUncheckedCreateInput = {
    id?: number
    user_id: bigint | number
    stamp_book_id: number
    point: number
    type: string
    description: string
    created_at?: Date | string
  }

  export type PointTransactionUpdateInput = {
    point?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPoint_transactionsNestedInput
    stamp_book?: StampBookUpdateOneRequiredWithoutPoint_transactionsNestedInput
  }

  export type PointTransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    stamp_book_id?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointTransactionCreateManyInput = {
    id?: number
    user_id: bigint | number
    stamp_book_id: number
    point: number
    type: string
    description: string
    created_at?: Date | string
  }

  export type PointTransactionUpdateManyMutationInput = {
    point?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointTransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    stamp_book_id?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeCreateInput = {
    id?: bigint | number
    name: string
    address: string
    region: string
    latitude: number
    longitude: number
    owner_name: string
    business_hours: string
    phone: string
    website_url: string
    description: string
    store_filters: JsonNullValueInput | InputJsonValue
    take_out_filters: JsonNullValueInput | InputJsonValue
    menu_filters: JsonNullValueInput | InputJsonValue
    keywords: JsonNullValueInput | InputJsonValue
    status: $Enums.CafeStatus
    created_at?: Date | string
    updated_at?: Date | string
    menu?: CafeMenuCreateNestedManyWithoutCafeInput
    photos?: CafePhotoCreateNestedManyWithoutCafeInput
    available_challenges?: ChallengeAvailableCafeCreateNestedManyWithoutCafeInput
    stamp_books?: StampBookCreateNestedManyWithoutCafeInput
    reviews?: ReviewCreateNestedManyWithoutCafeInput
    notifications?: NotificationCreateNestedManyWithoutCafeInput
    coupons?: CouponCreateNestedManyWithoutCafeInput
  }

  export type CafeUncheckedCreateInput = {
    id?: bigint | number
    name: string
    address: string
    region: string
    latitude: number
    longitude: number
    owner_name: string
    business_hours: string
    phone: string
    website_url: string
    description: string
    store_filters: JsonNullValueInput | InputJsonValue
    take_out_filters: JsonNullValueInput | InputJsonValue
    menu_filters: JsonNullValueInput | InputJsonValue
    keywords: JsonNullValueInput | InputJsonValue
    status: $Enums.CafeStatus
    created_at?: Date | string
    updated_at?: Date | string
    menu?: CafeMenuUncheckedCreateNestedManyWithoutCafeInput
    photos?: CafePhotoUncheckedCreateNestedManyWithoutCafeInput
    available_challenges?: ChallengeAvailableCafeUncheckedCreateNestedManyWithoutCafeInput
    stamp_books?: StampBookUncheckedCreateNestedManyWithoutCafeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCafeInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCafeInput
    coupons?: CouponUncheckedCreateNestedManyWithoutCafeInput
  }

  export type CafeUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner_name?: StringFieldUpdateOperationsInput | string
    business_hours?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    store_filters?: JsonNullValueInput | InputJsonValue
    take_out_filters?: JsonNullValueInput | InputJsonValue
    menu_filters?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    status?: EnumCafeStatusFieldUpdateOperationsInput | $Enums.CafeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: CafeMenuUpdateManyWithoutCafeNestedInput
    photos?: CafePhotoUpdateManyWithoutCafeNestedInput
    available_challenges?: ChallengeAvailableCafeUpdateManyWithoutCafeNestedInput
    stamp_books?: StampBookUpdateManyWithoutCafeNestedInput
    reviews?: ReviewUpdateManyWithoutCafeNestedInput
    notifications?: NotificationUpdateManyWithoutCafeNestedInput
    coupons?: CouponUpdateManyWithoutCafeNestedInput
  }

  export type CafeUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner_name?: StringFieldUpdateOperationsInput | string
    business_hours?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    store_filters?: JsonNullValueInput | InputJsonValue
    take_out_filters?: JsonNullValueInput | InputJsonValue
    menu_filters?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    status?: EnumCafeStatusFieldUpdateOperationsInput | $Enums.CafeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: CafeMenuUncheckedUpdateManyWithoutCafeNestedInput
    photos?: CafePhotoUncheckedUpdateManyWithoutCafeNestedInput
    available_challenges?: ChallengeAvailableCafeUncheckedUpdateManyWithoutCafeNestedInput
    stamp_books?: StampBookUncheckedUpdateManyWithoutCafeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCafeNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCafeNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutCafeNestedInput
  }

  export type CafeCreateManyInput = {
    id?: bigint | number
    name: string
    address: string
    region: string
    latitude: number
    longitude: number
    owner_name: string
    business_hours: string
    phone: string
    website_url: string
    description: string
    store_filters: JsonNullValueInput | InputJsonValue
    take_out_filters: JsonNullValueInput | InputJsonValue
    menu_filters: JsonNullValueInput | InputJsonValue
    keywords: JsonNullValueInput | InputJsonValue
    status: $Enums.CafeStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CafeUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner_name?: StringFieldUpdateOperationsInput | string
    business_hours?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    store_filters?: JsonNullValueInput | InputJsonValue
    take_out_filters?: JsonNullValueInput | InputJsonValue
    menu_filters?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    status?: EnumCafeStatusFieldUpdateOperationsInput | $Enums.CafeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner_name?: StringFieldUpdateOperationsInput | string
    business_hours?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    store_filters?: JsonNullValueInput | InputJsonValue
    take_out_filters?: JsonNullValueInput | InputJsonValue
    menu_filters?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    status?: EnumCafeStatusFieldUpdateOperationsInput | $Enums.CafeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeMenuCreateInput = {
    id?: bigint | number
    category: string
    name: string
    description: string
    price: number
    is_sold_out: boolean
    photo_url: string
    created_at?: Date | string
    updated_at?: Date | string
    cafe: CafeCreateNestedOneWithoutMenuInput
  }

  export type CafeMenuUncheckedCreateInput = {
    id?: bigint | number
    cafe_id: bigint | number
    category: string
    name: string
    description: string
    price: number
    is_sold_out: boolean
    photo_url: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CafeMenuUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    is_sold_out?: BoolFieldUpdateOperationsInput | boolean
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cafe?: CafeUpdateOneRequiredWithoutMenuNestedInput
  }

  export type CafeMenuUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    is_sold_out?: BoolFieldUpdateOperationsInput | boolean
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeMenuCreateManyInput = {
    id?: bigint | number
    cafe_id: bigint | number
    category: string
    name: string
    description: string
    price: number
    is_sold_out: boolean
    photo_url: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CafeMenuUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    is_sold_out?: BoolFieldUpdateOperationsInput | boolean
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeMenuUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    is_sold_out?: BoolFieldUpdateOperationsInput | boolean
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafePhotoCreateInput = {
    id?: bigint | number
    photo_url: string
    display_order: number
    created_at?: Date | string
    cafe: CafeCreateNestedOneWithoutPhotosInput
  }

  export type CafePhotoUncheckedCreateInput = {
    id?: bigint | number
    cafe_id: bigint | number
    photo_url: string
    display_order: number
    created_at?: Date | string
  }

  export type CafePhotoUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    photo_url?: StringFieldUpdateOperationsInput | string
    display_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cafe?: CafeUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type CafePhotoUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    photo_url?: StringFieldUpdateOperationsInput | string
    display_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafePhotoCreateManyInput = {
    id?: bigint | number
    cafe_id: bigint | number
    photo_url: string
    display_order: number
    created_at?: Date | string
  }

  export type CafePhotoUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    photo_url?: StringFieldUpdateOperationsInput | string
    display_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafePhotoUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    photo_url?: StringFieldUpdateOperationsInput | string
    display_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    title: string
    content: string
    images: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    cafe: CafeCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: number
    user_id: bigint | number
    cafe_id: bigint | number
    title: string
    content: string
    images: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ReviewUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    cafe?: CafeUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: number
    user_id: bigint | number
    cafe_id: bigint | number
    title: string
    content: string
    images: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    type: string
    title: string
    content: string
    is_read: boolean
    created_at?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
    cafe: CafeCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    user_id: bigint | number
    cafe_id: bigint | number
    type: string
    title: string
    content: string
    is_read: boolean
    created_at?: Date | string
  }

  export type NotificationUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    cafe?: CafeUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    user_id: bigint | number
    cafe_id: bigint | number
    type: string
    title: string
    content: string
    is_read: boolean
    created_at?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponCreateInput = {
    type: string
    name: string
    status: string
    issued_at: Date | string
    expired_at: Date | string
    used_at: Date | string
    user: UserCreateNestedOneWithoutCouponsInput
    cafe: CafeCreateNestedOneWithoutCouponsInput
  }

  export type CouponUncheckedCreateInput = {
    id?: number
    user_id: bigint | number
    cafe_id: bigint | number
    type: string
    name: string
    status: string
    issued_at: Date | string
    expired_at: Date | string
    used_at: Date | string
  }

  export type CouponUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCouponsNestedInput
    cafe?: CafeUpdateOneRequiredWithoutCouponsNestedInput
  }

  export type CouponUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponCreateManyInput = {
    id?: number
    user_id: bigint | number
    cafe_id: bigint | number
    type: string
    name: string
    status: string
    issued_at: Date | string
    expired_at: Date | string
    used_at: Date | string
  }

  export type CouponUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type KakaoAccountListRelationFilter = {
    every?: KakaoAccountWhereInput
    some?: KakaoAccountWhereInput
    none?: KakaoAccountWhereInput
  }

  export type UserAgreementNullableScalarRelationFilter = {
    is?: UserAgreementWhereInput | null
    isNot?: UserAgreementWhereInput | null
  }

  export type UserPreferenceListRelationFilter = {
    every?: UserPreferenceWhereInput
    some?: UserPreferenceWhereInput
    none?: UserPreferenceWhereInput
  }

  export type VerificationCodeListRelationFilter = {
    every?: VerificationCodeWhereInput
    some?: VerificationCodeWhereInput
    none?: VerificationCodeWhereInput
  }

  export type ChallengeParticipantListRelationFilter = {
    every?: ChallengeParticipantWhereInput
    some?: ChallengeParticipantWhereInput
    none?: ChallengeParticipantWhereInput
  }

  export type BadgeListRelationFilter = {
    every?: BadgeWhereInput
    some?: BadgeWhereInput
    none?: BadgeWhereInput
  }

  export type StampBookListRelationFilter = {
    every?: StampBookWhereInput
    some?: StampBookWhereInput
    none?: StampBookWhereInput
  }

  export type PointTransactionListRelationFilter = {
    every?: PointTransactionWhereInput
    some?: PointTransactionWhereInput
    none?: PointTransactionWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type CouponListRelationFilter = {
    every?: CouponWhereInput
    some?: CouponWhereInput
    none?: CouponWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type KakaoAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPreferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerificationCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StampBookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PointTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CouponOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    kakao_id?: SortOrder
    password_hash?: SortOrder
    phone_number?: SortOrder
    nickname?: SortOrder
    role?: SortOrder
    allow_kakao_alert?: SortOrder
    status?: SortOrder
    fcm_token?: SortOrder
    profile_image_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    kakao_id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    kakao_id?: SortOrder
    password_hash?: SortOrder
    phone_number?: SortOrder
    nickname?: SortOrder
    role?: SortOrder
    allow_kakao_alert?: SortOrder
    status?: SortOrder
    fcm_token?: SortOrder
    profile_image_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    kakao_id?: SortOrder
    password_hash?: SortOrder
    phone_number?: SortOrder
    nickname?: SortOrder
    role?: SortOrder
    allow_kakao_alert?: SortOrder
    status?: SortOrder
    fcm_token?: SortOrder
    profile_image_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    kakao_id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type KakaoAccountCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    social_id?: SortOrder
    created_at?: SortOrder
  }

  export type KakaoAccountAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type KakaoAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    social_id?: SortOrder
    created_at?: SortOrder
  }

  export type KakaoAccountMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    social_id?: SortOrder
    created_at?: SortOrder
  }

  export type KakaoAccountSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    preferred_area?: SortOrder
    preferred_keywords?: SortOrder
    created_at?: SortOrder
  }

  export type UserPreferenceAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type UserPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    preferred_area?: SortOrder
    created_at?: SortOrder
  }

  export type UserPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    preferred_area?: SortOrder
    created_at?: SortOrder
  }

  export type UserPreferenceSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type VerificationCodeCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    phone_number?: SortOrder
    code?: SortOrder
    expires_at?: SortOrder
    verified?: SortOrder
    created_at?: SortOrder
  }

  export type VerificationCodeAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type VerificationCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    phone_number?: SortOrder
    code?: SortOrder
    expires_at?: SortOrder
    verified?: SortOrder
    created_at?: SortOrder
  }

  export type VerificationCodeMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    phone_number?: SortOrder
    code?: SortOrder
    expires_at?: SortOrder
    verified?: SortOrder
    created_at?: SortOrder
  }

  export type VerificationCodeSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type UserAgreementCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    terms_agreed?: SortOrder
    privacy_policy_agreed?: SortOrder
    marketing_agreed?: SortOrder
    location_permission?: SortOrder
    agreed_at?: SortOrder
  }

  export type UserAgreementAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type UserAgreementMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    terms_agreed?: SortOrder
    privacy_policy_agreed?: SortOrder
    marketing_agreed?: SortOrder
    location_permission?: SortOrder
    agreed_at?: SortOrder
  }

  export type UserAgreementMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    terms_agreed?: SortOrder
    privacy_policy_agreed?: SortOrder
    marketing_agreed?: SortOrder
    location_permission?: SortOrder
    agreed_at?: SortOrder
  }

  export type UserAgreementSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ChallengeAvailableCafeListRelationFilter = {
    every?: ChallengeAvailableCafeWhereInput
    some?: ChallengeAvailableCafeWhereInput
    none?: ChallengeAvailableCafeWhereInput
  }

  export type ChallengeAvailableCafeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail_url?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChallengeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ChallengeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail_url?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChallengeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail_url?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChallengeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ChallengeScalarRelationFilter = {
    is?: ChallengeWhereInput
    isNot?: ChallengeWhereInput
  }

  export type ChallengeParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    status?: SortOrder
    joined_at?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChallengeParticipantAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
  }

  export type ChallengeParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    status?: SortOrder
    joined_at?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChallengeParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    status?: SortOrder
    joined_at?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChallengeParticipantSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
  }

  export type CafeScalarRelationFilter = {
    is?: CafeWhereInput
    isNot?: CafeWhereInput
  }

  export type ChallengeAvailableCafeCountOrderByAggregateInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    cafe_id?: SortOrder
    created_at?: SortOrder
  }

  export type ChallengeAvailableCafeAvgOrderByAggregateInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    cafe_id?: SortOrder
  }

  export type ChallengeAvailableCafeMaxOrderByAggregateInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    cafe_id?: SortOrder
    created_at?: SortOrder
  }

  export type ChallengeAvailableCafeMinOrderByAggregateInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    cafe_id?: SortOrder
    created_at?: SortOrder
  }

  export type ChallengeAvailableCafeSumOrderByAggregateInput = {
    id?: SortOrder
    challenge_id?: SortOrder
    cafe_id?: SortOrder
  }

  export type BadgeTypeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image_url?: SortOrder
    created_at?: SortOrder
  }

  export type BadgeTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BadgeTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image_url?: SortOrder
    created_at?: SortOrder
  }

  export type BadgeTypeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    image_url?: SortOrder
    created_at?: SortOrder
  }

  export type BadgeTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BadgeTypeScalarRelationFilter = {
    is?: BadgeTypeWhereInput
    isNot?: BadgeTypeWhereInput
  }

  export type BadgeCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    badge_type_id?: SortOrder
    earned_at?: SortOrder
  }

  export type BadgeAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    badge_type_id?: SortOrder
  }

  export type BadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    badge_type_id?: SortOrder
    earned_at?: SortOrder
  }

  export type BadgeMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    badge_type_id?: SortOrder
    earned_at?: SortOrder
  }

  export type BadgeSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    challenge_id?: SortOrder
    badge_type_id?: SortOrder
  }

  export type StampListRelationFilter = {
    every?: StampWhereInput
    some?: StampWhereInput
    none?: StampWhereInput
  }

  export type StampOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StampBookCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    current_count?: SortOrder
    goal_count?: SortOrder
    reward_detail?: SortOrder
    started_at?: SortOrder
    last_visited_at?: SortOrder
    expires_at?: SortOrder
    extended_at?: SortOrder
    expired_at?: SortOrder
    completed_at?: SortOrder
    converted_at?: SortOrder
    status?: SortOrder
    is_completed?: SortOrder
    is_converted?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StampBookAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    current_count?: SortOrder
    goal_count?: SortOrder
  }

  export type StampBookMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    current_count?: SortOrder
    goal_count?: SortOrder
    reward_detail?: SortOrder
    started_at?: SortOrder
    last_visited_at?: SortOrder
    expires_at?: SortOrder
    extended_at?: SortOrder
    expired_at?: SortOrder
    completed_at?: SortOrder
    converted_at?: SortOrder
    status?: SortOrder
    is_completed?: SortOrder
    is_converted?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StampBookMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    current_count?: SortOrder
    goal_count?: SortOrder
    reward_detail?: SortOrder
    started_at?: SortOrder
    last_visited_at?: SortOrder
    expires_at?: SortOrder
    extended_at?: SortOrder
    expired_at?: SortOrder
    completed_at?: SortOrder
    converted_at?: SortOrder
    status?: SortOrder
    is_completed?: SortOrder
    is_converted?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StampBookSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    current_count?: SortOrder
    goal_count?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StampBookScalarRelationFilter = {
    is?: StampBookWhereInput
    isNot?: StampBookWhereInput
  }

  export type StampCountOrderByAggregateInput = {
    id?: SortOrder
    stamp_book_id?: SortOrder
    stamp_image_url?: SortOrder
    stamped_at?: SortOrder
    source?: SortOrder
    note?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type StampAvgOrderByAggregateInput = {
    id?: SortOrder
    stamp_book_id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type StampMaxOrderByAggregateInput = {
    id?: SortOrder
    stamp_book_id?: SortOrder
    stamp_image_url?: SortOrder
    stamped_at?: SortOrder
    source?: SortOrder
    note?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type StampMinOrderByAggregateInput = {
    id?: SortOrder
    stamp_book_id?: SortOrder
    stamp_image_url?: SortOrder
    stamped_at?: SortOrder
    source?: SortOrder
    note?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type StampSumOrderByAggregateInput = {
    id?: SortOrder
    stamp_book_id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type PointTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    stamp_book_id?: SortOrder
    point?: SortOrder
    type?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type PointTransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    stamp_book_id?: SortOrder
    point?: SortOrder
  }

  export type PointTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    stamp_book_id?: SortOrder
    point?: SortOrder
    type?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type PointTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    stamp_book_id?: SortOrder
    point?: SortOrder
    type?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type PointTransactionSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    stamp_book_id?: SortOrder
    point?: SortOrder
  }

  export type EnumCafeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CafeStatus | EnumCafeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CafeStatus[] | ListEnumCafeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CafeStatus[] | ListEnumCafeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCafeStatusFilter<$PrismaModel> | $Enums.CafeStatus
  }

  export type CafeMenuListRelationFilter = {
    every?: CafeMenuWhereInput
    some?: CafeMenuWhereInput
    none?: CafeMenuWhereInput
  }

  export type CafePhotoListRelationFilter = {
    every?: CafePhotoWhereInput
    some?: CafePhotoWhereInput
    none?: CafePhotoWhereInput
  }

  export type CafeMenuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CafePhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CafeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    owner_name?: SortOrder
    business_hours?: SortOrder
    phone?: SortOrder
    website_url?: SortOrder
    description?: SortOrder
    store_filters?: SortOrder
    take_out_filters?: SortOrder
    menu_filters?: SortOrder
    keywords?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CafeAvgOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type CafeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    owner_name?: SortOrder
    business_hours?: SortOrder
    phone?: SortOrder
    website_url?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CafeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    owner_name?: SortOrder
    business_hours?: SortOrder
    phone?: SortOrder
    website_url?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CafeSumOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EnumCafeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CafeStatus | EnumCafeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CafeStatus[] | ListEnumCafeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CafeStatus[] | ListEnumCafeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCafeStatusWithAggregatesFilter<$PrismaModel> | $Enums.CafeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCafeStatusFilter<$PrismaModel>
    _max?: NestedEnumCafeStatusFilter<$PrismaModel>
  }

  export type CafeMenuCountOrderByAggregateInput = {
    id?: SortOrder
    cafe_id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    is_sold_out?: SortOrder
    photo_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CafeMenuAvgOrderByAggregateInput = {
    id?: SortOrder
    cafe_id?: SortOrder
    price?: SortOrder
  }

  export type CafeMenuMaxOrderByAggregateInput = {
    id?: SortOrder
    cafe_id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    is_sold_out?: SortOrder
    photo_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CafeMenuMinOrderByAggregateInput = {
    id?: SortOrder
    cafe_id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    is_sold_out?: SortOrder
    photo_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CafeMenuSumOrderByAggregateInput = {
    id?: SortOrder
    cafe_id?: SortOrder
    price?: SortOrder
  }

  export type CafePhotoCountOrderByAggregateInput = {
    id?: SortOrder
    cafe_id?: SortOrder
    photo_url?: SortOrder
    display_order?: SortOrder
    created_at?: SortOrder
  }

  export type CafePhotoAvgOrderByAggregateInput = {
    id?: SortOrder
    cafe_id?: SortOrder
    display_order?: SortOrder
  }

  export type CafePhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    cafe_id?: SortOrder
    photo_url?: SortOrder
    display_order?: SortOrder
    created_at?: SortOrder
  }

  export type CafePhotoMinOrderByAggregateInput = {
    id?: SortOrder
    cafe_id?: SortOrder
    photo_url?: SortOrder
    display_order?: SortOrder
    created_at?: SortOrder
  }

  export type CafePhotoSumOrderByAggregateInput = {
    id?: SortOrder
    cafe_id?: SortOrder
    display_order?: SortOrder
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    images?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    is_read?: SortOrder
    created_at?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    is_read?: SortOrder
    created_at?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    is_read?: SortOrder
    created_at?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
  }

  export type CouponCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    status?: SortOrder
    issued_at?: SortOrder
    expired_at?: SortOrder
    used_at?: SortOrder
  }

  export type CouponAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
  }

  export type CouponMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    status?: SortOrder
    issued_at?: SortOrder
    expired_at?: SortOrder
    used_at?: SortOrder
  }

  export type CouponMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    status?: SortOrder
    issued_at?: SortOrder
    expired_at?: SortOrder
    used_at?: SortOrder
  }

  export type CouponSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    cafe_id?: SortOrder
  }

  export type KakaoAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<KakaoAccountCreateWithoutUserInput, KakaoAccountUncheckedCreateWithoutUserInput> | KakaoAccountCreateWithoutUserInput[] | KakaoAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KakaoAccountCreateOrConnectWithoutUserInput | KakaoAccountCreateOrConnectWithoutUserInput[]
    createMany?: KakaoAccountCreateManyUserInputEnvelope
    connect?: KakaoAccountWhereUniqueInput | KakaoAccountWhereUniqueInput[]
  }

  export type UserAgreementCreateNestedOneWithoutUserInput = {
    create?: XOR<UserAgreementCreateWithoutUserInput, UserAgreementUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAgreementCreateOrConnectWithoutUserInput
    connect?: UserAgreementWhereUniqueInput
  }

  export type UserPreferenceCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput> | UserPreferenceCreateWithoutUserInput[] | UserPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutUserInput | UserPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: UserPreferenceCreateManyUserInputEnvelope
    connect?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
  }

  export type VerificationCodeCreateNestedManyWithoutUserInput = {
    create?: XOR<VerificationCodeCreateWithoutUserInput, VerificationCodeUncheckedCreateWithoutUserInput> | VerificationCodeCreateWithoutUserInput[] | VerificationCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationCodeCreateOrConnectWithoutUserInput | VerificationCodeCreateOrConnectWithoutUserInput[]
    createMany?: VerificationCodeCreateManyUserInputEnvelope
    connect?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
  }

  export type ChallengeParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<ChallengeParticipantCreateWithoutUserInput, ChallengeParticipantUncheckedCreateWithoutUserInput> | ChallengeParticipantCreateWithoutUserInput[] | ChallengeParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutUserInput | ChallengeParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ChallengeParticipantCreateManyUserInputEnvelope
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
  }

  export type BadgeCreateNestedManyWithoutUserInput = {
    create?: XOR<BadgeCreateWithoutUserInput, BadgeUncheckedCreateWithoutUserInput> | BadgeCreateWithoutUserInput[] | BadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutUserInput | BadgeCreateOrConnectWithoutUserInput[]
    createMany?: BadgeCreateManyUserInputEnvelope
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
  }

  export type StampBookCreateNestedManyWithoutUserInput = {
    create?: XOR<StampBookCreateWithoutUserInput, StampBookUncheckedCreateWithoutUserInput> | StampBookCreateWithoutUserInput[] | StampBookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StampBookCreateOrConnectWithoutUserInput | StampBookCreateOrConnectWithoutUserInput[]
    createMany?: StampBookCreateManyUserInputEnvelope
    connect?: StampBookWhereUniqueInput | StampBookWhereUniqueInput[]
  }

  export type PointTransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<PointTransactionCreateWithoutUserInput, PointTransactionUncheckedCreateWithoutUserInput> | PointTransactionCreateWithoutUserInput[] | PointTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointTransactionCreateOrConnectWithoutUserInput | PointTransactionCreateOrConnectWithoutUserInput[]
    createMany?: PointTransactionCreateManyUserInputEnvelope
    connect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CouponCreateNestedManyWithoutUserInput = {
    create?: XOR<CouponCreateWithoutUserInput, CouponUncheckedCreateWithoutUserInput> | CouponCreateWithoutUserInput[] | CouponUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutUserInput | CouponCreateOrConnectWithoutUserInput[]
    createMany?: CouponCreateManyUserInputEnvelope
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
  }

  export type KakaoAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<KakaoAccountCreateWithoutUserInput, KakaoAccountUncheckedCreateWithoutUserInput> | KakaoAccountCreateWithoutUserInput[] | KakaoAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KakaoAccountCreateOrConnectWithoutUserInput | KakaoAccountCreateOrConnectWithoutUserInput[]
    createMany?: KakaoAccountCreateManyUserInputEnvelope
    connect?: KakaoAccountWhereUniqueInput | KakaoAccountWhereUniqueInput[]
  }

  export type UserAgreementUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserAgreementCreateWithoutUserInput, UserAgreementUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAgreementCreateOrConnectWithoutUserInput
    connect?: UserAgreementWhereUniqueInput
  }

  export type UserPreferenceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput> | UserPreferenceCreateWithoutUserInput[] | UserPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutUserInput | UserPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: UserPreferenceCreateManyUserInputEnvelope
    connect?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
  }

  export type VerificationCodeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VerificationCodeCreateWithoutUserInput, VerificationCodeUncheckedCreateWithoutUserInput> | VerificationCodeCreateWithoutUserInput[] | VerificationCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationCodeCreateOrConnectWithoutUserInput | VerificationCodeCreateOrConnectWithoutUserInput[]
    createMany?: VerificationCodeCreateManyUserInputEnvelope
    connect?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
  }

  export type ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChallengeParticipantCreateWithoutUserInput, ChallengeParticipantUncheckedCreateWithoutUserInput> | ChallengeParticipantCreateWithoutUserInput[] | ChallengeParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutUserInput | ChallengeParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ChallengeParticipantCreateManyUserInputEnvelope
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
  }

  export type BadgeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BadgeCreateWithoutUserInput, BadgeUncheckedCreateWithoutUserInput> | BadgeCreateWithoutUserInput[] | BadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutUserInput | BadgeCreateOrConnectWithoutUserInput[]
    createMany?: BadgeCreateManyUserInputEnvelope
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
  }

  export type StampBookUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StampBookCreateWithoutUserInput, StampBookUncheckedCreateWithoutUserInput> | StampBookCreateWithoutUserInput[] | StampBookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StampBookCreateOrConnectWithoutUserInput | StampBookCreateOrConnectWithoutUserInput[]
    createMany?: StampBookCreateManyUserInputEnvelope
    connect?: StampBookWhereUniqueInput | StampBookWhereUniqueInput[]
  }

  export type PointTransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PointTransactionCreateWithoutUserInput, PointTransactionUncheckedCreateWithoutUserInput> | PointTransactionCreateWithoutUserInput[] | PointTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointTransactionCreateOrConnectWithoutUserInput | PointTransactionCreateOrConnectWithoutUserInput[]
    createMany?: PointTransactionCreateManyUserInputEnvelope
    connect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CouponUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CouponCreateWithoutUserInput, CouponUncheckedCreateWithoutUserInput> | CouponCreateWithoutUserInput[] | CouponUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutUserInput | CouponCreateOrConnectWithoutUserInput[]
    createMany?: CouponCreateManyUserInputEnvelope
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type KakaoAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<KakaoAccountCreateWithoutUserInput, KakaoAccountUncheckedCreateWithoutUserInput> | KakaoAccountCreateWithoutUserInput[] | KakaoAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KakaoAccountCreateOrConnectWithoutUserInput | KakaoAccountCreateOrConnectWithoutUserInput[]
    upsert?: KakaoAccountUpsertWithWhereUniqueWithoutUserInput | KakaoAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: KakaoAccountCreateManyUserInputEnvelope
    set?: KakaoAccountWhereUniqueInput | KakaoAccountWhereUniqueInput[]
    disconnect?: KakaoAccountWhereUniqueInput | KakaoAccountWhereUniqueInput[]
    delete?: KakaoAccountWhereUniqueInput | KakaoAccountWhereUniqueInput[]
    connect?: KakaoAccountWhereUniqueInput | KakaoAccountWhereUniqueInput[]
    update?: KakaoAccountUpdateWithWhereUniqueWithoutUserInput | KakaoAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: KakaoAccountUpdateManyWithWhereWithoutUserInput | KakaoAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: KakaoAccountScalarWhereInput | KakaoAccountScalarWhereInput[]
  }

  export type UserAgreementUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserAgreementCreateWithoutUserInput, UserAgreementUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAgreementCreateOrConnectWithoutUserInput
    upsert?: UserAgreementUpsertWithoutUserInput
    disconnect?: UserAgreementWhereInput | boolean
    delete?: UserAgreementWhereInput | boolean
    connect?: UserAgreementWhereUniqueInput
    update?: XOR<XOR<UserAgreementUpdateToOneWithWhereWithoutUserInput, UserAgreementUpdateWithoutUserInput>, UserAgreementUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferenceUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput> | UserPreferenceCreateWithoutUserInput[] | UserPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutUserInput | UserPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: UserPreferenceUpsertWithWhereUniqueWithoutUserInput | UserPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPreferenceCreateManyUserInputEnvelope
    set?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    disconnect?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    delete?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    connect?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    update?: UserPreferenceUpdateWithWhereUniqueWithoutUserInput | UserPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPreferenceUpdateManyWithWhereWithoutUserInput | UserPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPreferenceScalarWhereInput | UserPreferenceScalarWhereInput[]
  }

  export type VerificationCodeUpdateManyWithoutUserNestedInput = {
    create?: XOR<VerificationCodeCreateWithoutUserInput, VerificationCodeUncheckedCreateWithoutUserInput> | VerificationCodeCreateWithoutUserInput[] | VerificationCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationCodeCreateOrConnectWithoutUserInput | VerificationCodeCreateOrConnectWithoutUserInput[]
    upsert?: VerificationCodeUpsertWithWhereUniqueWithoutUserInput | VerificationCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VerificationCodeCreateManyUserInputEnvelope
    set?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    disconnect?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    delete?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    connect?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    update?: VerificationCodeUpdateWithWhereUniqueWithoutUserInput | VerificationCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VerificationCodeUpdateManyWithWhereWithoutUserInput | VerificationCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VerificationCodeScalarWhereInput | VerificationCodeScalarWhereInput[]
  }

  export type ChallengeParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChallengeParticipantCreateWithoutUserInput, ChallengeParticipantUncheckedCreateWithoutUserInput> | ChallengeParticipantCreateWithoutUserInput[] | ChallengeParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutUserInput | ChallengeParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ChallengeParticipantUpsertWithWhereUniqueWithoutUserInput | ChallengeParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChallengeParticipantCreateManyUserInputEnvelope
    set?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    disconnect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    delete?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    update?: ChallengeParticipantUpdateWithWhereUniqueWithoutUserInput | ChallengeParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChallengeParticipantUpdateManyWithWhereWithoutUserInput | ChallengeParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChallengeParticipantScalarWhereInput | ChallengeParticipantScalarWhereInput[]
  }

  export type BadgeUpdateManyWithoutUserNestedInput = {
    create?: XOR<BadgeCreateWithoutUserInput, BadgeUncheckedCreateWithoutUserInput> | BadgeCreateWithoutUserInput[] | BadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutUserInput | BadgeCreateOrConnectWithoutUserInput[]
    upsert?: BadgeUpsertWithWhereUniqueWithoutUserInput | BadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BadgeCreateManyUserInputEnvelope
    set?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    disconnect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    delete?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    update?: BadgeUpdateWithWhereUniqueWithoutUserInput | BadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BadgeUpdateManyWithWhereWithoutUserInput | BadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
  }

  export type StampBookUpdateManyWithoutUserNestedInput = {
    create?: XOR<StampBookCreateWithoutUserInput, StampBookUncheckedCreateWithoutUserInput> | StampBookCreateWithoutUserInput[] | StampBookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StampBookCreateOrConnectWithoutUserInput | StampBookCreateOrConnectWithoutUserInput[]
    upsert?: StampBookUpsertWithWhereUniqueWithoutUserInput | StampBookUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StampBookCreateManyUserInputEnvelope
    set?: StampBookWhereUniqueInput | StampBookWhereUniqueInput[]
    disconnect?: StampBookWhereUniqueInput | StampBookWhereUniqueInput[]
    delete?: StampBookWhereUniqueInput | StampBookWhereUniqueInput[]
    connect?: StampBookWhereUniqueInput | StampBookWhereUniqueInput[]
    update?: StampBookUpdateWithWhereUniqueWithoutUserInput | StampBookUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StampBookUpdateManyWithWhereWithoutUserInput | StampBookUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StampBookScalarWhereInput | StampBookScalarWhereInput[]
  }

  export type PointTransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<PointTransactionCreateWithoutUserInput, PointTransactionUncheckedCreateWithoutUserInput> | PointTransactionCreateWithoutUserInput[] | PointTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointTransactionCreateOrConnectWithoutUserInput | PointTransactionCreateOrConnectWithoutUserInput[]
    upsert?: PointTransactionUpsertWithWhereUniqueWithoutUserInput | PointTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PointTransactionCreateManyUserInputEnvelope
    set?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    disconnect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    delete?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    connect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    update?: PointTransactionUpdateWithWhereUniqueWithoutUserInput | PointTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PointTransactionUpdateManyWithWhereWithoutUserInput | PointTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PointTransactionScalarWhereInput | PointTransactionScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CouponUpdateManyWithoutUserNestedInput = {
    create?: XOR<CouponCreateWithoutUserInput, CouponUncheckedCreateWithoutUserInput> | CouponCreateWithoutUserInput[] | CouponUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutUserInput | CouponCreateOrConnectWithoutUserInput[]
    upsert?: CouponUpsertWithWhereUniqueWithoutUserInput | CouponUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CouponCreateManyUserInputEnvelope
    set?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    disconnect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    delete?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    update?: CouponUpdateWithWhereUniqueWithoutUserInput | CouponUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CouponUpdateManyWithWhereWithoutUserInput | CouponUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CouponScalarWhereInput | CouponScalarWhereInput[]
  }

  export type KakaoAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<KakaoAccountCreateWithoutUserInput, KakaoAccountUncheckedCreateWithoutUserInput> | KakaoAccountCreateWithoutUserInput[] | KakaoAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KakaoAccountCreateOrConnectWithoutUserInput | KakaoAccountCreateOrConnectWithoutUserInput[]
    upsert?: KakaoAccountUpsertWithWhereUniqueWithoutUserInput | KakaoAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: KakaoAccountCreateManyUserInputEnvelope
    set?: KakaoAccountWhereUniqueInput | KakaoAccountWhereUniqueInput[]
    disconnect?: KakaoAccountWhereUniqueInput | KakaoAccountWhereUniqueInput[]
    delete?: KakaoAccountWhereUniqueInput | KakaoAccountWhereUniqueInput[]
    connect?: KakaoAccountWhereUniqueInput | KakaoAccountWhereUniqueInput[]
    update?: KakaoAccountUpdateWithWhereUniqueWithoutUserInput | KakaoAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: KakaoAccountUpdateManyWithWhereWithoutUserInput | KakaoAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: KakaoAccountScalarWhereInput | KakaoAccountScalarWhereInput[]
  }

  export type UserAgreementUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserAgreementCreateWithoutUserInput, UserAgreementUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAgreementCreateOrConnectWithoutUserInput
    upsert?: UserAgreementUpsertWithoutUserInput
    disconnect?: UserAgreementWhereInput | boolean
    delete?: UserAgreementWhereInput | boolean
    connect?: UserAgreementWhereUniqueInput
    update?: XOR<XOR<UserAgreementUpdateToOneWithWhereWithoutUserInput, UserAgreementUpdateWithoutUserInput>, UserAgreementUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferenceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput> | UserPreferenceCreateWithoutUserInput[] | UserPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutUserInput | UserPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: UserPreferenceUpsertWithWhereUniqueWithoutUserInput | UserPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPreferenceCreateManyUserInputEnvelope
    set?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    disconnect?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    delete?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    connect?: UserPreferenceWhereUniqueInput | UserPreferenceWhereUniqueInput[]
    update?: UserPreferenceUpdateWithWhereUniqueWithoutUserInput | UserPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPreferenceUpdateManyWithWhereWithoutUserInput | UserPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPreferenceScalarWhereInput | UserPreferenceScalarWhereInput[]
  }

  export type VerificationCodeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VerificationCodeCreateWithoutUserInput, VerificationCodeUncheckedCreateWithoutUserInput> | VerificationCodeCreateWithoutUserInput[] | VerificationCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationCodeCreateOrConnectWithoutUserInput | VerificationCodeCreateOrConnectWithoutUserInput[]
    upsert?: VerificationCodeUpsertWithWhereUniqueWithoutUserInput | VerificationCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VerificationCodeCreateManyUserInputEnvelope
    set?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    disconnect?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    delete?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    connect?: VerificationCodeWhereUniqueInput | VerificationCodeWhereUniqueInput[]
    update?: VerificationCodeUpdateWithWhereUniqueWithoutUserInput | VerificationCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VerificationCodeUpdateManyWithWhereWithoutUserInput | VerificationCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VerificationCodeScalarWhereInput | VerificationCodeScalarWhereInput[]
  }

  export type ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChallengeParticipantCreateWithoutUserInput, ChallengeParticipantUncheckedCreateWithoutUserInput> | ChallengeParticipantCreateWithoutUserInput[] | ChallengeParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutUserInput | ChallengeParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ChallengeParticipantUpsertWithWhereUniqueWithoutUserInput | ChallengeParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChallengeParticipantCreateManyUserInputEnvelope
    set?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    disconnect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    delete?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    update?: ChallengeParticipantUpdateWithWhereUniqueWithoutUserInput | ChallengeParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChallengeParticipantUpdateManyWithWhereWithoutUserInput | ChallengeParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChallengeParticipantScalarWhereInput | ChallengeParticipantScalarWhereInput[]
  }

  export type BadgeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BadgeCreateWithoutUserInput, BadgeUncheckedCreateWithoutUserInput> | BadgeCreateWithoutUserInput[] | BadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutUserInput | BadgeCreateOrConnectWithoutUserInput[]
    upsert?: BadgeUpsertWithWhereUniqueWithoutUserInput | BadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BadgeCreateManyUserInputEnvelope
    set?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    disconnect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    delete?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    update?: BadgeUpdateWithWhereUniqueWithoutUserInput | BadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BadgeUpdateManyWithWhereWithoutUserInput | BadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
  }

  export type StampBookUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StampBookCreateWithoutUserInput, StampBookUncheckedCreateWithoutUserInput> | StampBookCreateWithoutUserInput[] | StampBookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StampBookCreateOrConnectWithoutUserInput | StampBookCreateOrConnectWithoutUserInput[]
    upsert?: StampBookUpsertWithWhereUniqueWithoutUserInput | StampBookUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StampBookCreateManyUserInputEnvelope
    set?: StampBookWhereUniqueInput | StampBookWhereUniqueInput[]
    disconnect?: StampBookWhereUniqueInput | StampBookWhereUniqueInput[]
    delete?: StampBookWhereUniqueInput | StampBookWhereUniqueInput[]
    connect?: StampBookWhereUniqueInput | StampBookWhereUniqueInput[]
    update?: StampBookUpdateWithWhereUniqueWithoutUserInput | StampBookUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StampBookUpdateManyWithWhereWithoutUserInput | StampBookUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StampBookScalarWhereInput | StampBookScalarWhereInput[]
  }

  export type PointTransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PointTransactionCreateWithoutUserInput, PointTransactionUncheckedCreateWithoutUserInput> | PointTransactionCreateWithoutUserInput[] | PointTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointTransactionCreateOrConnectWithoutUserInput | PointTransactionCreateOrConnectWithoutUserInput[]
    upsert?: PointTransactionUpsertWithWhereUniqueWithoutUserInput | PointTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PointTransactionCreateManyUserInputEnvelope
    set?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    disconnect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    delete?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    connect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    update?: PointTransactionUpdateWithWhereUniqueWithoutUserInput | PointTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PointTransactionUpdateManyWithWhereWithoutUserInput | PointTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PointTransactionScalarWhereInput | PointTransactionScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CouponUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CouponCreateWithoutUserInput, CouponUncheckedCreateWithoutUserInput> | CouponCreateWithoutUserInput[] | CouponUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutUserInput | CouponCreateOrConnectWithoutUserInput[]
    upsert?: CouponUpsertWithWhereUniqueWithoutUserInput | CouponUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CouponCreateManyUserInputEnvelope
    set?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    disconnect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    delete?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    update?: CouponUpdateWithWhereUniqueWithoutUserInput | CouponUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CouponUpdateManyWithWhereWithoutUserInput | CouponUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CouponScalarWhereInput | CouponScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutKakao_accountsInput = {
    create?: XOR<UserCreateWithoutKakao_accountsInput, UserUncheckedCreateWithoutKakao_accountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutKakao_accountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutKakao_accountsNestedInput = {
    create?: XOR<UserCreateWithoutKakao_accountsInput, UserUncheckedCreateWithoutKakao_accountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutKakao_accountsInput
    upsert?: UserUpsertWithoutKakao_accountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutKakao_accountsInput, UserUpdateWithoutKakao_accountsInput>, UserUncheckedUpdateWithoutKakao_accountsInput>
  }

  export type UserCreateNestedOneWithoutUser_preferencesInput = {
    create?: XOR<UserCreateWithoutUser_preferencesInput, UserUncheckedCreateWithoutUser_preferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_preferencesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUser_preferencesNestedInput = {
    create?: XOR<UserCreateWithoutUser_preferencesInput, UserUncheckedCreateWithoutUser_preferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_preferencesInput
    upsert?: UserUpsertWithoutUser_preferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUser_preferencesInput, UserUpdateWithoutUser_preferencesInput>, UserUncheckedUpdateWithoutUser_preferencesInput>
  }

  export type UserCreateNestedOneWithoutVerification_codesInput = {
    create?: XOR<UserCreateWithoutVerification_codesInput, UserUncheckedCreateWithoutVerification_codesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerification_codesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutVerification_codesNestedInput = {
    create?: XOR<UserCreateWithoutVerification_codesInput, UserUncheckedCreateWithoutVerification_codesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerification_codesInput
    upsert?: UserUpsertWithoutVerification_codesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerification_codesInput, UserUpdateWithoutVerification_codesInput>, UserUncheckedUpdateWithoutVerification_codesInput>
  }

  export type UserCreateNestedOneWithoutUser_agreementsInput = {
    create?: XOR<UserCreateWithoutUser_agreementsInput, UserUncheckedCreateWithoutUser_agreementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_agreementsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUser_agreementsNestedInput = {
    create?: XOR<UserCreateWithoutUser_agreementsInput, UserUncheckedCreateWithoutUser_agreementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_agreementsInput
    upsert?: UserUpsertWithoutUser_agreementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUser_agreementsInput, UserUpdateWithoutUser_agreementsInput>, UserUncheckedUpdateWithoutUser_agreementsInput>
  }

  export type ChallengeParticipantCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeParticipantCreateWithoutChallengeInput, ChallengeParticipantUncheckedCreateWithoutChallengeInput> | ChallengeParticipantCreateWithoutChallengeInput[] | ChallengeParticipantUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutChallengeInput | ChallengeParticipantCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeParticipantCreateManyChallengeInputEnvelope
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
  }

  export type ChallengeAvailableCafeCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeAvailableCafeCreateWithoutChallengeInput, ChallengeAvailableCafeUncheckedCreateWithoutChallengeInput> | ChallengeAvailableCafeCreateWithoutChallengeInput[] | ChallengeAvailableCafeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeAvailableCafeCreateOrConnectWithoutChallengeInput | ChallengeAvailableCafeCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeAvailableCafeCreateManyChallengeInputEnvelope
    connect?: ChallengeAvailableCafeWhereUniqueInput | ChallengeAvailableCafeWhereUniqueInput[]
  }

  export type BadgeCreateNestedManyWithoutChallengeInput = {
    create?: XOR<BadgeCreateWithoutChallengeInput, BadgeUncheckedCreateWithoutChallengeInput> | BadgeCreateWithoutChallengeInput[] | BadgeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutChallengeInput | BadgeCreateOrConnectWithoutChallengeInput[]
    createMany?: BadgeCreateManyChallengeInputEnvelope
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
  }

  export type ChallengeParticipantUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeParticipantCreateWithoutChallengeInput, ChallengeParticipantUncheckedCreateWithoutChallengeInput> | ChallengeParticipantCreateWithoutChallengeInput[] | ChallengeParticipantUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutChallengeInput | ChallengeParticipantCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeParticipantCreateManyChallengeInputEnvelope
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
  }

  export type ChallengeAvailableCafeUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeAvailableCafeCreateWithoutChallengeInput, ChallengeAvailableCafeUncheckedCreateWithoutChallengeInput> | ChallengeAvailableCafeCreateWithoutChallengeInput[] | ChallengeAvailableCafeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeAvailableCafeCreateOrConnectWithoutChallengeInput | ChallengeAvailableCafeCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeAvailableCafeCreateManyChallengeInputEnvelope
    connect?: ChallengeAvailableCafeWhereUniqueInput | ChallengeAvailableCafeWhereUniqueInput[]
  }

  export type BadgeUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<BadgeCreateWithoutChallengeInput, BadgeUncheckedCreateWithoutChallengeInput> | BadgeCreateWithoutChallengeInput[] | BadgeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutChallengeInput | BadgeCreateOrConnectWithoutChallengeInput[]
    createMany?: BadgeCreateManyChallengeInputEnvelope
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
  }

  export type ChallengeParticipantUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeParticipantCreateWithoutChallengeInput, ChallengeParticipantUncheckedCreateWithoutChallengeInput> | ChallengeParticipantCreateWithoutChallengeInput[] | ChallengeParticipantUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutChallengeInput | ChallengeParticipantCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeParticipantUpsertWithWhereUniqueWithoutChallengeInput | ChallengeParticipantUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeParticipantCreateManyChallengeInputEnvelope
    set?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    disconnect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    delete?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    update?: ChallengeParticipantUpdateWithWhereUniqueWithoutChallengeInput | ChallengeParticipantUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeParticipantUpdateManyWithWhereWithoutChallengeInput | ChallengeParticipantUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeParticipantScalarWhereInput | ChallengeParticipantScalarWhereInput[]
  }

  export type ChallengeAvailableCafeUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeAvailableCafeCreateWithoutChallengeInput, ChallengeAvailableCafeUncheckedCreateWithoutChallengeInput> | ChallengeAvailableCafeCreateWithoutChallengeInput[] | ChallengeAvailableCafeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeAvailableCafeCreateOrConnectWithoutChallengeInput | ChallengeAvailableCafeCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeAvailableCafeUpsertWithWhereUniqueWithoutChallengeInput | ChallengeAvailableCafeUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeAvailableCafeCreateManyChallengeInputEnvelope
    set?: ChallengeAvailableCafeWhereUniqueInput | ChallengeAvailableCafeWhereUniqueInput[]
    disconnect?: ChallengeAvailableCafeWhereUniqueInput | ChallengeAvailableCafeWhereUniqueInput[]
    delete?: ChallengeAvailableCafeWhereUniqueInput | ChallengeAvailableCafeWhereUniqueInput[]
    connect?: ChallengeAvailableCafeWhereUniqueInput | ChallengeAvailableCafeWhereUniqueInput[]
    update?: ChallengeAvailableCafeUpdateWithWhereUniqueWithoutChallengeInput | ChallengeAvailableCafeUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeAvailableCafeUpdateManyWithWhereWithoutChallengeInput | ChallengeAvailableCafeUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeAvailableCafeScalarWhereInput | ChallengeAvailableCafeScalarWhereInput[]
  }

  export type BadgeUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<BadgeCreateWithoutChallengeInput, BadgeUncheckedCreateWithoutChallengeInput> | BadgeCreateWithoutChallengeInput[] | BadgeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutChallengeInput | BadgeCreateOrConnectWithoutChallengeInput[]
    upsert?: BadgeUpsertWithWhereUniqueWithoutChallengeInput | BadgeUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: BadgeCreateManyChallengeInputEnvelope
    set?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    disconnect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    delete?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    update?: BadgeUpdateWithWhereUniqueWithoutChallengeInput | BadgeUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: BadgeUpdateManyWithWhereWithoutChallengeInput | BadgeUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ChallengeParticipantUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeParticipantCreateWithoutChallengeInput, ChallengeParticipantUncheckedCreateWithoutChallengeInput> | ChallengeParticipantCreateWithoutChallengeInput[] | ChallengeParticipantUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeParticipantCreateOrConnectWithoutChallengeInput | ChallengeParticipantCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeParticipantUpsertWithWhereUniqueWithoutChallengeInput | ChallengeParticipantUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeParticipantCreateManyChallengeInputEnvelope
    set?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    disconnect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    delete?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    connect?: ChallengeParticipantWhereUniqueInput | ChallengeParticipantWhereUniqueInput[]
    update?: ChallengeParticipantUpdateWithWhereUniqueWithoutChallengeInput | ChallengeParticipantUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeParticipantUpdateManyWithWhereWithoutChallengeInput | ChallengeParticipantUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeParticipantScalarWhereInput | ChallengeParticipantScalarWhereInput[]
  }

  export type ChallengeAvailableCafeUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeAvailableCafeCreateWithoutChallengeInput, ChallengeAvailableCafeUncheckedCreateWithoutChallengeInput> | ChallengeAvailableCafeCreateWithoutChallengeInput[] | ChallengeAvailableCafeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeAvailableCafeCreateOrConnectWithoutChallengeInput | ChallengeAvailableCafeCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeAvailableCafeUpsertWithWhereUniqueWithoutChallengeInput | ChallengeAvailableCafeUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeAvailableCafeCreateManyChallengeInputEnvelope
    set?: ChallengeAvailableCafeWhereUniqueInput | ChallengeAvailableCafeWhereUniqueInput[]
    disconnect?: ChallengeAvailableCafeWhereUniqueInput | ChallengeAvailableCafeWhereUniqueInput[]
    delete?: ChallengeAvailableCafeWhereUniqueInput | ChallengeAvailableCafeWhereUniqueInput[]
    connect?: ChallengeAvailableCafeWhereUniqueInput | ChallengeAvailableCafeWhereUniqueInput[]
    update?: ChallengeAvailableCafeUpdateWithWhereUniqueWithoutChallengeInput | ChallengeAvailableCafeUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeAvailableCafeUpdateManyWithWhereWithoutChallengeInput | ChallengeAvailableCafeUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeAvailableCafeScalarWhereInput | ChallengeAvailableCafeScalarWhereInput[]
  }

  export type BadgeUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<BadgeCreateWithoutChallengeInput, BadgeUncheckedCreateWithoutChallengeInput> | BadgeCreateWithoutChallengeInput[] | BadgeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutChallengeInput | BadgeCreateOrConnectWithoutChallengeInput[]
    upsert?: BadgeUpsertWithWhereUniqueWithoutChallengeInput | BadgeUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: BadgeCreateManyChallengeInputEnvelope
    set?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    disconnect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    delete?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    update?: BadgeUpdateWithWhereUniqueWithoutChallengeInput | BadgeUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: BadgeUpdateManyWithWhereWithoutChallengeInput | BadgeUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutChallenge_participantsInput = {
    create?: XOR<UserCreateWithoutChallenge_participantsInput, UserUncheckedCreateWithoutChallenge_participantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallenge_participantsInput
    connect?: UserWhereUniqueInput
  }

  export type ChallengeCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<ChallengeCreateWithoutParticipantsInput, ChallengeUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutParticipantsInput
    connect?: ChallengeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChallenge_participantsNestedInput = {
    create?: XOR<UserCreateWithoutChallenge_participantsInput, UserUncheckedCreateWithoutChallenge_participantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallenge_participantsInput
    upsert?: UserUpsertWithoutChallenge_participantsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChallenge_participantsInput, UserUpdateWithoutChallenge_participantsInput>, UserUncheckedUpdateWithoutChallenge_participantsInput>
  }

  export type ChallengeUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<ChallengeCreateWithoutParticipantsInput, ChallengeUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutParticipantsInput
    upsert?: ChallengeUpsertWithoutParticipantsInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutParticipantsInput, ChallengeUpdateWithoutParticipantsInput>, ChallengeUncheckedUpdateWithoutParticipantsInput>
  }

  export type ChallengeCreateNestedOneWithoutAvailable_cafesInput = {
    create?: XOR<ChallengeCreateWithoutAvailable_cafesInput, ChallengeUncheckedCreateWithoutAvailable_cafesInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutAvailable_cafesInput
    connect?: ChallengeWhereUniqueInput
  }

  export type CafeCreateNestedOneWithoutAvailable_challengesInput = {
    create?: XOR<CafeCreateWithoutAvailable_challengesInput, CafeUncheckedCreateWithoutAvailable_challengesInput>
    connectOrCreate?: CafeCreateOrConnectWithoutAvailable_challengesInput
    connect?: CafeWhereUniqueInput
  }

  export type ChallengeUpdateOneRequiredWithoutAvailable_cafesNestedInput = {
    create?: XOR<ChallengeCreateWithoutAvailable_cafesInput, ChallengeUncheckedCreateWithoutAvailable_cafesInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutAvailable_cafesInput
    upsert?: ChallengeUpsertWithoutAvailable_cafesInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutAvailable_cafesInput, ChallengeUpdateWithoutAvailable_cafesInput>, ChallengeUncheckedUpdateWithoutAvailable_cafesInput>
  }

  export type CafeUpdateOneRequiredWithoutAvailable_challengesNestedInput = {
    create?: XOR<CafeCreateWithoutAvailable_challengesInput, CafeUncheckedCreateWithoutAvailable_challengesInput>
    connectOrCreate?: CafeCreateOrConnectWithoutAvailable_challengesInput
    upsert?: CafeUpsertWithoutAvailable_challengesInput
    connect?: CafeWhereUniqueInput
    update?: XOR<XOR<CafeUpdateToOneWithWhereWithoutAvailable_challengesInput, CafeUpdateWithoutAvailable_challengesInput>, CafeUncheckedUpdateWithoutAvailable_challengesInput>
  }

  export type BadgeCreateNestedManyWithoutBadge_typeInput = {
    create?: XOR<BadgeCreateWithoutBadge_typeInput, BadgeUncheckedCreateWithoutBadge_typeInput> | BadgeCreateWithoutBadge_typeInput[] | BadgeUncheckedCreateWithoutBadge_typeInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutBadge_typeInput | BadgeCreateOrConnectWithoutBadge_typeInput[]
    createMany?: BadgeCreateManyBadge_typeInputEnvelope
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
  }

  export type BadgeUncheckedCreateNestedManyWithoutBadge_typeInput = {
    create?: XOR<BadgeCreateWithoutBadge_typeInput, BadgeUncheckedCreateWithoutBadge_typeInput> | BadgeCreateWithoutBadge_typeInput[] | BadgeUncheckedCreateWithoutBadge_typeInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutBadge_typeInput | BadgeCreateOrConnectWithoutBadge_typeInput[]
    createMany?: BadgeCreateManyBadge_typeInputEnvelope
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
  }

  export type BadgeUpdateManyWithoutBadge_typeNestedInput = {
    create?: XOR<BadgeCreateWithoutBadge_typeInput, BadgeUncheckedCreateWithoutBadge_typeInput> | BadgeCreateWithoutBadge_typeInput[] | BadgeUncheckedCreateWithoutBadge_typeInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutBadge_typeInput | BadgeCreateOrConnectWithoutBadge_typeInput[]
    upsert?: BadgeUpsertWithWhereUniqueWithoutBadge_typeInput | BadgeUpsertWithWhereUniqueWithoutBadge_typeInput[]
    createMany?: BadgeCreateManyBadge_typeInputEnvelope
    set?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    disconnect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    delete?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    update?: BadgeUpdateWithWhereUniqueWithoutBadge_typeInput | BadgeUpdateWithWhereUniqueWithoutBadge_typeInput[]
    updateMany?: BadgeUpdateManyWithWhereWithoutBadge_typeInput | BadgeUpdateManyWithWhereWithoutBadge_typeInput[]
    deleteMany?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
  }

  export type BadgeUncheckedUpdateManyWithoutBadge_typeNestedInput = {
    create?: XOR<BadgeCreateWithoutBadge_typeInput, BadgeUncheckedCreateWithoutBadge_typeInput> | BadgeCreateWithoutBadge_typeInput[] | BadgeUncheckedCreateWithoutBadge_typeInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutBadge_typeInput | BadgeCreateOrConnectWithoutBadge_typeInput[]
    upsert?: BadgeUpsertWithWhereUniqueWithoutBadge_typeInput | BadgeUpsertWithWhereUniqueWithoutBadge_typeInput[]
    createMany?: BadgeCreateManyBadge_typeInputEnvelope
    set?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    disconnect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    delete?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    update?: BadgeUpdateWithWhereUniqueWithoutBadge_typeInput | BadgeUpdateWithWhereUniqueWithoutBadge_typeInput[]
    updateMany?: BadgeUpdateManyWithWhereWithoutBadge_typeInput | BadgeUpdateManyWithWhereWithoutBadge_typeInput[]
    deleteMany?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBadgesInput = {
    create?: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBadgesInput
    connect?: UserWhereUniqueInput
  }

  export type ChallengeCreateNestedOneWithoutBadgesInput = {
    create?: XOR<ChallengeCreateWithoutBadgesInput, ChallengeUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutBadgesInput
    connect?: ChallengeWhereUniqueInput
  }

  export type BadgeTypeCreateNestedOneWithoutBadgesInput = {
    create?: XOR<BadgeTypeCreateWithoutBadgesInput, BadgeTypeUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: BadgeTypeCreateOrConnectWithoutBadgesInput
    connect?: BadgeTypeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBadgesNestedInput = {
    create?: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBadgesInput
    upsert?: UserUpsertWithoutBadgesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBadgesInput, UserUpdateWithoutBadgesInput>, UserUncheckedUpdateWithoutBadgesInput>
  }

  export type ChallengeUpdateOneRequiredWithoutBadgesNestedInput = {
    create?: XOR<ChallengeCreateWithoutBadgesInput, ChallengeUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutBadgesInput
    upsert?: ChallengeUpsertWithoutBadgesInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutBadgesInput, ChallengeUpdateWithoutBadgesInput>, ChallengeUncheckedUpdateWithoutBadgesInput>
  }

  export type BadgeTypeUpdateOneRequiredWithoutBadgesNestedInput = {
    create?: XOR<BadgeTypeCreateWithoutBadgesInput, BadgeTypeUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: BadgeTypeCreateOrConnectWithoutBadgesInput
    upsert?: BadgeTypeUpsertWithoutBadgesInput
    connect?: BadgeTypeWhereUniqueInput
    update?: XOR<XOR<BadgeTypeUpdateToOneWithWhereWithoutBadgesInput, BadgeTypeUpdateWithoutBadgesInput>, BadgeTypeUncheckedUpdateWithoutBadgesInput>
  }

  export type UserCreateNestedOneWithoutStamp_booksInput = {
    create?: XOR<UserCreateWithoutStamp_booksInput, UserUncheckedCreateWithoutStamp_booksInput>
    connectOrCreate?: UserCreateOrConnectWithoutStamp_booksInput
    connect?: UserWhereUniqueInput
  }

  export type CafeCreateNestedOneWithoutStamp_booksInput = {
    create?: XOR<CafeCreateWithoutStamp_booksInput, CafeUncheckedCreateWithoutStamp_booksInput>
    connectOrCreate?: CafeCreateOrConnectWithoutStamp_booksInput
    connect?: CafeWhereUniqueInput
  }

  export type StampCreateNestedManyWithoutStamp_bookInput = {
    create?: XOR<StampCreateWithoutStamp_bookInput, StampUncheckedCreateWithoutStamp_bookInput> | StampCreateWithoutStamp_bookInput[] | StampUncheckedCreateWithoutStamp_bookInput[]
    connectOrCreate?: StampCreateOrConnectWithoutStamp_bookInput | StampCreateOrConnectWithoutStamp_bookInput[]
    createMany?: StampCreateManyStamp_bookInputEnvelope
    connect?: StampWhereUniqueInput | StampWhereUniqueInput[]
  }

  export type PointTransactionCreateNestedManyWithoutStamp_bookInput = {
    create?: XOR<PointTransactionCreateWithoutStamp_bookInput, PointTransactionUncheckedCreateWithoutStamp_bookInput> | PointTransactionCreateWithoutStamp_bookInput[] | PointTransactionUncheckedCreateWithoutStamp_bookInput[]
    connectOrCreate?: PointTransactionCreateOrConnectWithoutStamp_bookInput | PointTransactionCreateOrConnectWithoutStamp_bookInput[]
    createMany?: PointTransactionCreateManyStamp_bookInputEnvelope
    connect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
  }

  export type StampUncheckedCreateNestedManyWithoutStamp_bookInput = {
    create?: XOR<StampCreateWithoutStamp_bookInput, StampUncheckedCreateWithoutStamp_bookInput> | StampCreateWithoutStamp_bookInput[] | StampUncheckedCreateWithoutStamp_bookInput[]
    connectOrCreate?: StampCreateOrConnectWithoutStamp_bookInput | StampCreateOrConnectWithoutStamp_bookInput[]
    createMany?: StampCreateManyStamp_bookInputEnvelope
    connect?: StampWhereUniqueInput | StampWhereUniqueInput[]
  }

  export type PointTransactionUncheckedCreateNestedManyWithoutStamp_bookInput = {
    create?: XOR<PointTransactionCreateWithoutStamp_bookInput, PointTransactionUncheckedCreateWithoutStamp_bookInput> | PointTransactionCreateWithoutStamp_bookInput[] | PointTransactionUncheckedCreateWithoutStamp_bookInput[]
    connectOrCreate?: PointTransactionCreateOrConnectWithoutStamp_bookInput | PointTransactionCreateOrConnectWithoutStamp_bookInput[]
    createMany?: PointTransactionCreateManyStamp_bookInputEnvelope
    connect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutStamp_booksNestedInput = {
    create?: XOR<UserCreateWithoutStamp_booksInput, UserUncheckedCreateWithoutStamp_booksInput>
    connectOrCreate?: UserCreateOrConnectWithoutStamp_booksInput
    upsert?: UserUpsertWithoutStamp_booksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStamp_booksInput, UserUpdateWithoutStamp_booksInput>, UserUncheckedUpdateWithoutStamp_booksInput>
  }

  export type CafeUpdateOneRequiredWithoutStamp_booksNestedInput = {
    create?: XOR<CafeCreateWithoutStamp_booksInput, CafeUncheckedCreateWithoutStamp_booksInput>
    connectOrCreate?: CafeCreateOrConnectWithoutStamp_booksInput
    upsert?: CafeUpsertWithoutStamp_booksInput
    connect?: CafeWhereUniqueInput
    update?: XOR<XOR<CafeUpdateToOneWithWhereWithoutStamp_booksInput, CafeUpdateWithoutStamp_booksInput>, CafeUncheckedUpdateWithoutStamp_booksInput>
  }

  export type StampUpdateManyWithoutStamp_bookNestedInput = {
    create?: XOR<StampCreateWithoutStamp_bookInput, StampUncheckedCreateWithoutStamp_bookInput> | StampCreateWithoutStamp_bookInput[] | StampUncheckedCreateWithoutStamp_bookInput[]
    connectOrCreate?: StampCreateOrConnectWithoutStamp_bookInput | StampCreateOrConnectWithoutStamp_bookInput[]
    upsert?: StampUpsertWithWhereUniqueWithoutStamp_bookInput | StampUpsertWithWhereUniqueWithoutStamp_bookInput[]
    createMany?: StampCreateManyStamp_bookInputEnvelope
    set?: StampWhereUniqueInput | StampWhereUniqueInput[]
    disconnect?: StampWhereUniqueInput | StampWhereUniqueInput[]
    delete?: StampWhereUniqueInput | StampWhereUniqueInput[]
    connect?: StampWhereUniqueInput | StampWhereUniqueInput[]
    update?: StampUpdateWithWhereUniqueWithoutStamp_bookInput | StampUpdateWithWhereUniqueWithoutStamp_bookInput[]
    updateMany?: StampUpdateManyWithWhereWithoutStamp_bookInput | StampUpdateManyWithWhereWithoutStamp_bookInput[]
    deleteMany?: StampScalarWhereInput | StampScalarWhereInput[]
  }

  export type PointTransactionUpdateManyWithoutStamp_bookNestedInput = {
    create?: XOR<PointTransactionCreateWithoutStamp_bookInput, PointTransactionUncheckedCreateWithoutStamp_bookInput> | PointTransactionCreateWithoutStamp_bookInput[] | PointTransactionUncheckedCreateWithoutStamp_bookInput[]
    connectOrCreate?: PointTransactionCreateOrConnectWithoutStamp_bookInput | PointTransactionCreateOrConnectWithoutStamp_bookInput[]
    upsert?: PointTransactionUpsertWithWhereUniqueWithoutStamp_bookInput | PointTransactionUpsertWithWhereUniqueWithoutStamp_bookInput[]
    createMany?: PointTransactionCreateManyStamp_bookInputEnvelope
    set?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    disconnect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    delete?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    connect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    update?: PointTransactionUpdateWithWhereUniqueWithoutStamp_bookInput | PointTransactionUpdateWithWhereUniqueWithoutStamp_bookInput[]
    updateMany?: PointTransactionUpdateManyWithWhereWithoutStamp_bookInput | PointTransactionUpdateManyWithWhereWithoutStamp_bookInput[]
    deleteMany?: PointTransactionScalarWhereInput | PointTransactionScalarWhereInput[]
  }

  export type StampUncheckedUpdateManyWithoutStamp_bookNestedInput = {
    create?: XOR<StampCreateWithoutStamp_bookInput, StampUncheckedCreateWithoutStamp_bookInput> | StampCreateWithoutStamp_bookInput[] | StampUncheckedCreateWithoutStamp_bookInput[]
    connectOrCreate?: StampCreateOrConnectWithoutStamp_bookInput | StampCreateOrConnectWithoutStamp_bookInput[]
    upsert?: StampUpsertWithWhereUniqueWithoutStamp_bookInput | StampUpsertWithWhereUniqueWithoutStamp_bookInput[]
    createMany?: StampCreateManyStamp_bookInputEnvelope
    set?: StampWhereUniqueInput | StampWhereUniqueInput[]
    disconnect?: StampWhereUniqueInput | StampWhereUniqueInput[]
    delete?: StampWhereUniqueInput | StampWhereUniqueInput[]
    connect?: StampWhereUniqueInput | StampWhereUniqueInput[]
    update?: StampUpdateWithWhereUniqueWithoutStamp_bookInput | StampUpdateWithWhereUniqueWithoutStamp_bookInput[]
    updateMany?: StampUpdateManyWithWhereWithoutStamp_bookInput | StampUpdateManyWithWhereWithoutStamp_bookInput[]
    deleteMany?: StampScalarWhereInput | StampScalarWhereInput[]
  }

  export type PointTransactionUncheckedUpdateManyWithoutStamp_bookNestedInput = {
    create?: XOR<PointTransactionCreateWithoutStamp_bookInput, PointTransactionUncheckedCreateWithoutStamp_bookInput> | PointTransactionCreateWithoutStamp_bookInput[] | PointTransactionUncheckedCreateWithoutStamp_bookInput[]
    connectOrCreate?: PointTransactionCreateOrConnectWithoutStamp_bookInput | PointTransactionCreateOrConnectWithoutStamp_bookInput[]
    upsert?: PointTransactionUpsertWithWhereUniqueWithoutStamp_bookInput | PointTransactionUpsertWithWhereUniqueWithoutStamp_bookInput[]
    createMany?: PointTransactionCreateManyStamp_bookInputEnvelope
    set?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    disconnect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    delete?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    connect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    update?: PointTransactionUpdateWithWhereUniqueWithoutStamp_bookInput | PointTransactionUpdateWithWhereUniqueWithoutStamp_bookInput[]
    updateMany?: PointTransactionUpdateManyWithWhereWithoutStamp_bookInput | PointTransactionUpdateManyWithWhereWithoutStamp_bookInput[]
    deleteMany?: PointTransactionScalarWhereInput | PointTransactionScalarWhereInput[]
  }

  export type StampBookCreateNestedOneWithoutStampsInput = {
    create?: XOR<StampBookCreateWithoutStampsInput, StampBookUncheckedCreateWithoutStampsInput>
    connectOrCreate?: StampBookCreateOrConnectWithoutStampsInput
    connect?: StampBookWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StampBookUpdateOneRequiredWithoutStampsNestedInput = {
    create?: XOR<StampBookCreateWithoutStampsInput, StampBookUncheckedCreateWithoutStampsInput>
    connectOrCreate?: StampBookCreateOrConnectWithoutStampsInput
    upsert?: StampBookUpsertWithoutStampsInput
    connect?: StampBookWhereUniqueInput
    update?: XOR<XOR<StampBookUpdateToOneWithWhereWithoutStampsInput, StampBookUpdateWithoutStampsInput>, StampBookUncheckedUpdateWithoutStampsInput>
  }

  export type UserCreateNestedOneWithoutPoint_transactionsInput = {
    create?: XOR<UserCreateWithoutPoint_transactionsInput, UserUncheckedCreateWithoutPoint_transactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPoint_transactionsInput
    connect?: UserWhereUniqueInput
  }

  export type StampBookCreateNestedOneWithoutPoint_transactionsInput = {
    create?: XOR<StampBookCreateWithoutPoint_transactionsInput, StampBookUncheckedCreateWithoutPoint_transactionsInput>
    connectOrCreate?: StampBookCreateOrConnectWithoutPoint_transactionsInput
    connect?: StampBookWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPoint_transactionsNestedInput = {
    create?: XOR<UserCreateWithoutPoint_transactionsInput, UserUncheckedCreateWithoutPoint_transactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPoint_transactionsInput
    upsert?: UserUpsertWithoutPoint_transactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPoint_transactionsInput, UserUpdateWithoutPoint_transactionsInput>, UserUncheckedUpdateWithoutPoint_transactionsInput>
  }

  export type StampBookUpdateOneRequiredWithoutPoint_transactionsNestedInput = {
    create?: XOR<StampBookCreateWithoutPoint_transactionsInput, StampBookUncheckedCreateWithoutPoint_transactionsInput>
    connectOrCreate?: StampBookCreateOrConnectWithoutPoint_transactionsInput
    upsert?: StampBookUpsertWithoutPoint_transactionsInput
    connect?: StampBookWhereUniqueInput
    update?: XOR<XOR<StampBookUpdateToOneWithWhereWithoutPoint_transactionsInput, StampBookUpdateWithoutPoint_transactionsInput>, StampBookUncheckedUpdateWithoutPoint_transactionsInput>
  }

  export type CafeMenuCreateNestedManyWithoutCafeInput = {
    create?: XOR<CafeMenuCreateWithoutCafeInput, CafeMenuUncheckedCreateWithoutCafeInput> | CafeMenuCreateWithoutCafeInput[] | CafeMenuUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: CafeMenuCreateOrConnectWithoutCafeInput | CafeMenuCreateOrConnectWithoutCafeInput[]
    createMany?: CafeMenuCreateManyCafeInputEnvelope
    connect?: CafeMenuWhereUniqueInput | CafeMenuWhereUniqueInput[]
  }

  export type CafePhotoCreateNestedManyWithoutCafeInput = {
    create?: XOR<CafePhotoCreateWithoutCafeInput, CafePhotoUncheckedCreateWithoutCafeInput> | CafePhotoCreateWithoutCafeInput[] | CafePhotoUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: CafePhotoCreateOrConnectWithoutCafeInput | CafePhotoCreateOrConnectWithoutCafeInput[]
    createMany?: CafePhotoCreateManyCafeInputEnvelope
    connect?: CafePhotoWhereUniqueInput | CafePhotoWhereUniqueInput[]
  }

  export type ChallengeAvailableCafeCreateNestedManyWithoutCafeInput = {
    create?: XOR<ChallengeAvailableCafeCreateWithoutCafeInput, ChallengeAvailableCafeUncheckedCreateWithoutCafeInput> | ChallengeAvailableCafeCreateWithoutCafeInput[] | ChallengeAvailableCafeUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: ChallengeAvailableCafeCreateOrConnectWithoutCafeInput | ChallengeAvailableCafeCreateOrConnectWithoutCafeInput[]
    createMany?: ChallengeAvailableCafeCreateManyCafeInputEnvelope
    connect?: ChallengeAvailableCafeWhereUniqueInput | ChallengeAvailableCafeWhereUniqueInput[]
  }

  export type StampBookCreateNestedManyWithoutCafeInput = {
    create?: XOR<StampBookCreateWithoutCafeInput, StampBookUncheckedCreateWithoutCafeInput> | StampBookCreateWithoutCafeInput[] | StampBookUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: StampBookCreateOrConnectWithoutCafeInput | StampBookCreateOrConnectWithoutCafeInput[]
    createMany?: StampBookCreateManyCafeInputEnvelope
    connect?: StampBookWhereUniqueInput | StampBookWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutCafeInput = {
    create?: XOR<ReviewCreateWithoutCafeInput, ReviewUncheckedCreateWithoutCafeInput> | ReviewCreateWithoutCafeInput[] | ReviewUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCafeInput | ReviewCreateOrConnectWithoutCafeInput[]
    createMany?: ReviewCreateManyCafeInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutCafeInput = {
    create?: XOR<NotificationCreateWithoutCafeInput, NotificationUncheckedCreateWithoutCafeInput> | NotificationCreateWithoutCafeInput[] | NotificationUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCafeInput | NotificationCreateOrConnectWithoutCafeInput[]
    createMany?: NotificationCreateManyCafeInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CouponCreateNestedManyWithoutCafeInput = {
    create?: XOR<CouponCreateWithoutCafeInput, CouponUncheckedCreateWithoutCafeInput> | CouponCreateWithoutCafeInput[] | CouponUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutCafeInput | CouponCreateOrConnectWithoutCafeInput[]
    createMany?: CouponCreateManyCafeInputEnvelope
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
  }

  export type CafeMenuUncheckedCreateNestedManyWithoutCafeInput = {
    create?: XOR<CafeMenuCreateWithoutCafeInput, CafeMenuUncheckedCreateWithoutCafeInput> | CafeMenuCreateWithoutCafeInput[] | CafeMenuUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: CafeMenuCreateOrConnectWithoutCafeInput | CafeMenuCreateOrConnectWithoutCafeInput[]
    createMany?: CafeMenuCreateManyCafeInputEnvelope
    connect?: CafeMenuWhereUniqueInput | CafeMenuWhereUniqueInput[]
  }

  export type CafePhotoUncheckedCreateNestedManyWithoutCafeInput = {
    create?: XOR<CafePhotoCreateWithoutCafeInput, CafePhotoUncheckedCreateWithoutCafeInput> | CafePhotoCreateWithoutCafeInput[] | CafePhotoUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: CafePhotoCreateOrConnectWithoutCafeInput | CafePhotoCreateOrConnectWithoutCafeInput[]
    createMany?: CafePhotoCreateManyCafeInputEnvelope
    connect?: CafePhotoWhereUniqueInput | CafePhotoWhereUniqueInput[]
  }

  export type ChallengeAvailableCafeUncheckedCreateNestedManyWithoutCafeInput = {
    create?: XOR<ChallengeAvailableCafeCreateWithoutCafeInput, ChallengeAvailableCafeUncheckedCreateWithoutCafeInput> | ChallengeAvailableCafeCreateWithoutCafeInput[] | ChallengeAvailableCafeUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: ChallengeAvailableCafeCreateOrConnectWithoutCafeInput | ChallengeAvailableCafeCreateOrConnectWithoutCafeInput[]
    createMany?: ChallengeAvailableCafeCreateManyCafeInputEnvelope
    connect?: ChallengeAvailableCafeWhereUniqueInput | ChallengeAvailableCafeWhereUniqueInput[]
  }

  export type StampBookUncheckedCreateNestedManyWithoutCafeInput = {
    create?: XOR<StampBookCreateWithoutCafeInput, StampBookUncheckedCreateWithoutCafeInput> | StampBookCreateWithoutCafeInput[] | StampBookUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: StampBookCreateOrConnectWithoutCafeInput | StampBookCreateOrConnectWithoutCafeInput[]
    createMany?: StampBookCreateManyCafeInputEnvelope
    connect?: StampBookWhereUniqueInput | StampBookWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutCafeInput = {
    create?: XOR<ReviewCreateWithoutCafeInput, ReviewUncheckedCreateWithoutCafeInput> | ReviewCreateWithoutCafeInput[] | ReviewUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCafeInput | ReviewCreateOrConnectWithoutCafeInput[]
    createMany?: ReviewCreateManyCafeInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutCafeInput = {
    create?: XOR<NotificationCreateWithoutCafeInput, NotificationUncheckedCreateWithoutCafeInput> | NotificationCreateWithoutCafeInput[] | NotificationUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCafeInput | NotificationCreateOrConnectWithoutCafeInput[]
    createMany?: NotificationCreateManyCafeInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CouponUncheckedCreateNestedManyWithoutCafeInput = {
    create?: XOR<CouponCreateWithoutCafeInput, CouponUncheckedCreateWithoutCafeInput> | CouponCreateWithoutCafeInput[] | CouponUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutCafeInput | CouponCreateOrConnectWithoutCafeInput[]
    createMany?: CouponCreateManyCafeInputEnvelope
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
  }

  export type EnumCafeStatusFieldUpdateOperationsInput = {
    set?: $Enums.CafeStatus
  }

  export type CafeMenuUpdateManyWithoutCafeNestedInput = {
    create?: XOR<CafeMenuCreateWithoutCafeInput, CafeMenuUncheckedCreateWithoutCafeInput> | CafeMenuCreateWithoutCafeInput[] | CafeMenuUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: CafeMenuCreateOrConnectWithoutCafeInput | CafeMenuCreateOrConnectWithoutCafeInput[]
    upsert?: CafeMenuUpsertWithWhereUniqueWithoutCafeInput | CafeMenuUpsertWithWhereUniqueWithoutCafeInput[]
    createMany?: CafeMenuCreateManyCafeInputEnvelope
    set?: CafeMenuWhereUniqueInput | CafeMenuWhereUniqueInput[]
    disconnect?: CafeMenuWhereUniqueInput | CafeMenuWhereUniqueInput[]
    delete?: CafeMenuWhereUniqueInput | CafeMenuWhereUniqueInput[]
    connect?: CafeMenuWhereUniqueInput | CafeMenuWhereUniqueInput[]
    update?: CafeMenuUpdateWithWhereUniqueWithoutCafeInput | CafeMenuUpdateWithWhereUniqueWithoutCafeInput[]
    updateMany?: CafeMenuUpdateManyWithWhereWithoutCafeInput | CafeMenuUpdateManyWithWhereWithoutCafeInput[]
    deleteMany?: CafeMenuScalarWhereInput | CafeMenuScalarWhereInput[]
  }

  export type CafePhotoUpdateManyWithoutCafeNestedInput = {
    create?: XOR<CafePhotoCreateWithoutCafeInput, CafePhotoUncheckedCreateWithoutCafeInput> | CafePhotoCreateWithoutCafeInput[] | CafePhotoUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: CafePhotoCreateOrConnectWithoutCafeInput | CafePhotoCreateOrConnectWithoutCafeInput[]
    upsert?: CafePhotoUpsertWithWhereUniqueWithoutCafeInput | CafePhotoUpsertWithWhereUniqueWithoutCafeInput[]
    createMany?: CafePhotoCreateManyCafeInputEnvelope
    set?: CafePhotoWhereUniqueInput | CafePhotoWhereUniqueInput[]
    disconnect?: CafePhotoWhereUniqueInput | CafePhotoWhereUniqueInput[]
    delete?: CafePhotoWhereUniqueInput | CafePhotoWhereUniqueInput[]
    connect?: CafePhotoWhereUniqueInput | CafePhotoWhereUniqueInput[]
    update?: CafePhotoUpdateWithWhereUniqueWithoutCafeInput | CafePhotoUpdateWithWhereUniqueWithoutCafeInput[]
    updateMany?: CafePhotoUpdateManyWithWhereWithoutCafeInput | CafePhotoUpdateManyWithWhereWithoutCafeInput[]
    deleteMany?: CafePhotoScalarWhereInput | CafePhotoScalarWhereInput[]
  }

  export type ChallengeAvailableCafeUpdateManyWithoutCafeNestedInput = {
    create?: XOR<ChallengeAvailableCafeCreateWithoutCafeInput, ChallengeAvailableCafeUncheckedCreateWithoutCafeInput> | ChallengeAvailableCafeCreateWithoutCafeInput[] | ChallengeAvailableCafeUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: ChallengeAvailableCafeCreateOrConnectWithoutCafeInput | ChallengeAvailableCafeCreateOrConnectWithoutCafeInput[]
    upsert?: ChallengeAvailableCafeUpsertWithWhereUniqueWithoutCafeInput | ChallengeAvailableCafeUpsertWithWhereUniqueWithoutCafeInput[]
    createMany?: ChallengeAvailableCafeCreateManyCafeInputEnvelope
    set?: ChallengeAvailableCafeWhereUniqueInput | ChallengeAvailableCafeWhereUniqueInput[]
    disconnect?: ChallengeAvailableCafeWhereUniqueInput | ChallengeAvailableCafeWhereUniqueInput[]
    delete?: ChallengeAvailableCafeWhereUniqueInput | ChallengeAvailableCafeWhereUniqueInput[]
    connect?: ChallengeAvailableCafeWhereUniqueInput | ChallengeAvailableCafeWhereUniqueInput[]
    update?: ChallengeAvailableCafeUpdateWithWhereUniqueWithoutCafeInput | ChallengeAvailableCafeUpdateWithWhereUniqueWithoutCafeInput[]
    updateMany?: ChallengeAvailableCafeUpdateManyWithWhereWithoutCafeInput | ChallengeAvailableCafeUpdateManyWithWhereWithoutCafeInput[]
    deleteMany?: ChallengeAvailableCafeScalarWhereInput | ChallengeAvailableCafeScalarWhereInput[]
  }

  export type StampBookUpdateManyWithoutCafeNestedInput = {
    create?: XOR<StampBookCreateWithoutCafeInput, StampBookUncheckedCreateWithoutCafeInput> | StampBookCreateWithoutCafeInput[] | StampBookUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: StampBookCreateOrConnectWithoutCafeInput | StampBookCreateOrConnectWithoutCafeInput[]
    upsert?: StampBookUpsertWithWhereUniqueWithoutCafeInput | StampBookUpsertWithWhereUniqueWithoutCafeInput[]
    createMany?: StampBookCreateManyCafeInputEnvelope
    set?: StampBookWhereUniqueInput | StampBookWhereUniqueInput[]
    disconnect?: StampBookWhereUniqueInput | StampBookWhereUniqueInput[]
    delete?: StampBookWhereUniqueInput | StampBookWhereUniqueInput[]
    connect?: StampBookWhereUniqueInput | StampBookWhereUniqueInput[]
    update?: StampBookUpdateWithWhereUniqueWithoutCafeInput | StampBookUpdateWithWhereUniqueWithoutCafeInput[]
    updateMany?: StampBookUpdateManyWithWhereWithoutCafeInput | StampBookUpdateManyWithWhereWithoutCafeInput[]
    deleteMany?: StampBookScalarWhereInput | StampBookScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutCafeNestedInput = {
    create?: XOR<ReviewCreateWithoutCafeInput, ReviewUncheckedCreateWithoutCafeInput> | ReviewCreateWithoutCafeInput[] | ReviewUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCafeInput | ReviewCreateOrConnectWithoutCafeInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutCafeInput | ReviewUpsertWithWhereUniqueWithoutCafeInput[]
    createMany?: ReviewCreateManyCafeInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutCafeInput | ReviewUpdateWithWhereUniqueWithoutCafeInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutCafeInput | ReviewUpdateManyWithWhereWithoutCafeInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutCafeNestedInput = {
    create?: XOR<NotificationCreateWithoutCafeInput, NotificationUncheckedCreateWithoutCafeInput> | NotificationCreateWithoutCafeInput[] | NotificationUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCafeInput | NotificationCreateOrConnectWithoutCafeInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCafeInput | NotificationUpsertWithWhereUniqueWithoutCafeInput[]
    createMany?: NotificationCreateManyCafeInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCafeInput | NotificationUpdateWithWhereUniqueWithoutCafeInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCafeInput | NotificationUpdateManyWithWhereWithoutCafeInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CouponUpdateManyWithoutCafeNestedInput = {
    create?: XOR<CouponCreateWithoutCafeInput, CouponUncheckedCreateWithoutCafeInput> | CouponCreateWithoutCafeInput[] | CouponUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutCafeInput | CouponCreateOrConnectWithoutCafeInput[]
    upsert?: CouponUpsertWithWhereUniqueWithoutCafeInput | CouponUpsertWithWhereUniqueWithoutCafeInput[]
    createMany?: CouponCreateManyCafeInputEnvelope
    set?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    disconnect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    delete?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    update?: CouponUpdateWithWhereUniqueWithoutCafeInput | CouponUpdateWithWhereUniqueWithoutCafeInput[]
    updateMany?: CouponUpdateManyWithWhereWithoutCafeInput | CouponUpdateManyWithWhereWithoutCafeInput[]
    deleteMany?: CouponScalarWhereInput | CouponScalarWhereInput[]
  }

  export type CafeMenuUncheckedUpdateManyWithoutCafeNestedInput = {
    create?: XOR<CafeMenuCreateWithoutCafeInput, CafeMenuUncheckedCreateWithoutCafeInput> | CafeMenuCreateWithoutCafeInput[] | CafeMenuUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: CafeMenuCreateOrConnectWithoutCafeInput | CafeMenuCreateOrConnectWithoutCafeInput[]
    upsert?: CafeMenuUpsertWithWhereUniqueWithoutCafeInput | CafeMenuUpsertWithWhereUniqueWithoutCafeInput[]
    createMany?: CafeMenuCreateManyCafeInputEnvelope
    set?: CafeMenuWhereUniqueInput | CafeMenuWhereUniqueInput[]
    disconnect?: CafeMenuWhereUniqueInput | CafeMenuWhereUniqueInput[]
    delete?: CafeMenuWhereUniqueInput | CafeMenuWhereUniqueInput[]
    connect?: CafeMenuWhereUniqueInput | CafeMenuWhereUniqueInput[]
    update?: CafeMenuUpdateWithWhereUniqueWithoutCafeInput | CafeMenuUpdateWithWhereUniqueWithoutCafeInput[]
    updateMany?: CafeMenuUpdateManyWithWhereWithoutCafeInput | CafeMenuUpdateManyWithWhereWithoutCafeInput[]
    deleteMany?: CafeMenuScalarWhereInput | CafeMenuScalarWhereInput[]
  }

  export type CafePhotoUncheckedUpdateManyWithoutCafeNestedInput = {
    create?: XOR<CafePhotoCreateWithoutCafeInput, CafePhotoUncheckedCreateWithoutCafeInput> | CafePhotoCreateWithoutCafeInput[] | CafePhotoUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: CafePhotoCreateOrConnectWithoutCafeInput | CafePhotoCreateOrConnectWithoutCafeInput[]
    upsert?: CafePhotoUpsertWithWhereUniqueWithoutCafeInput | CafePhotoUpsertWithWhereUniqueWithoutCafeInput[]
    createMany?: CafePhotoCreateManyCafeInputEnvelope
    set?: CafePhotoWhereUniqueInput | CafePhotoWhereUniqueInput[]
    disconnect?: CafePhotoWhereUniqueInput | CafePhotoWhereUniqueInput[]
    delete?: CafePhotoWhereUniqueInput | CafePhotoWhereUniqueInput[]
    connect?: CafePhotoWhereUniqueInput | CafePhotoWhereUniqueInput[]
    update?: CafePhotoUpdateWithWhereUniqueWithoutCafeInput | CafePhotoUpdateWithWhereUniqueWithoutCafeInput[]
    updateMany?: CafePhotoUpdateManyWithWhereWithoutCafeInput | CafePhotoUpdateManyWithWhereWithoutCafeInput[]
    deleteMany?: CafePhotoScalarWhereInput | CafePhotoScalarWhereInput[]
  }

  export type ChallengeAvailableCafeUncheckedUpdateManyWithoutCafeNestedInput = {
    create?: XOR<ChallengeAvailableCafeCreateWithoutCafeInput, ChallengeAvailableCafeUncheckedCreateWithoutCafeInput> | ChallengeAvailableCafeCreateWithoutCafeInput[] | ChallengeAvailableCafeUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: ChallengeAvailableCafeCreateOrConnectWithoutCafeInput | ChallengeAvailableCafeCreateOrConnectWithoutCafeInput[]
    upsert?: ChallengeAvailableCafeUpsertWithWhereUniqueWithoutCafeInput | ChallengeAvailableCafeUpsertWithWhereUniqueWithoutCafeInput[]
    createMany?: ChallengeAvailableCafeCreateManyCafeInputEnvelope
    set?: ChallengeAvailableCafeWhereUniqueInput | ChallengeAvailableCafeWhereUniqueInput[]
    disconnect?: ChallengeAvailableCafeWhereUniqueInput | ChallengeAvailableCafeWhereUniqueInput[]
    delete?: ChallengeAvailableCafeWhereUniqueInput | ChallengeAvailableCafeWhereUniqueInput[]
    connect?: ChallengeAvailableCafeWhereUniqueInput | ChallengeAvailableCafeWhereUniqueInput[]
    update?: ChallengeAvailableCafeUpdateWithWhereUniqueWithoutCafeInput | ChallengeAvailableCafeUpdateWithWhereUniqueWithoutCafeInput[]
    updateMany?: ChallengeAvailableCafeUpdateManyWithWhereWithoutCafeInput | ChallengeAvailableCafeUpdateManyWithWhereWithoutCafeInput[]
    deleteMany?: ChallengeAvailableCafeScalarWhereInput | ChallengeAvailableCafeScalarWhereInput[]
  }

  export type StampBookUncheckedUpdateManyWithoutCafeNestedInput = {
    create?: XOR<StampBookCreateWithoutCafeInput, StampBookUncheckedCreateWithoutCafeInput> | StampBookCreateWithoutCafeInput[] | StampBookUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: StampBookCreateOrConnectWithoutCafeInput | StampBookCreateOrConnectWithoutCafeInput[]
    upsert?: StampBookUpsertWithWhereUniqueWithoutCafeInput | StampBookUpsertWithWhereUniqueWithoutCafeInput[]
    createMany?: StampBookCreateManyCafeInputEnvelope
    set?: StampBookWhereUniqueInput | StampBookWhereUniqueInput[]
    disconnect?: StampBookWhereUniqueInput | StampBookWhereUniqueInput[]
    delete?: StampBookWhereUniqueInput | StampBookWhereUniqueInput[]
    connect?: StampBookWhereUniqueInput | StampBookWhereUniqueInput[]
    update?: StampBookUpdateWithWhereUniqueWithoutCafeInput | StampBookUpdateWithWhereUniqueWithoutCafeInput[]
    updateMany?: StampBookUpdateManyWithWhereWithoutCafeInput | StampBookUpdateManyWithWhereWithoutCafeInput[]
    deleteMany?: StampBookScalarWhereInput | StampBookScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutCafeNestedInput = {
    create?: XOR<ReviewCreateWithoutCafeInput, ReviewUncheckedCreateWithoutCafeInput> | ReviewCreateWithoutCafeInput[] | ReviewUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCafeInput | ReviewCreateOrConnectWithoutCafeInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutCafeInput | ReviewUpsertWithWhereUniqueWithoutCafeInput[]
    createMany?: ReviewCreateManyCafeInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutCafeInput | ReviewUpdateWithWhereUniqueWithoutCafeInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutCafeInput | ReviewUpdateManyWithWhereWithoutCafeInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutCafeNestedInput = {
    create?: XOR<NotificationCreateWithoutCafeInput, NotificationUncheckedCreateWithoutCafeInput> | NotificationCreateWithoutCafeInput[] | NotificationUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCafeInput | NotificationCreateOrConnectWithoutCafeInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCafeInput | NotificationUpsertWithWhereUniqueWithoutCafeInput[]
    createMany?: NotificationCreateManyCafeInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCafeInput | NotificationUpdateWithWhereUniqueWithoutCafeInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCafeInput | NotificationUpdateManyWithWhereWithoutCafeInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CouponUncheckedUpdateManyWithoutCafeNestedInput = {
    create?: XOR<CouponCreateWithoutCafeInput, CouponUncheckedCreateWithoutCafeInput> | CouponCreateWithoutCafeInput[] | CouponUncheckedCreateWithoutCafeInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutCafeInput | CouponCreateOrConnectWithoutCafeInput[]
    upsert?: CouponUpsertWithWhereUniqueWithoutCafeInput | CouponUpsertWithWhereUniqueWithoutCafeInput[]
    createMany?: CouponCreateManyCafeInputEnvelope
    set?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    disconnect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    delete?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    update?: CouponUpdateWithWhereUniqueWithoutCafeInput | CouponUpdateWithWhereUniqueWithoutCafeInput[]
    updateMany?: CouponUpdateManyWithWhereWithoutCafeInput | CouponUpdateManyWithWhereWithoutCafeInput[]
    deleteMany?: CouponScalarWhereInput | CouponScalarWhereInput[]
  }

  export type CafeCreateNestedOneWithoutMenuInput = {
    create?: XOR<CafeCreateWithoutMenuInput, CafeUncheckedCreateWithoutMenuInput>
    connectOrCreate?: CafeCreateOrConnectWithoutMenuInput
    connect?: CafeWhereUniqueInput
  }

  export type CafeUpdateOneRequiredWithoutMenuNestedInput = {
    create?: XOR<CafeCreateWithoutMenuInput, CafeUncheckedCreateWithoutMenuInput>
    connectOrCreate?: CafeCreateOrConnectWithoutMenuInput
    upsert?: CafeUpsertWithoutMenuInput
    connect?: CafeWhereUniqueInput
    update?: XOR<XOR<CafeUpdateToOneWithWhereWithoutMenuInput, CafeUpdateWithoutMenuInput>, CafeUncheckedUpdateWithoutMenuInput>
  }

  export type CafeCreateNestedOneWithoutPhotosInput = {
    create?: XOR<CafeCreateWithoutPhotosInput, CafeUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: CafeCreateOrConnectWithoutPhotosInput
    connect?: CafeWhereUniqueInput
  }

  export type CafeUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<CafeCreateWithoutPhotosInput, CafeUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: CafeCreateOrConnectWithoutPhotosInput
    upsert?: CafeUpsertWithoutPhotosInput
    connect?: CafeWhereUniqueInput
    update?: XOR<XOR<CafeUpdateToOneWithWhereWithoutPhotosInput, CafeUpdateWithoutPhotosInput>, CafeUncheckedUpdateWithoutPhotosInput>
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type CafeCreateNestedOneWithoutReviewsInput = {
    create?: XOR<CafeCreateWithoutReviewsInput, CafeUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CafeCreateOrConnectWithoutReviewsInput
    connect?: CafeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type CafeUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<CafeCreateWithoutReviewsInput, CafeUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CafeCreateOrConnectWithoutReviewsInput
    upsert?: CafeUpsertWithoutReviewsInput
    connect?: CafeWhereUniqueInput
    update?: XOR<XOR<CafeUpdateToOneWithWhereWithoutReviewsInput, CafeUpdateWithoutReviewsInput>, CafeUncheckedUpdateWithoutReviewsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type CafeCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<CafeCreateWithoutNotificationsInput, CafeUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CafeCreateOrConnectWithoutNotificationsInput
    connect?: CafeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type CafeUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<CafeCreateWithoutNotificationsInput, CafeUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CafeCreateOrConnectWithoutNotificationsInput
    upsert?: CafeUpsertWithoutNotificationsInput
    connect?: CafeWhereUniqueInput
    update?: XOR<XOR<CafeUpdateToOneWithWhereWithoutNotificationsInput, CafeUpdateWithoutNotificationsInput>, CafeUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutCouponsInput = {
    create?: XOR<UserCreateWithoutCouponsInput, UserUncheckedCreateWithoutCouponsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCouponsInput
    connect?: UserWhereUniqueInput
  }

  export type CafeCreateNestedOneWithoutCouponsInput = {
    create?: XOR<CafeCreateWithoutCouponsInput, CafeUncheckedCreateWithoutCouponsInput>
    connectOrCreate?: CafeCreateOrConnectWithoutCouponsInput
    connect?: CafeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCouponsNestedInput = {
    create?: XOR<UserCreateWithoutCouponsInput, UserUncheckedCreateWithoutCouponsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCouponsInput
    upsert?: UserUpsertWithoutCouponsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCouponsInput, UserUpdateWithoutCouponsInput>, UserUncheckedUpdateWithoutCouponsInput>
  }

  export type CafeUpdateOneRequiredWithoutCouponsNestedInput = {
    create?: XOR<CafeCreateWithoutCouponsInput, CafeUncheckedCreateWithoutCouponsInput>
    connectOrCreate?: CafeCreateOrConnectWithoutCouponsInput
    upsert?: CafeUpsertWithoutCouponsInput
    connect?: CafeWhereUniqueInput
    update?: XOR<XOR<CafeUpdateToOneWithWhereWithoutCouponsInput, CafeUpdateWithoutCouponsInput>, CafeUncheckedUpdateWithoutCouponsInput>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumCafeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CafeStatus | EnumCafeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CafeStatus[] | ListEnumCafeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CafeStatus[] | ListEnumCafeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCafeStatusFilter<$PrismaModel> | $Enums.CafeStatus
  }

  export type NestedEnumCafeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CafeStatus | EnumCafeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CafeStatus[] | ListEnumCafeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CafeStatus[] | ListEnumCafeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCafeStatusWithAggregatesFilter<$PrismaModel> | $Enums.CafeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCafeStatusFilter<$PrismaModel>
    _max?: NestedEnumCafeStatusFilter<$PrismaModel>
  }

  export type KakaoAccountCreateWithoutUserInput = {
    id?: bigint | number
    social_id: string
    created_at?: Date | string
  }

  export type KakaoAccountUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    social_id: string
    created_at?: Date | string
  }

  export type KakaoAccountCreateOrConnectWithoutUserInput = {
    where: KakaoAccountWhereUniqueInput
    create: XOR<KakaoAccountCreateWithoutUserInput, KakaoAccountUncheckedCreateWithoutUserInput>
  }

  export type KakaoAccountCreateManyUserInputEnvelope = {
    data: KakaoAccountCreateManyUserInput | KakaoAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAgreementCreateWithoutUserInput = {
    id?: bigint | number
    terms_agreed: boolean
    privacy_policy_agreed: boolean
    marketing_agreed: boolean
    location_permission: boolean
    agreed_at?: Date | string
  }

  export type UserAgreementUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    terms_agreed: boolean
    privacy_policy_agreed: boolean
    marketing_agreed: boolean
    location_permission: boolean
    agreed_at?: Date | string
  }

  export type UserAgreementCreateOrConnectWithoutUserInput = {
    where: UserAgreementWhereUniqueInput
    create: XOR<UserAgreementCreateWithoutUserInput, UserAgreementUncheckedCreateWithoutUserInput>
  }

  export type UserPreferenceCreateWithoutUserInput = {
    id?: bigint | number
    preferred_area: string
    preferred_keywords: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type UserPreferenceUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    preferred_area: string
    preferred_keywords: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type UserPreferenceCreateOrConnectWithoutUserInput = {
    where: UserPreferenceWhereUniqueInput
    create: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
  }

  export type UserPreferenceCreateManyUserInputEnvelope = {
    data: UserPreferenceCreateManyUserInput | UserPreferenceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VerificationCodeCreateWithoutUserInput = {
    id?: bigint | number
    phone_number: string
    code: string
    expires_at: Date | string
    verified: boolean
    created_at?: Date | string
  }

  export type VerificationCodeUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    phone_number: string
    code: string
    expires_at: Date | string
    verified: boolean
    created_at?: Date | string
  }

  export type VerificationCodeCreateOrConnectWithoutUserInput = {
    where: VerificationCodeWhereUniqueInput
    create: XOR<VerificationCodeCreateWithoutUserInput, VerificationCodeUncheckedCreateWithoutUserInput>
  }

  export type VerificationCodeCreateManyUserInputEnvelope = {
    data: VerificationCodeCreateManyUserInput | VerificationCodeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeParticipantCreateWithoutUserInput = {
    status: string
    joined_at: Date | string
    completed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    challenge: ChallengeCreateNestedOneWithoutParticipantsInput
  }

  export type ChallengeParticipantUncheckedCreateWithoutUserInput = {
    id?: number
    challenge_id: number
    status: string
    joined_at: Date | string
    completed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChallengeParticipantCreateOrConnectWithoutUserInput = {
    where: ChallengeParticipantWhereUniqueInput
    create: XOR<ChallengeParticipantCreateWithoutUserInput, ChallengeParticipantUncheckedCreateWithoutUserInput>
  }

  export type ChallengeParticipantCreateManyUserInputEnvelope = {
    data: ChallengeParticipantCreateManyUserInput | ChallengeParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BadgeCreateWithoutUserInput = {
    earned_at?: Date | string
    challenge: ChallengeCreateNestedOneWithoutBadgesInput
    badge_type: BadgeTypeCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateWithoutUserInput = {
    id?: number
    challenge_id: number
    badge_type_id: number
    earned_at?: Date | string
  }

  export type BadgeCreateOrConnectWithoutUserInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutUserInput, BadgeUncheckedCreateWithoutUserInput>
  }

  export type BadgeCreateManyUserInputEnvelope = {
    data: BadgeCreateManyUserInput | BadgeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StampBookCreateWithoutUserInput = {
    current_count: number
    goal_count: number
    reward_detail: string
    started_at: Date | string
    last_visited_at: Date | string
    expires_at: Date | string
    extended_at: Date | string
    expired_at: Date | string
    completed_at: Date | string
    converted_at: Date | string
    status: string
    is_completed: boolean
    is_converted: boolean
    created_at?: Date | string
    updated_at?: Date | string
    cafe: CafeCreateNestedOneWithoutStamp_booksInput
    stamps?: StampCreateNestedManyWithoutStamp_bookInput
    point_transactions?: PointTransactionCreateNestedManyWithoutStamp_bookInput
  }

  export type StampBookUncheckedCreateWithoutUserInput = {
    id?: number
    cafe_id: bigint | number
    current_count: number
    goal_count: number
    reward_detail: string
    started_at: Date | string
    last_visited_at: Date | string
    expires_at: Date | string
    extended_at: Date | string
    expired_at: Date | string
    completed_at: Date | string
    converted_at: Date | string
    status: string
    is_completed: boolean
    is_converted: boolean
    created_at?: Date | string
    updated_at?: Date | string
    stamps?: StampUncheckedCreateNestedManyWithoutStamp_bookInput
    point_transactions?: PointTransactionUncheckedCreateNestedManyWithoutStamp_bookInput
  }

  export type StampBookCreateOrConnectWithoutUserInput = {
    where: StampBookWhereUniqueInput
    create: XOR<StampBookCreateWithoutUserInput, StampBookUncheckedCreateWithoutUserInput>
  }

  export type StampBookCreateManyUserInputEnvelope = {
    data: StampBookCreateManyUserInput | StampBookCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PointTransactionCreateWithoutUserInput = {
    point: number
    type: string
    description: string
    created_at?: Date | string
    stamp_book: StampBookCreateNestedOneWithoutPoint_transactionsInput
  }

  export type PointTransactionUncheckedCreateWithoutUserInput = {
    id?: number
    stamp_book_id: number
    point: number
    type: string
    description: string
    created_at?: Date | string
  }

  export type PointTransactionCreateOrConnectWithoutUserInput = {
    where: PointTransactionWhereUniqueInput
    create: XOR<PointTransactionCreateWithoutUserInput, PointTransactionUncheckedCreateWithoutUserInput>
  }

  export type PointTransactionCreateManyUserInputEnvelope = {
    data: PointTransactionCreateManyUserInput | PointTransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    title: string
    content: string
    images: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    cafe: CafeCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: number
    cafe_id: bigint | number
    title: string
    content: string
    images: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    type: string
    title: string
    content: string
    is_read: boolean
    created_at?: Date | string
    cafe: CafeCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    cafe_id: bigint | number
    type: string
    title: string
    content: string
    is_read: boolean
    created_at?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CouponCreateWithoutUserInput = {
    type: string
    name: string
    status: string
    issued_at: Date | string
    expired_at: Date | string
    used_at: Date | string
    cafe: CafeCreateNestedOneWithoutCouponsInput
  }

  export type CouponUncheckedCreateWithoutUserInput = {
    id?: number
    cafe_id: bigint | number
    type: string
    name: string
    status: string
    issued_at: Date | string
    expired_at: Date | string
    used_at: Date | string
  }

  export type CouponCreateOrConnectWithoutUserInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutUserInput, CouponUncheckedCreateWithoutUserInput>
  }

  export type CouponCreateManyUserInputEnvelope = {
    data: CouponCreateManyUserInput | CouponCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type KakaoAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: KakaoAccountWhereUniqueInput
    update: XOR<KakaoAccountUpdateWithoutUserInput, KakaoAccountUncheckedUpdateWithoutUserInput>
    create: XOR<KakaoAccountCreateWithoutUserInput, KakaoAccountUncheckedCreateWithoutUserInput>
  }

  export type KakaoAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: KakaoAccountWhereUniqueInput
    data: XOR<KakaoAccountUpdateWithoutUserInput, KakaoAccountUncheckedUpdateWithoutUserInput>
  }

  export type KakaoAccountUpdateManyWithWhereWithoutUserInput = {
    where: KakaoAccountScalarWhereInput
    data: XOR<KakaoAccountUpdateManyMutationInput, KakaoAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type KakaoAccountScalarWhereInput = {
    AND?: KakaoAccountScalarWhereInput | KakaoAccountScalarWhereInput[]
    OR?: KakaoAccountScalarWhereInput[]
    NOT?: KakaoAccountScalarWhereInput | KakaoAccountScalarWhereInput[]
    id?: BigIntFilter<"KakaoAccount"> | bigint | number
    user_id?: BigIntFilter<"KakaoAccount"> | bigint | number
    social_id?: StringFilter<"KakaoAccount"> | string
    created_at?: DateTimeFilter<"KakaoAccount"> | Date | string
  }

  export type UserAgreementUpsertWithoutUserInput = {
    update: XOR<UserAgreementUpdateWithoutUserInput, UserAgreementUncheckedUpdateWithoutUserInput>
    create: XOR<UserAgreementCreateWithoutUserInput, UserAgreementUncheckedCreateWithoutUserInput>
    where?: UserAgreementWhereInput
  }

  export type UserAgreementUpdateToOneWithWhereWithoutUserInput = {
    where?: UserAgreementWhereInput
    data: XOR<UserAgreementUpdateWithoutUserInput, UserAgreementUncheckedUpdateWithoutUserInput>
  }

  export type UserAgreementUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    terms_agreed?: BoolFieldUpdateOperationsInput | boolean
    privacy_policy_agreed?: BoolFieldUpdateOperationsInput | boolean
    marketing_agreed?: BoolFieldUpdateOperationsInput | boolean
    location_permission?: BoolFieldUpdateOperationsInput | boolean
    agreed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAgreementUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    terms_agreed?: BoolFieldUpdateOperationsInput | boolean
    privacy_policy_agreed?: BoolFieldUpdateOperationsInput | boolean
    marketing_agreed?: BoolFieldUpdateOperationsInput | boolean
    location_permission?: BoolFieldUpdateOperationsInput | boolean
    agreed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferenceUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPreferenceWhereUniqueInput
    update: XOR<UserPreferenceUpdateWithoutUserInput, UserPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
  }

  export type UserPreferenceUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPreferenceWhereUniqueInput
    data: XOR<UserPreferenceUpdateWithoutUserInput, UserPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferenceUpdateManyWithWhereWithoutUserInput = {
    where: UserPreferenceScalarWhereInput
    data: XOR<UserPreferenceUpdateManyMutationInput, UserPreferenceUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPreferenceScalarWhereInput = {
    AND?: UserPreferenceScalarWhereInput | UserPreferenceScalarWhereInput[]
    OR?: UserPreferenceScalarWhereInput[]
    NOT?: UserPreferenceScalarWhereInput | UserPreferenceScalarWhereInput[]
    id?: BigIntFilter<"UserPreference"> | bigint | number
    user_id?: BigIntFilter<"UserPreference"> | bigint | number
    preferred_area?: StringFilter<"UserPreference"> | string
    preferred_keywords?: JsonFilter<"UserPreference">
    created_at?: DateTimeFilter<"UserPreference"> | Date | string
  }

  export type VerificationCodeUpsertWithWhereUniqueWithoutUserInput = {
    where: VerificationCodeWhereUniqueInput
    update: XOR<VerificationCodeUpdateWithoutUserInput, VerificationCodeUncheckedUpdateWithoutUserInput>
    create: XOR<VerificationCodeCreateWithoutUserInput, VerificationCodeUncheckedCreateWithoutUserInput>
  }

  export type VerificationCodeUpdateWithWhereUniqueWithoutUserInput = {
    where: VerificationCodeWhereUniqueInput
    data: XOR<VerificationCodeUpdateWithoutUserInput, VerificationCodeUncheckedUpdateWithoutUserInput>
  }

  export type VerificationCodeUpdateManyWithWhereWithoutUserInput = {
    where: VerificationCodeScalarWhereInput
    data: XOR<VerificationCodeUpdateManyMutationInput, VerificationCodeUncheckedUpdateManyWithoutUserInput>
  }

  export type VerificationCodeScalarWhereInput = {
    AND?: VerificationCodeScalarWhereInput | VerificationCodeScalarWhereInput[]
    OR?: VerificationCodeScalarWhereInput[]
    NOT?: VerificationCodeScalarWhereInput | VerificationCodeScalarWhereInput[]
    id?: BigIntFilter<"VerificationCode"> | bigint | number
    user_id?: BigIntNullableFilter<"VerificationCode"> | bigint | number | null
    phone_number?: StringFilter<"VerificationCode"> | string
    code?: StringFilter<"VerificationCode"> | string
    expires_at?: DateTimeFilter<"VerificationCode"> | Date | string
    verified?: BoolFilter<"VerificationCode"> | boolean
    created_at?: DateTimeFilter<"VerificationCode"> | Date | string
  }

  export type ChallengeParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: ChallengeParticipantWhereUniqueInput
    update: XOR<ChallengeParticipantUpdateWithoutUserInput, ChallengeParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<ChallengeParticipantCreateWithoutUserInput, ChallengeParticipantUncheckedCreateWithoutUserInput>
  }

  export type ChallengeParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: ChallengeParticipantWhereUniqueInput
    data: XOR<ChallengeParticipantUpdateWithoutUserInput, ChallengeParticipantUncheckedUpdateWithoutUserInput>
  }

  export type ChallengeParticipantUpdateManyWithWhereWithoutUserInput = {
    where: ChallengeParticipantScalarWhereInput
    data: XOR<ChallengeParticipantUpdateManyMutationInput, ChallengeParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type ChallengeParticipantScalarWhereInput = {
    AND?: ChallengeParticipantScalarWhereInput | ChallengeParticipantScalarWhereInput[]
    OR?: ChallengeParticipantScalarWhereInput[]
    NOT?: ChallengeParticipantScalarWhereInput | ChallengeParticipantScalarWhereInput[]
    id?: IntFilter<"ChallengeParticipant"> | number
    user_id?: BigIntFilter<"ChallengeParticipant"> | bigint | number
    challenge_id?: IntFilter<"ChallengeParticipant"> | number
    status?: StringFilter<"ChallengeParticipant"> | string
    joined_at?: DateTimeFilter<"ChallengeParticipant"> | Date | string
    completed_at?: DateTimeFilter<"ChallengeParticipant"> | Date | string
    created_at?: DateTimeFilter<"ChallengeParticipant"> | Date | string
    updated_at?: DateTimeFilter<"ChallengeParticipant"> | Date | string
  }

  export type BadgeUpsertWithWhereUniqueWithoutUserInput = {
    where: BadgeWhereUniqueInput
    update: XOR<BadgeUpdateWithoutUserInput, BadgeUncheckedUpdateWithoutUserInput>
    create: XOR<BadgeCreateWithoutUserInput, BadgeUncheckedCreateWithoutUserInput>
  }

  export type BadgeUpdateWithWhereUniqueWithoutUserInput = {
    where: BadgeWhereUniqueInput
    data: XOR<BadgeUpdateWithoutUserInput, BadgeUncheckedUpdateWithoutUserInput>
  }

  export type BadgeUpdateManyWithWhereWithoutUserInput = {
    where: BadgeScalarWhereInput
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyWithoutUserInput>
  }

  export type BadgeScalarWhereInput = {
    AND?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
    OR?: BadgeScalarWhereInput[]
    NOT?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
    id?: IntFilter<"Badge"> | number
    user_id?: BigIntFilter<"Badge"> | bigint | number
    challenge_id?: IntFilter<"Badge"> | number
    badge_type_id?: IntFilter<"Badge"> | number
    earned_at?: DateTimeFilter<"Badge"> | Date | string
  }

  export type StampBookUpsertWithWhereUniqueWithoutUserInput = {
    where: StampBookWhereUniqueInput
    update: XOR<StampBookUpdateWithoutUserInput, StampBookUncheckedUpdateWithoutUserInput>
    create: XOR<StampBookCreateWithoutUserInput, StampBookUncheckedCreateWithoutUserInput>
  }

  export type StampBookUpdateWithWhereUniqueWithoutUserInput = {
    where: StampBookWhereUniqueInput
    data: XOR<StampBookUpdateWithoutUserInput, StampBookUncheckedUpdateWithoutUserInput>
  }

  export type StampBookUpdateManyWithWhereWithoutUserInput = {
    where: StampBookScalarWhereInput
    data: XOR<StampBookUpdateManyMutationInput, StampBookUncheckedUpdateManyWithoutUserInput>
  }

  export type StampBookScalarWhereInput = {
    AND?: StampBookScalarWhereInput | StampBookScalarWhereInput[]
    OR?: StampBookScalarWhereInput[]
    NOT?: StampBookScalarWhereInput | StampBookScalarWhereInput[]
    id?: IntFilter<"StampBook"> | number
    user_id?: BigIntFilter<"StampBook"> | bigint | number
    cafe_id?: BigIntFilter<"StampBook"> | bigint | number
    current_count?: IntFilter<"StampBook"> | number
    goal_count?: IntFilter<"StampBook"> | number
    reward_detail?: StringFilter<"StampBook"> | string
    started_at?: DateTimeFilter<"StampBook"> | Date | string
    last_visited_at?: DateTimeFilter<"StampBook"> | Date | string
    expires_at?: DateTimeFilter<"StampBook"> | Date | string
    extended_at?: DateTimeFilter<"StampBook"> | Date | string
    expired_at?: DateTimeFilter<"StampBook"> | Date | string
    completed_at?: DateTimeFilter<"StampBook"> | Date | string
    converted_at?: DateTimeFilter<"StampBook"> | Date | string
    status?: StringFilter<"StampBook"> | string
    is_completed?: BoolFilter<"StampBook"> | boolean
    is_converted?: BoolFilter<"StampBook"> | boolean
    created_at?: DateTimeFilter<"StampBook"> | Date | string
    updated_at?: DateTimeFilter<"StampBook"> | Date | string
  }

  export type PointTransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: PointTransactionWhereUniqueInput
    update: XOR<PointTransactionUpdateWithoutUserInput, PointTransactionUncheckedUpdateWithoutUserInput>
    create: XOR<PointTransactionCreateWithoutUserInput, PointTransactionUncheckedCreateWithoutUserInput>
  }

  export type PointTransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: PointTransactionWhereUniqueInput
    data: XOR<PointTransactionUpdateWithoutUserInput, PointTransactionUncheckedUpdateWithoutUserInput>
  }

  export type PointTransactionUpdateManyWithWhereWithoutUserInput = {
    where: PointTransactionScalarWhereInput
    data: XOR<PointTransactionUpdateManyMutationInput, PointTransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type PointTransactionScalarWhereInput = {
    AND?: PointTransactionScalarWhereInput | PointTransactionScalarWhereInput[]
    OR?: PointTransactionScalarWhereInput[]
    NOT?: PointTransactionScalarWhereInput | PointTransactionScalarWhereInput[]
    id?: IntFilter<"PointTransaction"> | number
    user_id?: BigIntFilter<"PointTransaction"> | bigint | number
    stamp_book_id?: IntFilter<"PointTransaction"> | number
    point?: IntFilter<"PointTransaction"> | number
    type?: StringFilter<"PointTransaction"> | string
    description?: StringFilter<"PointTransaction"> | string
    created_at?: DateTimeFilter<"PointTransaction"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: IntFilter<"Review"> | number
    user_id?: BigIntFilter<"Review"> | bigint | number
    cafe_id?: BigIntFilter<"Review"> | bigint | number
    title?: StringFilter<"Review"> | string
    content?: StringFilter<"Review"> | string
    images?: JsonFilter<"Review">
    created_at?: DateTimeFilter<"Review"> | Date | string
    updated_at?: DateTimeFilter<"Review"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    user_id?: BigIntFilter<"Notification"> | bigint | number
    cafe_id?: BigIntFilter<"Notification"> | bigint | number
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    is_read?: BoolFilter<"Notification"> | boolean
    created_at?: DateTimeFilter<"Notification"> | Date | string
  }

  export type CouponUpsertWithWhereUniqueWithoutUserInput = {
    where: CouponWhereUniqueInput
    update: XOR<CouponUpdateWithoutUserInput, CouponUncheckedUpdateWithoutUserInput>
    create: XOR<CouponCreateWithoutUserInput, CouponUncheckedCreateWithoutUserInput>
  }

  export type CouponUpdateWithWhereUniqueWithoutUserInput = {
    where: CouponWhereUniqueInput
    data: XOR<CouponUpdateWithoutUserInput, CouponUncheckedUpdateWithoutUserInput>
  }

  export type CouponUpdateManyWithWhereWithoutUserInput = {
    where: CouponScalarWhereInput
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyWithoutUserInput>
  }

  export type CouponScalarWhereInput = {
    AND?: CouponScalarWhereInput | CouponScalarWhereInput[]
    OR?: CouponScalarWhereInput[]
    NOT?: CouponScalarWhereInput | CouponScalarWhereInput[]
    id?: IntFilter<"Coupon"> | number
    user_id?: BigIntFilter<"Coupon"> | bigint | number
    cafe_id?: BigIntFilter<"Coupon"> | bigint | number
    type?: StringFilter<"Coupon"> | string
    name?: StringFilter<"Coupon"> | string
    status?: StringFilter<"Coupon"> | string
    issued_at?: DateTimeFilter<"Coupon"> | Date | string
    expired_at?: DateTimeFilter<"Coupon"> | Date | string
    used_at?: DateTimeFilter<"Coupon"> | Date | string
  }

  export type UserCreateWithoutKakao_accountsInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user_agreements?: UserAgreementCreateNestedOneWithoutUserInput
    user_preferences?: UserPreferenceCreateNestedManyWithoutUserInput
    verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    stamp_books?: StampBookCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    coupons?: CouponCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutKakao_accountsInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user_agreements?: UserAgreementUncheckedCreateNestedOneWithoutUserInput
    user_preferences?: UserPreferenceUncheckedCreateNestedManyWithoutUserInput
    verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    stamp_books?: StampBookUncheckedCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    coupons?: CouponUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutKakao_accountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutKakao_accountsInput, UserUncheckedCreateWithoutKakao_accountsInput>
  }

  export type UserUpsertWithoutKakao_accountsInput = {
    update: XOR<UserUpdateWithoutKakao_accountsInput, UserUncheckedUpdateWithoutKakao_accountsInput>
    create: XOR<UserCreateWithoutKakao_accountsInput, UserUncheckedCreateWithoutKakao_accountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutKakao_accountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutKakao_accountsInput, UserUncheckedUpdateWithoutKakao_accountsInput>
  }

  export type UserUpdateWithoutKakao_accountsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_agreements?: UserAgreementUpdateOneWithoutUserNestedInput
    user_preferences?: UserPreferenceUpdateManyWithoutUserNestedInput
    verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    coupons?: CouponUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutKakao_accountsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_agreements?: UserAgreementUncheckedUpdateOneWithoutUserNestedInput
    user_preferences?: UserPreferenceUncheckedUpdateManyWithoutUserNestedInput
    verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUncheckedUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUser_preferencesInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountCreateNestedManyWithoutUserInput
    user_agreements?: UserAgreementCreateNestedOneWithoutUserInput
    verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    stamp_books?: StampBookCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    coupons?: CouponCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUser_preferencesInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountUncheckedCreateNestedManyWithoutUserInput
    user_agreements?: UserAgreementUncheckedCreateNestedOneWithoutUserInput
    verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    stamp_books?: StampBookUncheckedCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    coupons?: CouponUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUser_preferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_preferencesInput, UserUncheckedCreateWithoutUser_preferencesInput>
  }

  export type UserUpsertWithoutUser_preferencesInput = {
    update: XOR<UserUpdateWithoutUser_preferencesInput, UserUncheckedUpdateWithoutUser_preferencesInput>
    create: XOR<UserCreateWithoutUser_preferencesInput, UserUncheckedCreateWithoutUser_preferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUser_preferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUser_preferencesInput, UserUncheckedUpdateWithoutUser_preferencesInput>
  }

  export type UserUpdateWithoutUser_preferencesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUpdateManyWithoutUserNestedInput
    user_agreements?: UserAgreementUpdateOneWithoutUserNestedInput
    verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    coupons?: CouponUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_preferencesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUncheckedUpdateManyWithoutUserNestedInput
    user_agreements?: UserAgreementUncheckedUpdateOneWithoutUserNestedInput
    verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUncheckedUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutVerification_codesInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountCreateNestedManyWithoutUserInput
    user_agreements?: UserAgreementCreateNestedOneWithoutUserInput
    user_preferences?: UserPreferenceCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    stamp_books?: StampBookCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    coupons?: CouponCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVerification_codesInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountUncheckedCreateNestedManyWithoutUserInput
    user_agreements?: UserAgreementUncheckedCreateNestedOneWithoutUserInput
    user_preferences?: UserPreferenceUncheckedCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    stamp_books?: StampBookUncheckedCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    coupons?: CouponUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVerification_codesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerification_codesInput, UserUncheckedCreateWithoutVerification_codesInput>
  }

  export type UserUpsertWithoutVerification_codesInput = {
    update: XOR<UserUpdateWithoutVerification_codesInput, UserUncheckedUpdateWithoutVerification_codesInput>
    create: XOR<UserCreateWithoutVerification_codesInput, UserUncheckedCreateWithoutVerification_codesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerification_codesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerification_codesInput, UserUncheckedUpdateWithoutVerification_codesInput>
  }

  export type UserUpdateWithoutVerification_codesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUpdateManyWithoutUserNestedInput
    user_agreements?: UserAgreementUpdateOneWithoutUserNestedInput
    user_preferences?: UserPreferenceUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    coupons?: CouponUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVerification_codesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUncheckedUpdateManyWithoutUserNestedInput
    user_agreements?: UserAgreementUncheckedUpdateOneWithoutUserNestedInput
    user_preferences?: UserPreferenceUncheckedUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUncheckedUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUser_agreementsInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountCreateNestedManyWithoutUserInput
    user_preferences?: UserPreferenceCreateNestedManyWithoutUserInput
    verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    stamp_books?: StampBookCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    coupons?: CouponCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUser_agreementsInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountUncheckedCreateNestedManyWithoutUserInput
    user_preferences?: UserPreferenceUncheckedCreateNestedManyWithoutUserInput
    verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    stamp_books?: StampBookUncheckedCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    coupons?: CouponUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUser_agreementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_agreementsInput, UserUncheckedCreateWithoutUser_agreementsInput>
  }

  export type UserUpsertWithoutUser_agreementsInput = {
    update: XOR<UserUpdateWithoutUser_agreementsInput, UserUncheckedUpdateWithoutUser_agreementsInput>
    create: XOR<UserCreateWithoutUser_agreementsInput, UserUncheckedCreateWithoutUser_agreementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUser_agreementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUser_agreementsInput, UserUncheckedUpdateWithoutUser_agreementsInput>
  }

  export type UserUpdateWithoutUser_agreementsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUpdateManyWithoutUserNestedInput
    user_preferences?: UserPreferenceUpdateManyWithoutUserNestedInput
    verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    coupons?: CouponUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_agreementsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUncheckedUpdateManyWithoutUserNestedInput
    user_preferences?: UserPreferenceUncheckedUpdateManyWithoutUserNestedInput
    verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUncheckedUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChallengeParticipantCreateWithoutChallengeInput = {
    status: string
    joined_at: Date | string
    completed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutChallenge_participantsInput
  }

  export type ChallengeParticipantUncheckedCreateWithoutChallengeInput = {
    id?: number
    user_id: bigint | number
    status: string
    joined_at: Date | string
    completed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChallengeParticipantCreateOrConnectWithoutChallengeInput = {
    where: ChallengeParticipantWhereUniqueInput
    create: XOR<ChallengeParticipantCreateWithoutChallengeInput, ChallengeParticipantUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeParticipantCreateManyChallengeInputEnvelope = {
    data: ChallengeParticipantCreateManyChallengeInput | ChallengeParticipantCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeAvailableCafeCreateWithoutChallengeInput = {
    created_at?: Date | string
    cafe: CafeCreateNestedOneWithoutAvailable_challengesInput
  }

  export type ChallengeAvailableCafeUncheckedCreateWithoutChallengeInput = {
    id?: number
    cafe_id: bigint | number
    created_at?: Date | string
  }

  export type ChallengeAvailableCafeCreateOrConnectWithoutChallengeInput = {
    where: ChallengeAvailableCafeWhereUniqueInput
    create: XOR<ChallengeAvailableCafeCreateWithoutChallengeInput, ChallengeAvailableCafeUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeAvailableCafeCreateManyChallengeInputEnvelope = {
    data: ChallengeAvailableCafeCreateManyChallengeInput | ChallengeAvailableCafeCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type BadgeCreateWithoutChallengeInput = {
    earned_at?: Date | string
    user: UserCreateNestedOneWithoutBadgesInput
    badge_type: BadgeTypeCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateWithoutChallengeInput = {
    id?: number
    user_id: bigint | number
    badge_type_id: number
    earned_at?: Date | string
  }

  export type BadgeCreateOrConnectWithoutChallengeInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutChallengeInput, BadgeUncheckedCreateWithoutChallengeInput>
  }

  export type BadgeCreateManyChallengeInputEnvelope = {
    data: BadgeCreateManyChallengeInput | BadgeCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeParticipantUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeParticipantWhereUniqueInput
    update: XOR<ChallengeParticipantUpdateWithoutChallengeInput, ChallengeParticipantUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeParticipantCreateWithoutChallengeInput, ChallengeParticipantUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeParticipantUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeParticipantWhereUniqueInput
    data: XOR<ChallengeParticipantUpdateWithoutChallengeInput, ChallengeParticipantUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeParticipantUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengeParticipantScalarWhereInput
    data: XOR<ChallengeParticipantUpdateManyMutationInput, ChallengeParticipantUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ChallengeAvailableCafeUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeAvailableCafeWhereUniqueInput
    update: XOR<ChallengeAvailableCafeUpdateWithoutChallengeInput, ChallengeAvailableCafeUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeAvailableCafeCreateWithoutChallengeInput, ChallengeAvailableCafeUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeAvailableCafeUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeAvailableCafeWhereUniqueInput
    data: XOR<ChallengeAvailableCafeUpdateWithoutChallengeInput, ChallengeAvailableCafeUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeAvailableCafeUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengeAvailableCafeScalarWhereInput
    data: XOR<ChallengeAvailableCafeUpdateManyMutationInput, ChallengeAvailableCafeUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ChallengeAvailableCafeScalarWhereInput = {
    AND?: ChallengeAvailableCafeScalarWhereInput | ChallengeAvailableCafeScalarWhereInput[]
    OR?: ChallengeAvailableCafeScalarWhereInput[]
    NOT?: ChallengeAvailableCafeScalarWhereInput | ChallengeAvailableCafeScalarWhereInput[]
    id?: IntFilter<"ChallengeAvailableCafe"> | number
    challenge_id?: IntFilter<"ChallengeAvailableCafe"> | number
    cafe_id?: BigIntFilter<"ChallengeAvailableCafe"> | bigint | number
    created_at?: DateTimeFilter<"ChallengeAvailableCafe"> | Date | string
  }

  export type BadgeUpsertWithWhereUniqueWithoutChallengeInput = {
    where: BadgeWhereUniqueInput
    update: XOR<BadgeUpdateWithoutChallengeInput, BadgeUncheckedUpdateWithoutChallengeInput>
    create: XOR<BadgeCreateWithoutChallengeInput, BadgeUncheckedCreateWithoutChallengeInput>
  }

  export type BadgeUpdateWithWhereUniqueWithoutChallengeInput = {
    where: BadgeWhereUniqueInput
    data: XOR<BadgeUpdateWithoutChallengeInput, BadgeUncheckedUpdateWithoutChallengeInput>
  }

  export type BadgeUpdateManyWithWhereWithoutChallengeInput = {
    where: BadgeScalarWhereInput
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyWithoutChallengeInput>
  }

  export type UserCreateWithoutChallenge_participantsInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountCreateNestedManyWithoutUserInput
    user_agreements?: UserAgreementCreateNestedOneWithoutUserInput
    user_preferences?: UserPreferenceCreateNestedManyWithoutUserInput
    verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    stamp_books?: StampBookCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    coupons?: CouponCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChallenge_participantsInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountUncheckedCreateNestedManyWithoutUserInput
    user_agreements?: UserAgreementUncheckedCreateNestedOneWithoutUserInput
    user_preferences?: UserPreferenceUncheckedCreateNestedManyWithoutUserInput
    verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    stamp_books?: StampBookUncheckedCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    coupons?: CouponUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChallenge_participantsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChallenge_participantsInput, UserUncheckedCreateWithoutChallenge_participantsInput>
  }

  export type ChallengeCreateWithoutParticipantsInput = {
    title: string
    description: string
    thumbnail_url: string
    start_date: Date | string
    end_date: Date | string
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    available_cafes?: ChallengeAvailableCafeCreateNestedManyWithoutChallengeInput
    badges?: BadgeCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutParticipantsInput = {
    id?: number
    title: string
    description: string
    thumbnail_url: string
    start_date: Date | string
    end_date: Date | string
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    available_cafes?: ChallengeAvailableCafeUncheckedCreateNestedManyWithoutChallengeInput
    badges?: BadgeUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutParticipantsInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutParticipantsInput, ChallengeUncheckedCreateWithoutParticipantsInput>
  }

  export type UserUpsertWithoutChallenge_participantsInput = {
    update: XOR<UserUpdateWithoutChallenge_participantsInput, UserUncheckedUpdateWithoutChallenge_participantsInput>
    create: XOR<UserCreateWithoutChallenge_participantsInput, UserUncheckedCreateWithoutChallenge_participantsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChallenge_participantsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChallenge_participantsInput, UserUncheckedUpdateWithoutChallenge_participantsInput>
  }

  export type UserUpdateWithoutChallenge_participantsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUpdateManyWithoutUserNestedInput
    user_agreements?: UserAgreementUpdateOneWithoutUserNestedInput
    user_preferences?: UserPreferenceUpdateManyWithoutUserNestedInput
    verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    coupons?: CouponUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChallenge_participantsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUncheckedUpdateManyWithoutUserNestedInput
    user_agreements?: UserAgreementUncheckedUpdateOneWithoutUserNestedInput
    user_preferences?: UserPreferenceUncheckedUpdateManyWithoutUserNestedInput
    verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUncheckedUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChallengeUpsertWithoutParticipantsInput = {
    update: XOR<ChallengeUpdateWithoutParticipantsInput, ChallengeUncheckedUpdateWithoutParticipantsInput>
    create: XOR<ChallengeCreateWithoutParticipantsInput, ChallengeUncheckedCreateWithoutParticipantsInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutParticipantsInput, ChallengeUncheckedUpdateWithoutParticipantsInput>
  }

  export type ChallengeUpdateWithoutParticipantsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail_url?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_cafes?: ChallengeAvailableCafeUpdateManyWithoutChallengeNestedInput
    badges?: BadgeUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutParticipantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail_url?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_cafes?: ChallengeAvailableCafeUncheckedUpdateManyWithoutChallengeNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateWithoutAvailable_cafesInput = {
    title: string
    description: string
    thumbnail_url: string
    start_date: Date | string
    end_date: Date | string
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    participants?: ChallengeParticipantCreateNestedManyWithoutChallengeInput
    badges?: BadgeCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutAvailable_cafesInput = {
    id?: number
    title: string
    description: string
    thumbnail_url: string
    start_date: Date | string
    end_date: Date | string
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    participants?: ChallengeParticipantUncheckedCreateNestedManyWithoutChallengeInput
    badges?: BadgeUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutAvailable_cafesInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutAvailable_cafesInput, ChallengeUncheckedCreateWithoutAvailable_cafesInput>
  }

  export type CafeCreateWithoutAvailable_challengesInput = {
    id?: bigint | number
    name: string
    address: string
    region: string
    latitude: number
    longitude: number
    owner_name: string
    business_hours: string
    phone: string
    website_url: string
    description: string
    store_filters: JsonNullValueInput | InputJsonValue
    take_out_filters: JsonNullValueInput | InputJsonValue
    menu_filters: JsonNullValueInput | InputJsonValue
    keywords: JsonNullValueInput | InputJsonValue
    status: $Enums.CafeStatus
    created_at?: Date | string
    updated_at?: Date | string
    menu?: CafeMenuCreateNestedManyWithoutCafeInput
    photos?: CafePhotoCreateNestedManyWithoutCafeInput
    stamp_books?: StampBookCreateNestedManyWithoutCafeInput
    reviews?: ReviewCreateNestedManyWithoutCafeInput
    notifications?: NotificationCreateNestedManyWithoutCafeInput
    coupons?: CouponCreateNestedManyWithoutCafeInput
  }

  export type CafeUncheckedCreateWithoutAvailable_challengesInput = {
    id?: bigint | number
    name: string
    address: string
    region: string
    latitude: number
    longitude: number
    owner_name: string
    business_hours: string
    phone: string
    website_url: string
    description: string
    store_filters: JsonNullValueInput | InputJsonValue
    take_out_filters: JsonNullValueInput | InputJsonValue
    menu_filters: JsonNullValueInput | InputJsonValue
    keywords: JsonNullValueInput | InputJsonValue
    status: $Enums.CafeStatus
    created_at?: Date | string
    updated_at?: Date | string
    menu?: CafeMenuUncheckedCreateNestedManyWithoutCafeInput
    photos?: CafePhotoUncheckedCreateNestedManyWithoutCafeInput
    stamp_books?: StampBookUncheckedCreateNestedManyWithoutCafeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCafeInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCafeInput
    coupons?: CouponUncheckedCreateNestedManyWithoutCafeInput
  }

  export type CafeCreateOrConnectWithoutAvailable_challengesInput = {
    where: CafeWhereUniqueInput
    create: XOR<CafeCreateWithoutAvailable_challengesInput, CafeUncheckedCreateWithoutAvailable_challengesInput>
  }

  export type ChallengeUpsertWithoutAvailable_cafesInput = {
    update: XOR<ChallengeUpdateWithoutAvailable_cafesInput, ChallengeUncheckedUpdateWithoutAvailable_cafesInput>
    create: XOR<ChallengeCreateWithoutAvailable_cafesInput, ChallengeUncheckedCreateWithoutAvailable_cafesInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutAvailable_cafesInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutAvailable_cafesInput, ChallengeUncheckedUpdateWithoutAvailable_cafesInput>
  }

  export type ChallengeUpdateWithoutAvailable_cafesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail_url?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ChallengeParticipantUpdateManyWithoutChallengeNestedInput
    badges?: BadgeUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutAvailable_cafesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail_url?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ChallengeParticipantUncheckedUpdateManyWithoutChallengeNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type CafeUpsertWithoutAvailable_challengesInput = {
    update: XOR<CafeUpdateWithoutAvailable_challengesInput, CafeUncheckedUpdateWithoutAvailable_challengesInput>
    create: XOR<CafeCreateWithoutAvailable_challengesInput, CafeUncheckedCreateWithoutAvailable_challengesInput>
    where?: CafeWhereInput
  }

  export type CafeUpdateToOneWithWhereWithoutAvailable_challengesInput = {
    where?: CafeWhereInput
    data: XOR<CafeUpdateWithoutAvailable_challengesInput, CafeUncheckedUpdateWithoutAvailable_challengesInput>
  }

  export type CafeUpdateWithoutAvailable_challengesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner_name?: StringFieldUpdateOperationsInput | string
    business_hours?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    store_filters?: JsonNullValueInput | InputJsonValue
    take_out_filters?: JsonNullValueInput | InputJsonValue
    menu_filters?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    status?: EnumCafeStatusFieldUpdateOperationsInput | $Enums.CafeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: CafeMenuUpdateManyWithoutCafeNestedInput
    photos?: CafePhotoUpdateManyWithoutCafeNestedInput
    stamp_books?: StampBookUpdateManyWithoutCafeNestedInput
    reviews?: ReviewUpdateManyWithoutCafeNestedInput
    notifications?: NotificationUpdateManyWithoutCafeNestedInput
    coupons?: CouponUpdateManyWithoutCafeNestedInput
  }

  export type CafeUncheckedUpdateWithoutAvailable_challengesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner_name?: StringFieldUpdateOperationsInput | string
    business_hours?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    store_filters?: JsonNullValueInput | InputJsonValue
    take_out_filters?: JsonNullValueInput | InputJsonValue
    menu_filters?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    status?: EnumCafeStatusFieldUpdateOperationsInput | $Enums.CafeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: CafeMenuUncheckedUpdateManyWithoutCafeNestedInput
    photos?: CafePhotoUncheckedUpdateManyWithoutCafeNestedInput
    stamp_books?: StampBookUncheckedUpdateManyWithoutCafeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCafeNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCafeNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutCafeNestedInput
  }

  export type BadgeCreateWithoutBadge_typeInput = {
    earned_at?: Date | string
    user: UserCreateNestedOneWithoutBadgesInput
    challenge: ChallengeCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateWithoutBadge_typeInput = {
    id?: number
    user_id: bigint | number
    challenge_id: number
    earned_at?: Date | string
  }

  export type BadgeCreateOrConnectWithoutBadge_typeInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutBadge_typeInput, BadgeUncheckedCreateWithoutBadge_typeInput>
  }

  export type BadgeCreateManyBadge_typeInputEnvelope = {
    data: BadgeCreateManyBadge_typeInput | BadgeCreateManyBadge_typeInput[]
    skipDuplicates?: boolean
  }

  export type BadgeUpsertWithWhereUniqueWithoutBadge_typeInput = {
    where: BadgeWhereUniqueInput
    update: XOR<BadgeUpdateWithoutBadge_typeInput, BadgeUncheckedUpdateWithoutBadge_typeInput>
    create: XOR<BadgeCreateWithoutBadge_typeInput, BadgeUncheckedCreateWithoutBadge_typeInput>
  }

  export type BadgeUpdateWithWhereUniqueWithoutBadge_typeInput = {
    where: BadgeWhereUniqueInput
    data: XOR<BadgeUpdateWithoutBadge_typeInput, BadgeUncheckedUpdateWithoutBadge_typeInput>
  }

  export type BadgeUpdateManyWithWhereWithoutBadge_typeInput = {
    where: BadgeScalarWhereInput
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyWithoutBadge_typeInput>
  }

  export type UserCreateWithoutBadgesInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountCreateNestedManyWithoutUserInput
    user_agreements?: UserAgreementCreateNestedOneWithoutUserInput
    user_preferences?: UserPreferenceCreateNestedManyWithoutUserInput
    verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    stamp_books?: StampBookCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    coupons?: CouponCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBadgesInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountUncheckedCreateNestedManyWithoutUserInput
    user_agreements?: UserAgreementUncheckedCreateNestedOneWithoutUserInput
    user_preferences?: UserPreferenceUncheckedCreateNestedManyWithoutUserInput
    verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    stamp_books?: StampBookUncheckedCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    coupons?: CouponUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBadgesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
  }

  export type ChallengeCreateWithoutBadgesInput = {
    title: string
    description: string
    thumbnail_url: string
    start_date: Date | string
    end_date: Date | string
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    participants?: ChallengeParticipantCreateNestedManyWithoutChallengeInput
    available_cafes?: ChallengeAvailableCafeCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutBadgesInput = {
    id?: number
    title: string
    description: string
    thumbnail_url: string
    start_date: Date | string
    end_date: Date | string
    is_active: boolean
    created_at?: Date | string
    updated_at?: Date | string
    participants?: ChallengeParticipantUncheckedCreateNestedManyWithoutChallengeInput
    available_cafes?: ChallengeAvailableCafeUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutBadgesInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutBadgesInput, ChallengeUncheckedCreateWithoutBadgesInput>
  }

  export type BadgeTypeCreateWithoutBadgesInput = {
    title: string
    image_url: string
    created_at?: Date | string
  }

  export type BadgeTypeUncheckedCreateWithoutBadgesInput = {
    id?: number
    title: string
    image_url: string
    created_at?: Date | string
  }

  export type BadgeTypeCreateOrConnectWithoutBadgesInput = {
    where: BadgeTypeWhereUniqueInput
    create: XOR<BadgeTypeCreateWithoutBadgesInput, BadgeTypeUncheckedCreateWithoutBadgesInput>
  }

  export type UserUpsertWithoutBadgesInput = {
    update: XOR<UserUpdateWithoutBadgesInput, UserUncheckedUpdateWithoutBadgesInput>
    create: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBadgesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBadgesInput, UserUncheckedUpdateWithoutBadgesInput>
  }

  export type UserUpdateWithoutBadgesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUpdateManyWithoutUserNestedInput
    user_agreements?: UserAgreementUpdateOneWithoutUserNestedInput
    user_preferences?: UserPreferenceUpdateManyWithoutUserNestedInput
    verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    coupons?: CouponUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBadgesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUncheckedUpdateManyWithoutUserNestedInput
    user_agreements?: UserAgreementUncheckedUpdateOneWithoutUserNestedInput
    user_preferences?: UserPreferenceUncheckedUpdateManyWithoutUserNestedInput
    verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUncheckedUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChallengeUpsertWithoutBadgesInput = {
    update: XOR<ChallengeUpdateWithoutBadgesInput, ChallengeUncheckedUpdateWithoutBadgesInput>
    create: XOR<ChallengeCreateWithoutBadgesInput, ChallengeUncheckedCreateWithoutBadgesInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutBadgesInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutBadgesInput, ChallengeUncheckedUpdateWithoutBadgesInput>
  }

  export type ChallengeUpdateWithoutBadgesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail_url?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ChallengeParticipantUpdateManyWithoutChallengeNestedInput
    available_cafes?: ChallengeAvailableCafeUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutBadgesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail_url?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ChallengeParticipantUncheckedUpdateManyWithoutChallengeNestedInput
    available_cafes?: ChallengeAvailableCafeUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type BadgeTypeUpsertWithoutBadgesInput = {
    update: XOR<BadgeTypeUpdateWithoutBadgesInput, BadgeTypeUncheckedUpdateWithoutBadgesInput>
    create: XOR<BadgeTypeCreateWithoutBadgesInput, BadgeTypeUncheckedCreateWithoutBadgesInput>
    where?: BadgeTypeWhereInput
  }

  export type BadgeTypeUpdateToOneWithWhereWithoutBadgesInput = {
    where?: BadgeTypeWhereInput
    data: XOR<BadgeTypeUpdateWithoutBadgesInput, BadgeTypeUncheckedUpdateWithoutBadgesInput>
  }

  export type BadgeTypeUpdateWithoutBadgesInput = {
    title?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeTypeUncheckedUpdateWithoutBadgesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutStamp_booksInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountCreateNestedManyWithoutUserInput
    user_agreements?: UserAgreementCreateNestedOneWithoutUserInput
    user_preferences?: UserPreferenceCreateNestedManyWithoutUserInput
    verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    coupons?: CouponCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStamp_booksInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountUncheckedCreateNestedManyWithoutUserInput
    user_agreements?: UserAgreementUncheckedCreateNestedOneWithoutUserInput
    user_preferences?: UserPreferenceUncheckedCreateNestedManyWithoutUserInput
    verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    coupons?: CouponUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStamp_booksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStamp_booksInput, UserUncheckedCreateWithoutStamp_booksInput>
  }

  export type CafeCreateWithoutStamp_booksInput = {
    id?: bigint | number
    name: string
    address: string
    region: string
    latitude: number
    longitude: number
    owner_name: string
    business_hours: string
    phone: string
    website_url: string
    description: string
    store_filters: JsonNullValueInput | InputJsonValue
    take_out_filters: JsonNullValueInput | InputJsonValue
    menu_filters: JsonNullValueInput | InputJsonValue
    keywords: JsonNullValueInput | InputJsonValue
    status: $Enums.CafeStatus
    created_at?: Date | string
    updated_at?: Date | string
    menu?: CafeMenuCreateNestedManyWithoutCafeInput
    photos?: CafePhotoCreateNestedManyWithoutCafeInput
    available_challenges?: ChallengeAvailableCafeCreateNestedManyWithoutCafeInput
    reviews?: ReviewCreateNestedManyWithoutCafeInput
    notifications?: NotificationCreateNestedManyWithoutCafeInput
    coupons?: CouponCreateNestedManyWithoutCafeInput
  }

  export type CafeUncheckedCreateWithoutStamp_booksInput = {
    id?: bigint | number
    name: string
    address: string
    region: string
    latitude: number
    longitude: number
    owner_name: string
    business_hours: string
    phone: string
    website_url: string
    description: string
    store_filters: JsonNullValueInput | InputJsonValue
    take_out_filters: JsonNullValueInput | InputJsonValue
    menu_filters: JsonNullValueInput | InputJsonValue
    keywords: JsonNullValueInput | InputJsonValue
    status: $Enums.CafeStatus
    created_at?: Date | string
    updated_at?: Date | string
    menu?: CafeMenuUncheckedCreateNestedManyWithoutCafeInput
    photos?: CafePhotoUncheckedCreateNestedManyWithoutCafeInput
    available_challenges?: ChallengeAvailableCafeUncheckedCreateNestedManyWithoutCafeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCafeInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCafeInput
    coupons?: CouponUncheckedCreateNestedManyWithoutCafeInput
  }

  export type CafeCreateOrConnectWithoutStamp_booksInput = {
    where: CafeWhereUniqueInput
    create: XOR<CafeCreateWithoutStamp_booksInput, CafeUncheckedCreateWithoutStamp_booksInput>
  }

  export type StampCreateWithoutStamp_bookInput = {
    stamp_image_url: string
    stamped_at?: Date | string
    source: string
    note: string
    latitude: number
    longitude: number
  }

  export type StampUncheckedCreateWithoutStamp_bookInput = {
    id?: number
    stamp_image_url: string
    stamped_at?: Date | string
    source: string
    note: string
    latitude: number
    longitude: number
  }

  export type StampCreateOrConnectWithoutStamp_bookInput = {
    where: StampWhereUniqueInput
    create: XOR<StampCreateWithoutStamp_bookInput, StampUncheckedCreateWithoutStamp_bookInput>
  }

  export type StampCreateManyStamp_bookInputEnvelope = {
    data: StampCreateManyStamp_bookInput | StampCreateManyStamp_bookInput[]
    skipDuplicates?: boolean
  }

  export type PointTransactionCreateWithoutStamp_bookInput = {
    point: number
    type: string
    description: string
    created_at?: Date | string
    user: UserCreateNestedOneWithoutPoint_transactionsInput
  }

  export type PointTransactionUncheckedCreateWithoutStamp_bookInput = {
    id?: number
    user_id: bigint | number
    point: number
    type: string
    description: string
    created_at?: Date | string
  }

  export type PointTransactionCreateOrConnectWithoutStamp_bookInput = {
    where: PointTransactionWhereUniqueInput
    create: XOR<PointTransactionCreateWithoutStamp_bookInput, PointTransactionUncheckedCreateWithoutStamp_bookInput>
  }

  export type PointTransactionCreateManyStamp_bookInputEnvelope = {
    data: PointTransactionCreateManyStamp_bookInput | PointTransactionCreateManyStamp_bookInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStamp_booksInput = {
    update: XOR<UserUpdateWithoutStamp_booksInput, UserUncheckedUpdateWithoutStamp_booksInput>
    create: XOR<UserCreateWithoutStamp_booksInput, UserUncheckedCreateWithoutStamp_booksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStamp_booksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStamp_booksInput, UserUncheckedUpdateWithoutStamp_booksInput>
  }

  export type UserUpdateWithoutStamp_booksInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUpdateManyWithoutUserNestedInput
    user_agreements?: UserAgreementUpdateOneWithoutUserNestedInput
    user_preferences?: UserPreferenceUpdateManyWithoutUserNestedInput
    verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    coupons?: CouponUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStamp_booksInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUncheckedUpdateManyWithoutUserNestedInput
    user_agreements?: UserAgreementUncheckedUpdateOneWithoutUserNestedInput
    user_preferences?: UserPreferenceUncheckedUpdateManyWithoutUserNestedInput
    verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CafeUpsertWithoutStamp_booksInput = {
    update: XOR<CafeUpdateWithoutStamp_booksInput, CafeUncheckedUpdateWithoutStamp_booksInput>
    create: XOR<CafeCreateWithoutStamp_booksInput, CafeUncheckedCreateWithoutStamp_booksInput>
    where?: CafeWhereInput
  }

  export type CafeUpdateToOneWithWhereWithoutStamp_booksInput = {
    where?: CafeWhereInput
    data: XOR<CafeUpdateWithoutStamp_booksInput, CafeUncheckedUpdateWithoutStamp_booksInput>
  }

  export type CafeUpdateWithoutStamp_booksInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner_name?: StringFieldUpdateOperationsInput | string
    business_hours?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    store_filters?: JsonNullValueInput | InputJsonValue
    take_out_filters?: JsonNullValueInput | InputJsonValue
    menu_filters?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    status?: EnumCafeStatusFieldUpdateOperationsInput | $Enums.CafeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: CafeMenuUpdateManyWithoutCafeNestedInput
    photos?: CafePhotoUpdateManyWithoutCafeNestedInput
    available_challenges?: ChallengeAvailableCafeUpdateManyWithoutCafeNestedInput
    reviews?: ReviewUpdateManyWithoutCafeNestedInput
    notifications?: NotificationUpdateManyWithoutCafeNestedInput
    coupons?: CouponUpdateManyWithoutCafeNestedInput
  }

  export type CafeUncheckedUpdateWithoutStamp_booksInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner_name?: StringFieldUpdateOperationsInput | string
    business_hours?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    store_filters?: JsonNullValueInput | InputJsonValue
    take_out_filters?: JsonNullValueInput | InputJsonValue
    menu_filters?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    status?: EnumCafeStatusFieldUpdateOperationsInput | $Enums.CafeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: CafeMenuUncheckedUpdateManyWithoutCafeNestedInput
    photos?: CafePhotoUncheckedUpdateManyWithoutCafeNestedInput
    available_challenges?: ChallengeAvailableCafeUncheckedUpdateManyWithoutCafeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCafeNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCafeNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutCafeNestedInput
  }

  export type StampUpsertWithWhereUniqueWithoutStamp_bookInput = {
    where: StampWhereUniqueInput
    update: XOR<StampUpdateWithoutStamp_bookInput, StampUncheckedUpdateWithoutStamp_bookInput>
    create: XOR<StampCreateWithoutStamp_bookInput, StampUncheckedCreateWithoutStamp_bookInput>
  }

  export type StampUpdateWithWhereUniqueWithoutStamp_bookInput = {
    where: StampWhereUniqueInput
    data: XOR<StampUpdateWithoutStamp_bookInput, StampUncheckedUpdateWithoutStamp_bookInput>
  }

  export type StampUpdateManyWithWhereWithoutStamp_bookInput = {
    where: StampScalarWhereInput
    data: XOR<StampUpdateManyMutationInput, StampUncheckedUpdateManyWithoutStamp_bookInput>
  }

  export type StampScalarWhereInput = {
    AND?: StampScalarWhereInput | StampScalarWhereInput[]
    OR?: StampScalarWhereInput[]
    NOT?: StampScalarWhereInput | StampScalarWhereInput[]
    id?: IntFilter<"Stamp"> | number
    stamp_book_id?: IntFilter<"Stamp"> | number
    stamp_image_url?: StringFilter<"Stamp"> | string
    stamped_at?: DateTimeFilter<"Stamp"> | Date | string
    source?: StringFilter<"Stamp"> | string
    note?: StringFilter<"Stamp"> | string
    latitude?: FloatFilter<"Stamp"> | number
    longitude?: FloatFilter<"Stamp"> | number
  }

  export type PointTransactionUpsertWithWhereUniqueWithoutStamp_bookInput = {
    where: PointTransactionWhereUniqueInput
    update: XOR<PointTransactionUpdateWithoutStamp_bookInput, PointTransactionUncheckedUpdateWithoutStamp_bookInput>
    create: XOR<PointTransactionCreateWithoutStamp_bookInput, PointTransactionUncheckedCreateWithoutStamp_bookInput>
  }

  export type PointTransactionUpdateWithWhereUniqueWithoutStamp_bookInput = {
    where: PointTransactionWhereUniqueInput
    data: XOR<PointTransactionUpdateWithoutStamp_bookInput, PointTransactionUncheckedUpdateWithoutStamp_bookInput>
  }

  export type PointTransactionUpdateManyWithWhereWithoutStamp_bookInput = {
    where: PointTransactionScalarWhereInput
    data: XOR<PointTransactionUpdateManyMutationInput, PointTransactionUncheckedUpdateManyWithoutStamp_bookInput>
  }

  export type StampBookCreateWithoutStampsInput = {
    current_count: number
    goal_count: number
    reward_detail: string
    started_at: Date | string
    last_visited_at: Date | string
    expires_at: Date | string
    extended_at: Date | string
    expired_at: Date | string
    completed_at: Date | string
    converted_at: Date | string
    status: string
    is_completed: boolean
    is_converted: boolean
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutStamp_booksInput
    cafe: CafeCreateNestedOneWithoutStamp_booksInput
    point_transactions?: PointTransactionCreateNestedManyWithoutStamp_bookInput
  }

  export type StampBookUncheckedCreateWithoutStampsInput = {
    id?: number
    user_id: bigint | number
    cafe_id: bigint | number
    current_count: number
    goal_count: number
    reward_detail: string
    started_at: Date | string
    last_visited_at: Date | string
    expires_at: Date | string
    extended_at: Date | string
    expired_at: Date | string
    completed_at: Date | string
    converted_at: Date | string
    status: string
    is_completed: boolean
    is_converted: boolean
    created_at?: Date | string
    updated_at?: Date | string
    point_transactions?: PointTransactionUncheckedCreateNestedManyWithoutStamp_bookInput
  }

  export type StampBookCreateOrConnectWithoutStampsInput = {
    where: StampBookWhereUniqueInput
    create: XOR<StampBookCreateWithoutStampsInput, StampBookUncheckedCreateWithoutStampsInput>
  }

  export type StampBookUpsertWithoutStampsInput = {
    update: XOR<StampBookUpdateWithoutStampsInput, StampBookUncheckedUpdateWithoutStampsInput>
    create: XOR<StampBookCreateWithoutStampsInput, StampBookUncheckedCreateWithoutStampsInput>
    where?: StampBookWhereInput
  }

  export type StampBookUpdateToOneWithWhereWithoutStampsInput = {
    where?: StampBookWhereInput
    data: XOR<StampBookUpdateWithoutStampsInput, StampBookUncheckedUpdateWithoutStampsInput>
  }

  export type StampBookUpdateWithoutStampsInput = {
    current_count?: IntFieldUpdateOperationsInput | number
    goal_count?: IntFieldUpdateOperationsInput | number
    reward_detail?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_visited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    extended_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    converted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    is_converted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStamp_booksNestedInput
    cafe?: CafeUpdateOneRequiredWithoutStamp_booksNestedInput
    point_transactions?: PointTransactionUpdateManyWithoutStamp_bookNestedInput
  }

  export type StampBookUncheckedUpdateWithoutStampsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    current_count?: IntFieldUpdateOperationsInput | number
    goal_count?: IntFieldUpdateOperationsInput | number
    reward_detail?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_visited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    extended_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    converted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    is_converted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    point_transactions?: PointTransactionUncheckedUpdateManyWithoutStamp_bookNestedInput
  }

  export type UserCreateWithoutPoint_transactionsInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountCreateNestedManyWithoutUserInput
    user_agreements?: UserAgreementCreateNestedOneWithoutUserInput
    user_preferences?: UserPreferenceCreateNestedManyWithoutUserInput
    verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    stamp_books?: StampBookCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    coupons?: CouponCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPoint_transactionsInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountUncheckedCreateNestedManyWithoutUserInput
    user_agreements?: UserAgreementUncheckedCreateNestedOneWithoutUserInput
    user_preferences?: UserPreferenceUncheckedCreateNestedManyWithoutUserInput
    verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    stamp_books?: StampBookUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    coupons?: CouponUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPoint_transactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPoint_transactionsInput, UserUncheckedCreateWithoutPoint_transactionsInput>
  }

  export type StampBookCreateWithoutPoint_transactionsInput = {
    current_count: number
    goal_count: number
    reward_detail: string
    started_at: Date | string
    last_visited_at: Date | string
    expires_at: Date | string
    extended_at: Date | string
    expired_at: Date | string
    completed_at: Date | string
    converted_at: Date | string
    status: string
    is_completed: boolean
    is_converted: boolean
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutStamp_booksInput
    cafe: CafeCreateNestedOneWithoutStamp_booksInput
    stamps?: StampCreateNestedManyWithoutStamp_bookInput
  }

  export type StampBookUncheckedCreateWithoutPoint_transactionsInput = {
    id?: number
    user_id: bigint | number
    cafe_id: bigint | number
    current_count: number
    goal_count: number
    reward_detail: string
    started_at: Date | string
    last_visited_at: Date | string
    expires_at: Date | string
    extended_at: Date | string
    expired_at: Date | string
    completed_at: Date | string
    converted_at: Date | string
    status: string
    is_completed: boolean
    is_converted: boolean
    created_at?: Date | string
    updated_at?: Date | string
    stamps?: StampUncheckedCreateNestedManyWithoutStamp_bookInput
  }

  export type StampBookCreateOrConnectWithoutPoint_transactionsInput = {
    where: StampBookWhereUniqueInput
    create: XOR<StampBookCreateWithoutPoint_transactionsInput, StampBookUncheckedCreateWithoutPoint_transactionsInput>
  }

  export type UserUpsertWithoutPoint_transactionsInput = {
    update: XOR<UserUpdateWithoutPoint_transactionsInput, UserUncheckedUpdateWithoutPoint_transactionsInput>
    create: XOR<UserCreateWithoutPoint_transactionsInput, UserUncheckedCreateWithoutPoint_transactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPoint_transactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPoint_transactionsInput, UserUncheckedUpdateWithoutPoint_transactionsInput>
  }

  export type UserUpdateWithoutPoint_transactionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUpdateManyWithoutUserNestedInput
    user_agreements?: UserAgreementUpdateOneWithoutUserNestedInput
    user_preferences?: UserPreferenceUpdateManyWithoutUserNestedInput
    verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    coupons?: CouponUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPoint_transactionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUncheckedUpdateManyWithoutUserNestedInput
    user_agreements?: UserAgreementUncheckedUpdateOneWithoutUserNestedInput
    user_preferences?: UserPreferenceUncheckedUpdateManyWithoutUserNestedInput
    verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StampBookUpsertWithoutPoint_transactionsInput = {
    update: XOR<StampBookUpdateWithoutPoint_transactionsInput, StampBookUncheckedUpdateWithoutPoint_transactionsInput>
    create: XOR<StampBookCreateWithoutPoint_transactionsInput, StampBookUncheckedCreateWithoutPoint_transactionsInput>
    where?: StampBookWhereInput
  }

  export type StampBookUpdateToOneWithWhereWithoutPoint_transactionsInput = {
    where?: StampBookWhereInput
    data: XOR<StampBookUpdateWithoutPoint_transactionsInput, StampBookUncheckedUpdateWithoutPoint_transactionsInput>
  }

  export type StampBookUpdateWithoutPoint_transactionsInput = {
    current_count?: IntFieldUpdateOperationsInput | number
    goal_count?: IntFieldUpdateOperationsInput | number
    reward_detail?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_visited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    extended_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    converted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    is_converted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStamp_booksNestedInput
    cafe?: CafeUpdateOneRequiredWithoutStamp_booksNestedInput
    stamps?: StampUpdateManyWithoutStamp_bookNestedInput
  }

  export type StampBookUncheckedUpdateWithoutPoint_transactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    current_count?: IntFieldUpdateOperationsInput | number
    goal_count?: IntFieldUpdateOperationsInput | number
    reward_detail?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_visited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    extended_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    converted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    is_converted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stamps?: StampUncheckedUpdateManyWithoutStamp_bookNestedInput
  }

  export type CafeMenuCreateWithoutCafeInput = {
    id?: bigint | number
    category: string
    name: string
    description: string
    price: number
    is_sold_out: boolean
    photo_url: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CafeMenuUncheckedCreateWithoutCafeInput = {
    id?: bigint | number
    category: string
    name: string
    description: string
    price: number
    is_sold_out: boolean
    photo_url: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CafeMenuCreateOrConnectWithoutCafeInput = {
    where: CafeMenuWhereUniqueInput
    create: XOR<CafeMenuCreateWithoutCafeInput, CafeMenuUncheckedCreateWithoutCafeInput>
  }

  export type CafeMenuCreateManyCafeInputEnvelope = {
    data: CafeMenuCreateManyCafeInput | CafeMenuCreateManyCafeInput[]
    skipDuplicates?: boolean
  }

  export type CafePhotoCreateWithoutCafeInput = {
    id?: bigint | number
    photo_url: string
    display_order: number
    created_at?: Date | string
  }

  export type CafePhotoUncheckedCreateWithoutCafeInput = {
    id?: bigint | number
    photo_url: string
    display_order: number
    created_at?: Date | string
  }

  export type CafePhotoCreateOrConnectWithoutCafeInput = {
    where: CafePhotoWhereUniqueInput
    create: XOR<CafePhotoCreateWithoutCafeInput, CafePhotoUncheckedCreateWithoutCafeInput>
  }

  export type CafePhotoCreateManyCafeInputEnvelope = {
    data: CafePhotoCreateManyCafeInput | CafePhotoCreateManyCafeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeAvailableCafeCreateWithoutCafeInput = {
    created_at?: Date | string
    challenge: ChallengeCreateNestedOneWithoutAvailable_cafesInput
  }

  export type ChallengeAvailableCafeUncheckedCreateWithoutCafeInput = {
    id?: number
    challenge_id: number
    created_at?: Date | string
  }

  export type ChallengeAvailableCafeCreateOrConnectWithoutCafeInput = {
    where: ChallengeAvailableCafeWhereUniqueInput
    create: XOR<ChallengeAvailableCafeCreateWithoutCafeInput, ChallengeAvailableCafeUncheckedCreateWithoutCafeInput>
  }

  export type ChallengeAvailableCafeCreateManyCafeInputEnvelope = {
    data: ChallengeAvailableCafeCreateManyCafeInput | ChallengeAvailableCafeCreateManyCafeInput[]
    skipDuplicates?: boolean
  }

  export type StampBookCreateWithoutCafeInput = {
    current_count: number
    goal_count: number
    reward_detail: string
    started_at: Date | string
    last_visited_at: Date | string
    expires_at: Date | string
    extended_at: Date | string
    expired_at: Date | string
    completed_at: Date | string
    converted_at: Date | string
    status: string
    is_completed: boolean
    is_converted: boolean
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutStamp_booksInput
    stamps?: StampCreateNestedManyWithoutStamp_bookInput
    point_transactions?: PointTransactionCreateNestedManyWithoutStamp_bookInput
  }

  export type StampBookUncheckedCreateWithoutCafeInput = {
    id?: number
    user_id: bigint | number
    current_count: number
    goal_count: number
    reward_detail: string
    started_at: Date | string
    last_visited_at: Date | string
    expires_at: Date | string
    extended_at: Date | string
    expired_at: Date | string
    completed_at: Date | string
    converted_at: Date | string
    status: string
    is_completed: boolean
    is_converted: boolean
    created_at?: Date | string
    updated_at?: Date | string
    stamps?: StampUncheckedCreateNestedManyWithoutStamp_bookInput
    point_transactions?: PointTransactionUncheckedCreateNestedManyWithoutStamp_bookInput
  }

  export type StampBookCreateOrConnectWithoutCafeInput = {
    where: StampBookWhereUniqueInput
    create: XOR<StampBookCreateWithoutCafeInput, StampBookUncheckedCreateWithoutCafeInput>
  }

  export type StampBookCreateManyCafeInputEnvelope = {
    data: StampBookCreateManyCafeInput | StampBookCreateManyCafeInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutCafeInput = {
    title: string
    content: string
    images: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutCafeInput = {
    id?: number
    user_id: bigint | number
    title: string
    content: string
    images: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ReviewCreateOrConnectWithoutCafeInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutCafeInput, ReviewUncheckedCreateWithoutCafeInput>
  }

  export type ReviewCreateManyCafeInputEnvelope = {
    data: ReviewCreateManyCafeInput | ReviewCreateManyCafeInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutCafeInput = {
    type: string
    title: string
    content: string
    is_read: boolean
    created_at?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutCafeInput = {
    id?: number
    user_id: bigint | number
    type: string
    title: string
    content: string
    is_read: boolean
    created_at?: Date | string
  }

  export type NotificationCreateOrConnectWithoutCafeInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutCafeInput, NotificationUncheckedCreateWithoutCafeInput>
  }

  export type NotificationCreateManyCafeInputEnvelope = {
    data: NotificationCreateManyCafeInput | NotificationCreateManyCafeInput[]
    skipDuplicates?: boolean
  }

  export type CouponCreateWithoutCafeInput = {
    type: string
    name: string
    status: string
    issued_at: Date | string
    expired_at: Date | string
    used_at: Date | string
    user: UserCreateNestedOneWithoutCouponsInput
  }

  export type CouponUncheckedCreateWithoutCafeInput = {
    id?: number
    user_id: bigint | number
    type: string
    name: string
    status: string
    issued_at: Date | string
    expired_at: Date | string
    used_at: Date | string
  }

  export type CouponCreateOrConnectWithoutCafeInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutCafeInput, CouponUncheckedCreateWithoutCafeInput>
  }

  export type CouponCreateManyCafeInputEnvelope = {
    data: CouponCreateManyCafeInput | CouponCreateManyCafeInput[]
    skipDuplicates?: boolean
  }

  export type CafeMenuUpsertWithWhereUniqueWithoutCafeInput = {
    where: CafeMenuWhereUniqueInput
    update: XOR<CafeMenuUpdateWithoutCafeInput, CafeMenuUncheckedUpdateWithoutCafeInput>
    create: XOR<CafeMenuCreateWithoutCafeInput, CafeMenuUncheckedCreateWithoutCafeInput>
  }

  export type CafeMenuUpdateWithWhereUniqueWithoutCafeInput = {
    where: CafeMenuWhereUniqueInput
    data: XOR<CafeMenuUpdateWithoutCafeInput, CafeMenuUncheckedUpdateWithoutCafeInput>
  }

  export type CafeMenuUpdateManyWithWhereWithoutCafeInput = {
    where: CafeMenuScalarWhereInput
    data: XOR<CafeMenuUpdateManyMutationInput, CafeMenuUncheckedUpdateManyWithoutCafeInput>
  }

  export type CafeMenuScalarWhereInput = {
    AND?: CafeMenuScalarWhereInput | CafeMenuScalarWhereInput[]
    OR?: CafeMenuScalarWhereInput[]
    NOT?: CafeMenuScalarWhereInput | CafeMenuScalarWhereInput[]
    id?: BigIntFilter<"CafeMenu"> | bigint | number
    cafe_id?: BigIntFilter<"CafeMenu"> | bigint | number
    category?: StringFilter<"CafeMenu"> | string
    name?: StringFilter<"CafeMenu"> | string
    description?: StringFilter<"CafeMenu"> | string
    price?: IntFilter<"CafeMenu"> | number
    is_sold_out?: BoolFilter<"CafeMenu"> | boolean
    photo_url?: StringFilter<"CafeMenu"> | string
    created_at?: DateTimeFilter<"CafeMenu"> | Date | string
    updated_at?: DateTimeFilter<"CafeMenu"> | Date | string
  }

  export type CafePhotoUpsertWithWhereUniqueWithoutCafeInput = {
    where: CafePhotoWhereUniqueInput
    update: XOR<CafePhotoUpdateWithoutCafeInput, CafePhotoUncheckedUpdateWithoutCafeInput>
    create: XOR<CafePhotoCreateWithoutCafeInput, CafePhotoUncheckedCreateWithoutCafeInput>
  }

  export type CafePhotoUpdateWithWhereUniqueWithoutCafeInput = {
    where: CafePhotoWhereUniqueInput
    data: XOR<CafePhotoUpdateWithoutCafeInput, CafePhotoUncheckedUpdateWithoutCafeInput>
  }

  export type CafePhotoUpdateManyWithWhereWithoutCafeInput = {
    where: CafePhotoScalarWhereInput
    data: XOR<CafePhotoUpdateManyMutationInput, CafePhotoUncheckedUpdateManyWithoutCafeInput>
  }

  export type CafePhotoScalarWhereInput = {
    AND?: CafePhotoScalarWhereInput | CafePhotoScalarWhereInput[]
    OR?: CafePhotoScalarWhereInput[]
    NOT?: CafePhotoScalarWhereInput | CafePhotoScalarWhereInput[]
    id?: BigIntFilter<"CafePhoto"> | bigint | number
    cafe_id?: BigIntFilter<"CafePhoto"> | bigint | number
    photo_url?: StringFilter<"CafePhoto"> | string
    display_order?: IntFilter<"CafePhoto"> | number
    created_at?: DateTimeFilter<"CafePhoto"> | Date | string
  }

  export type ChallengeAvailableCafeUpsertWithWhereUniqueWithoutCafeInput = {
    where: ChallengeAvailableCafeWhereUniqueInput
    update: XOR<ChallengeAvailableCafeUpdateWithoutCafeInput, ChallengeAvailableCafeUncheckedUpdateWithoutCafeInput>
    create: XOR<ChallengeAvailableCafeCreateWithoutCafeInput, ChallengeAvailableCafeUncheckedCreateWithoutCafeInput>
  }

  export type ChallengeAvailableCafeUpdateWithWhereUniqueWithoutCafeInput = {
    where: ChallengeAvailableCafeWhereUniqueInput
    data: XOR<ChallengeAvailableCafeUpdateWithoutCafeInput, ChallengeAvailableCafeUncheckedUpdateWithoutCafeInput>
  }

  export type ChallengeAvailableCafeUpdateManyWithWhereWithoutCafeInput = {
    where: ChallengeAvailableCafeScalarWhereInput
    data: XOR<ChallengeAvailableCafeUpdateManyMutationInput, ChallengeAvailableCafeUncheckedUpdateManyWithoutCafeInput>
  }

  export type StampBookUpsertWithWhereUniqueWithoutCafeInput = {
    where: StampBookWhereUniqueInput
    update: XOR<StampBookUpdateWithoutCafeInput, StampBookUncheckedUpdateWithoutCafeInput>
    create: XOR<StampBookCreateWithoutCafeInput, StampBookUncheckedCreateWithoutCafeInput>
  }

  export type StampBookUpdateWithWhereUniqueWithoutCafeInput = {
    where: StampBookWhereUniqueInput
    data: XOR<StampBookUpdateWithoutCafeInput, StampBookUncheckedUpdateWithoutCafeInput>
  }

  export type StampBookUpdateManyWithWhereWithoutCafeInput = {
    where: StampBookScalarWhereInput
    data: XOR<StampBookUpdateManyMutationInput, StampBookUncheckedUpdateManyWithoutCafeInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutCafeInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutCafeInput, ReviewUncheckedUpdateWithoutCafeInput>
    create: XOR<ReviewCreateWithoutCafeInput, ReviewUncheckedCreateWithoutCafeInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutCafeInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutCafeInput, ReviewUncheckedUpdateWithoutCafeInput>
  }

  export type ReviewUpdateManyWithWhereWithoutCafeInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutCafeInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutCafeInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutCafeInput, NotificationUncheckedUpdateWithoutCafeInput>
    create: XOR<NotificationCreateWithoutCafeInput, NotificationUncheckedCreateWithoutCafeInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutCafeInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutCafeInput, NotificationUncheckedUpdateWithoutCafeInput>
  }

  export type NotificationUpdateManyWithWhereWithoutCafeInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutCafeInput>
  }

  export type CouponUpsertWithWhereUniqueWithoutCafeInput = {
    where: CouponWhereUniqueInput
    update: XOR<CouponUpdateWithoutCafeInput, CouponUncheckedUpdateWithoutCafeInput>
    create: XOR<CouponCreateWithoutCafeInput, CouponUncheckedCreateWithoutCafeInput>
  }

  export type CouponUpdateWithWhereUniqueWithoutCafeInput = {
    where: CouponWhereUniqueInput
    data: XOR<CouponUpdateWithoutCafeInput, CouponUncheckedUpdateWithoutCafeInput>
  }

  export type CouponUpdateManyWithWhereWithoutCafeInput = {
    where: CouponScalarWhereInput
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyWithoutCafeInput>
  }

  export type CafeCreateWithoutMenuInput = {
    id?: bigint | number
    name: string
    address: string
    region: string
    latitude: number
    longitude: number
    owner_name: string
    business_hours: string
    phone: string
    website_url: string
    description: string
    store_filters: JsonNullValueInput | InputJsonValue
    take_out_filters: JsonNullValueInput | InputJsonValue
    menu_filters: JsonNullValueInput | InputJsonValue
    keywords: JsonNullValueInput | InputJsonValue
    status: $Enums.CafeStatus
    created_at?: Date | string
    updated_at?: Date | string
    photos?: CafePhotoCreateNestedManyWithoutCafeInput
    available_challenges?: ChallengeAvailableCafeCreateNestedManyWithoutCafeInput
    stamp_books?: StampBookCreateNestedManyWithoutCafeInput
    reviews?: ReviewCreateNestedManyWithoutCafeInput
    notifications?: NotificationCreateNestedManyWithoutCafeInput
    coupons?: CouponCreateNestedManyWithoutCafeInput
  }

  export type CafeUncheckedCreateWithoutMenuInput = {
    id?: bigint | number
    name: string
    address: string
    region: string
    latitude: number
    longitude: number
    owner_name: string
    business_hours: string
    phone: string
    website_url: string
    description: string
    store_filters: JsonNullValueInput | InputJsonValue
    take_out_filters: JsonNullValueInput | InputJsonValue
    menu_filters: JsonNullValueInput | InputJsonValue
    keywords: JsonNullValueInput | InputJsonValue
    status: $Enums.CafeStatus
    created_at?: Date | string
    updated_at?: Date | string
    photos?: CafePhotoUncheckedCreateNestedManyWithoutCafeInput
    available_challenges?: ChallengeAvailableCafeUncheckedCreateNestedManyWithoutCafeInput
    stamp_books?: StampBookUncheckedCreateNestedManyWithoutCafeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCafeInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCafeInput
    coupons?: CouponUncheckedCreateNestedManyWithoutCafeInput
  }

  export type CafeCreateOrConnectWithoutMenuInput = {
    where: CafeWhereUniqueInput
    create: XOR<CafeCreateWithoutMenuInput, CafeUncheckedCreateWithoutMenuInput>
  }

  export type CafeUpsertWithoutMenuInput = {
    update: XOR<CafeUpdateWithoutMenuInput, CafeUncheckedUpdateWithoutMenuInput>
    create: XOR<CafeCreateWithoutMenuInput, CafeUncheckedCreateWithoutMenuInput>
    where?: CafeWhereInput
  }

  export type CafeUpdateToOneWithWhereWithoutMenuInput = {
    where?: CafeWhereInput
    data: XOR<CafeUpdateWithoutMenuInput, CafeUncheckedUpdateWithoutMenuInput>
  }

  export type CafeUpdateWithoutMenuInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner_name?: StringFieldUpdateOperationsInput | string
    business_hours?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    store_filters?: JsonNullValueInput | InputJsonValue
    take_out_filters?: JsonNullValueInput | InputJsonValue
    menu_filters?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    status?: EnumCafeStatusFieldUpdateOperationsInput | $Enums.CafeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: CafePhotoUpdateManyWithoutCafeNestedInput
    available_challenges?: ChallengeAvailableCafeUpdateManyWithoutCafeNestedInput
    stamp_books?: StampBookUpdateManyWithoutCafeNestedInput
    reviews?: ReviewUpdateManyWithoutCafeNestedInput
    notifications?: NotificationUpdateManyWithoutCafeNestedInput
    coupons?: CouponUpdateManyWithoutCafeNestedInput
  }

  export type CafeUncheckedUpdateWithoutMenuInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner_name?: StringFieldUpdateOperationsInput | string
    business_hours?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    store_filters?: JsonNullValueInput | InputJsonValue
    take_out_filters?: JsonNullValueInput | InputJsonValue
    menu_filters?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    status?: EnumCafeStatusFieldUpdateOperationsInput | $Enums.CafeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: CafePhotoUncheckedUpdateManyWithoutCafeNestedInput
    available_challenges?: ChallengeAvailableCafeUncheckedUpdateManyWithoutCafeNestedInput
    stamp_books?: StampBookUncheckedUpdateManyWithoutCafeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCafeNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCafeNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutCafeNestedInput
  }

  export type CafeCreateWithoutPhotosInput = {
    id?: bigint | number
    name: string
    address: string
    region: string
    latitude: number
    longitude: number
    owner_name: string
    business_hours: string
    phone: string
    website_url: string
    description: string
    store_filters: JsonNullValueInput | InputJsonValue
    take_out_filters: JsonNullValueInput | InputJsonValue
    menu_filters: JsonNullValueInput | InputJsonValue
    keywords: JsonNullValueInput | InputJsonValue
    status: $Enums.CafeStatus
    created_at?: Date | string
    updated_at?: Date | string
    menu?: CafeMenuCreateNestedManyWithoutCafeInput
    available_challenges?: ChallengeAvailableCafeCreateNestedManyWithoutCafeInput
    stamp_books?: StampBookCreateNestedManyWithoutCafeInput
    reviews?: ReviewCreateNestedManyWithoutCafeInput
    notifications?: NotificationCreateNestedManyWithoutCafeInput
    coupons?: CouponCreateNestedManyWithoutCafeInput
  }

  export type CafeUncheckedCreateWithoutPhotosInput = {
    id?: bigint | number
    name: string
    address: string
    region: string
    latitude: number
    longitude: number
    owner_name: string
    business_hours: string
    phone: string
    website_url: string
    description: string
    store_filters: JsonNullValueInput | InputJsonValue
    take_out_filters: JsonNullValueInput | InputJsonValue
    menu_filters: JsonNullValueInput | InputJsonValue
    keywords: JsonNullValueInput | InputJsonValue
    status: $Enums.CafeStatus
    created_at?: Date | string
    updated_at?: Date | string
    menu?: CafeMenuUncheckedCreateNestedManyWithoutCafeInput
    available_challenges?: ChallengeAvailableCafeUncheckedCreateNestedManyWithoutCafeInput
    stamp_books?: StampBookUncheckedCreateNestedManyWithoutCafeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCafeInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCafeInput
    coupons?: CouponUncheckedCreateNestedManyWithoutCafeInput
  }

  export type CafeCreateOrConnectWithoutPhotosInput = {
    where: CafeWhereUniqueInput
    create: XOR<CafeCreateWithoutPhotosInput, CafeUncheckedCreateWithoutPhotosInput>
  }

  export type CafeUpsertWithoutPhotosInput = {
    update: XOR<CafeUpdateWithoutPhotosInput, CafeUncheckedUpdateWithoutPhotosInput>
    create: XOR<CafeCreateWithoutPhotosInput, CafeUncheckedCreateWithoutPhotosInput>
    where?: CafeWhereInput
  }

  export type CafeUpdateToOneWithWhereWithoutPhotosInput = {
    where?: CafeWhereInput
    data: XOR<CafeUpdateWithoutPhotosInput, CafeUncheckedUpdateWithoutPhotosInput>
  }

  export type CafeUpdateWithoutPhotosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner_name?: StringFieldUpdateOperationsInput | string
    business_hours?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    store_filters?: JsonNullValueInput | InputJsonValue
    take_out_filters?: JsonNullValueInput | InputJsonValue
    menu_filters?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    status?: EnumCafeStatusFieldUpdateOperationsInput | $Enums.CafeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: CafeMenuUpdateManyWithoutCafeNestedInput
    available_challenges?: ChallengeAvailableCafeUpdateManyWithoutCafeNestedInput
    stamp_books?: StampBookUpdateManyWithoutCafeNestedInput
    reviews?: ReviewUpdateManyWithoutCafeNestedInput
    notifications?: NotificationUpdateManyWithoutCafeNestedInput
    coupons?: CouponUpdateManyWithoutCafeNestedInput
  }

  export type CafeUncheckedUpdateWithoutPhotosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner_name?: StringFieldUpdateOperationsInput | string
    business_hours?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    store_filters?: JsonNullValueInput | InputJsonValue
    take_out_filters?: JsonNullValueInput | InputJsonValue
    menu_filters?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    status?: EnumCafeStatusFieldUpdateOperationsInput | $Enums.CafeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: CafeMenuUncheckedUpdateManyWithoutCafeNestedInput
    available_challenges?: ChallengeAvailableCafeUncheckedUpdateManyWithoutCafeNestedInput
    stamp_books?: StampBookUncheckedUpdateManyWithoutCafeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCafeNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCafeNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutCafeNestedInput
  }

  export type UserCreateWithoutReviewsInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountCreateNestedManyWithoutUserInput
    user_agreements?: UserAgreementCreateNestedOneWithoutUserInput
    user_preferences?: UserPreferenceCreateNestedManyWithoutUserInput
    verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    stamp_books?: StampBookCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    coupons?: CouponCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountUncheckedCreateNestedManyWithoutUserInput
    user_agreements?: UserAgreementUncheckedCreateNestedOneWithoutUserInput
    user_preferences?: UserPreferenceUncheckedCreateNestedManyWithoutUserInput
    verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    stamp_books?: StampBookUncheckedCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    coupons?: CouponUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type CafeCreateWithoutReviewsInput = {
    id?: bigint | number
    name: string
    address: string
    region: string
    latitude: number
    longitude: number
    owner_name: string
    business_hours: string
    phone: string
    website_url: string
    description: string
    store_filters: JsonNullValueInput | InputJsonValue
    take_out_filters: JsonNullValueInput | InputJsonValue
    menu_filters: JsonNullValueInput | InputJsonValue
    keywords: JsonNullValueInput | InputJsonValue
    status: $Enums.CafeStatus
    created_at?: Date | string
    updated_at?: Date | string
    menu?: CafeMenuCreateNestedManyWithoutCafeInput
    photos?: CafePhotoCreateNestedManyWithoutCafeInput
    available_challenges?: ChallengeAvailableCafeCreateNestedManyWithoutCafeInput
    stamp_books?: StampBookCreateNestedManyWithoutCafeInput
    notifications?: NotificationCreateNestedManyWithoutCafeInput
    coupons?: CouponCreateNestedManyWithoutCafeInput
  }

  export type CafeUncheckedCreateWithoutReviewsInput = {
    id?: bigint | number
    name: string
    address: string
    region: string
    latitude: number
    longitude: number
    owner_name: string
    business_hours: string
    phone: string
    website_url: string
    description: string
    store_filters: JsonNullValueInput | InputJsonValue
    take_out_filters: JsonNullValueInput | InputJsonValue
    menu_filters: JsonNullValueInput | InputJsonValue
    keywords: JsonNullValueInput | InputJsonValue
    status: $Enums.CafeStatus
    created_at?: Date | string
    updated_at?: Date | string
    menu?: CafeMenuUncheckedCreateNestedManyWithoutCafeInput
    photos?: CafePhotoUncheckedCreateNestedManyWithoutCafeInput
    available_challenges?: ChallengeAvailableCafeUncheckedCreateNestedManyWithoutCafeInput
    stamp_books?: StampBookUncheckedCreateNestedManyWithoutCafeInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCafeInput
    coupons?: CouponUncheckedCreateNestedManyWithoutCafeInput
  }

  export type CafeCreateOrConnectWithoutReviewsInput = {
    where: CafeWhereUniqueInput
    create: XOR<CafeCreateWithoutReviewsInput, CafeUncheckedCreateWithoutReviewsInput>
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUpdateManyWithoutUserNestedInput
    user_agreements?: UserAgreementUpdateOneWithoutUserNestedInput
    user_preferences?: UserPreferenceUpdateManyWithoutUserNestedInput
    verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    coupons?: CouponUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUncheckedUpdateManyWithoutUserNestedInput
    user_agreements?: UserAgreementUncheckedUpdateOneWithoutUserNestedInput
    user_preferences?: UserPreferenceUncheckedUpdateManyWithoutUserNestedInput
    verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUncheckedUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CafeUpsertWithoutReviewsInput = {
    update: XOR<CafeUpdateWithoutReviewsInput, CafeUncheckedUpdateWithoutReviewsInput>
    create: XOR<CafeCreateWithoutReviewsInput, CafeUncheckedCreateWithoutReviewsInput>
    where?: CafeWhereInput
  }

  export type CafeUpdateToOneWithWhereWithoutReviewsInput = {
    where?: CafeWhereInput
    data: XOR<CafeUpdateWithoutReviewsInput, CafeUncheckedUpdateWithoutReviewsInput>
  }

  export type CafeUpdateWithoutReviewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner_name?: StringFieldUpdateOperationsInput | string
    business_hours?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    store_filters?: JsonNullValueInput | InputJsonValue
    take_out_filters?: JsonNullValueInput | InputJsonValue
    menu_filters?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    status?: EnumCafeStatusFieldUpdateOperationsInput | $Enums.CafeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: CafeMenuUpdateManyWithoutCafeNestedInput
    photos?: CafePhotoUpdateManyWithoutCafeNestedInput
    available_challenges?: ChallengeAvailableCafeUpdateManyWithoutCafeNestedInput
    stamp_books?: StampBookUpdateManyWithoutCafeNestedInput
    notifications?: NotificationUpdateManyWithoutCafeNestedInput
    coupons?: CouponUpdateManyWithoutCafeNestedInput
  }

  export type CafeUncheckedUpdateWithoutReviewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner_name?: StringFieldUpdateOperationsInput | string
    business_hours?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    store_filters?: JsonNullValueInput | InputJsonValue
    take_out_filters?: JsonNullValueInput | InputJsonValue
    menu_filters?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    status?: EnumCafeStatusFieldUpdateOperationsInput | $Enums.CafeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: CafeMenuUncheckedUpdateManyWithoutCafeNestedInput
    photos?: CafePhotoUncheckedUpdateManyWithoutCafeNestedInput
    available_challenges?: ChallengeAvailableCafeUncheckedUpdateManyWithoutCafeNestedInput
    stamp_books?: StampBookUncheckedUpdateManyWithoutCafeNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCafeNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutCafeNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountCreateNestedManyWithoutUserInput
    user_agreements?: UserAgreementCreateNestedOneWithoutUserInput
    user_preferences?: UserPreferenceCreateNestedManyWithoutUserInput
    verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    stamp_books?: StampBookCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    coupons?: CouponCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountUncheckedCreateNestedManyWithoutUserInput
    user_agreements?: UserAgreementUncheckedCreateNestedOneWithoutUserInput
    user_preferences?: UserPreferenceUncheckedCreateNestedManyWithoutUserInput
    verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    stamp_books?: StampBookUncheckedCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    coupons?: CouponUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type CafeCreateWithoutNotificationsInput = {
    id?: bigint | number
    name: string
    address: string
    region: string
    latitude: number
    longitude: number
    owner_name: string
    business_hours: string
    phone: string
    website_url: string
    description: string
    store_filters: JsonNullValueInput | InputJsonValue
    take_out_filters: JsonNullValueInput | InputJsonValue
    menu_filters: JsonNullValueInput | InputJsonValue
    keywords: JsonNullValueInput | InputJsonValue
    status: $Enums.CafeStatus
    created_at?: Date | string
    updated_at?: Date | string
    menu?: CafeMenuCreateNestedManyWithoutCafeInput
    photos?: CafePhotoCreateNestedManyWithoutCafeInput
    available_challenges?: ChallengeAvailableCafeCreateNestedManyWithoutCafeInput
    stamp_books?: StampBookCreateNestedManyWithoutCafeInput
    reviews?: ReviewCreateNestedManyWithoutCafeInput
    coupons?: CouponCreateNestedManyWithoutCafeInput
  }

  export type CafeUncheckedCreateWithoutNotificationsInput = {
    id?: bigint | number
    name: string
    address: string
    region: string
    latitude: number
    longitude: number
    owner_name: string
    business_hours: string
    phone: string
    website_url: string
    description: string
    store_filters: JsonNullValueInput | InputJsonValue
    take_out_filters: JsonNullValueInput | InputJsonValue
    menu_filters: JsonNullValueInput | InputJsonValue
    keywords: JsonNullValueInput | InputJsonValue
    status: $Enums.CafeStatus
    created_at?: Date | string
    updated_at?: Date | string
    menu?: CafeMenuUncheckedCreateNestedManyWithoutCafeInput
    photos?: CafePhotoUncheckedCreateNestedManyWithoutCafeInput
    available_challenges?: ChallengeAvailableCafeUncheckedCreateNestedManyWithoutCafeInput
    stamp_books?: StampBookUncheckedCreateNestedManyWithoutCafeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCafeInput
    coupons?: CouponUncheckedCreateNestedManyWithoutCafeInput
  }

  export type CafeCreateOrConnectWithoutNotificationsInput = {
    where: CafeWhereUniqueInput
    create: XOR<CafeCreateWithoutNotificationsInput, CafeUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUpdateManyWithoutUserNestedInput
    user_agreements?: UserAgreementUpdateOneWithoutUserNestedInput
    user_preferences?: UserPreferenceUpdateManyWithoutUserNestedInput
    verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    coupons?: CouponUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUncheckedUpdateManyWithoutUserNestedInput
    user_agreements?: UserAgreementUncheckedUpdateOneWithoutUserNestedInput
    user_preferences?: UserPreferenceUncheckedUpdateManyWithoutUserNestedInput
    verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUncheckedUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CafeUpsertWithoutNotificationsInput = {
    update: XOR<CafeUpdateWithoutNotificationsInput, CafeUncheckedUpdateWithoutNotificationsInput>
    create: XOR<CafeCreateWithoutNotificationsInput, CafeUncheckedCreateWithoutNotificationsInput>
    where?: CafeWhereInput
  }

  export type CafeUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: CafeWhereInput
    data: XOR<CafeUpdateWithoutNotificationsInput, CafeUncheckedUpdateWithoutNotificationsInput>
  }

  export type CafeUpdateWithoutNotificationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner_name?: StringFieldUpdateOperationsInput | string
    business_hours?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    store_filters?: JsonNullValueInput | InputJsonValue
    take_out_filters?: JsonNullValueInput | InputJsonValue
    menu_filters?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    status?: EnumCafeStatusFieldUpdateOperationsInput | $Enums.CafeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: CafeMenuUpdateManyWithoutCafeNestedInput
    photos?: CafePhotoUpdateManyWithoutCafeNestedInput
    available_challenges?: ChallengeAvailableCafeUpdateManyWithoutCafeNestedInput
    stamp_books?: StampBookUpdateManyWithoutCafeNestedInput
    reviews?: ReviewUpdateManyWithoutCafeNestedInput
    coupons?: CouponUpdateManyWithoutCafeNestedInput
  }

  export type CafeUncheckedUpdateWithoutNotificationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner_name?: StringFieldUpdateOperationsInput | string
    business_hours?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    store_filters?: JsonNullValueInput | InputJsonValue
    take_out_filters?: JsonNullValueInput | InputJsonValue
    menu_filters?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    status?: EnumCafeStatusFieldUpdateOperationsInput | $Enums.CafeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: CafeMenuUncheckedUpdateManyWithoutCafeNestedInput
    photos?: CafePhotoUncheckedUpdateManyWithoutCafeNestedInput
    available_challenges?: ChallengeAvailableCafeUncheckedUpdateManyWithoutCafeNestedInput
    stamp_books?: StampBookUncheckedUpdateManyWithoutCafeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCafeNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutCafeNestedInput
  }

  export type UserCreateWithoutCouponsInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountCreateNestedManyWithoutUserInput
    user_agreements?: UserAgreementCreateNestedOneWithoutUserInput
    user_preferences?: UserPreferenceCreateNestedManyWithoutUserInput
    verification_codes?: VerificationCodeCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantCreateNestedManyWithoutUserInput
    badges?: BadgeCreateNestedManyWithoutUserInput
    stamp_books?: StampBookCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCouponsInput = {
    id?: bigint | number
    email?: string | null
    kakao_id?: bigint | number | null
    password_hash?: string | null
    phone_number: string
    nickname: string
    role: $Enums.Role
    allow_kakao_alert: boolean
    status: $Enums.UserStatus
    fcm_token?: string | null
    profile_image_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    kakao_accounts?: KakaoAccountUncheckedCreateNestedManyWithoutUserInput
    user_agreements?: UserAgreementUncheckedCreateNestedOneWithoutUserInput
    user_preferences?: UserPreferenceUncheckedCreateNestedManyWithoutUserInput
    verification_codes?: VerificationCodeUncheckedCreateNestedManyWithoutUserInput
    challenge_participants?: ChallengeParticipantUncheckedCreateNestedManyWithoutUserInput
    badges?: BadgeUncheckedCreateNestedManyWithoutUserInput
    stamp_books?: StampBookUncheckedCreateNestedManyWithoutUserInput
    point_transactions?: PointTransactionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCouponsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCouponsInput, UserUncheckedCreateWithoutCouponsInput>
  }

  export type CafeCreateWithoutCouponsInput = {
    id?: bigint | number
    name: string
    address: string
    region: string
    latitude: number
    longitude: number
    owner_name: string
    business_hours: string
    phone: string
    website_url: string
    description: string
    store_filters: JsonNullValueInput | InputJsonValue
    take_out_filters: JsonNullValueInput | InputJsonValue
    menu_filters: JsonNullValueInput | InputJsonValue
    keywords: JsonNullValueInput | InputJsonValue
    status: $Enums.CafeStatus
    created_at?: Date | string
    updated_at?: Date | string
    menu?: CafeMenuCreateNestedManyWithoutCafeInput
    photos?: CafePhotoCreateNestedManyWithoutCafeInput
    available_challenges?: ChallengeAvailableCafeCreateNestedManyWithoutCafeInput
    stamp_books?: StampBookCreateNestedManyWithoutCafeInput
    reviews?: ReviewCreateNestedManyWithoutCafeInput
    notifications?: NotificationCreateNestedManyWithoutCafeInput
  }

  export type CafeUncheckedCreateWithoutCouponsInput = {
    id?: bigint | number
    name: string
    address: string
    region: string
    latitude: number
    longitude: number
    owner_name: string
    business_hours: string
    phone: string
    website_url: string
    description: string
    store_filters: JsonNullValueInput | InputJsonValue
    take_out_filters: JsonNullValueInput | InputJsonValue
    menu_filters: JsonNullValueInput | InputJsonValue
    keywords: JsonNullValueInput | InputJsonValue
    status: $Enums.CafeStatus
    created_at?: Date | string
    updated_at?: Date | string
    menu?: CafeMenuUncheckedCreateNestedManyWithoutCafeInput
    photos?: CafePhotoUncheckedCreateNestedManyWithoutCafeInput
    available_challenges?: ChallengeAvailableCafeUncheckedCreateNestedManyWithoutCafeInput
    stamp_books?: StampBookUncheckedCreateNestedManyWithoutCafeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCafeInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCafeInput
  }

  export type CafeCreateOrConnectWithoutCouponsInput = {
    where: CafeWhereUniqueInput
    create: XOR<CafeCreateWithoutCouponsInput, CafeUncheckedCreateWithoutCouponsInput>
  }

  export type UserUpsertWithoutCouponsInput = {
    update: XOR<UserUpdateWithoutCouponsInput, UserUncheckedUpdateWithoutCouponsInput>
    create: XOR<UserCreateWithoutCouponsInput, UserUncheckedCreateWithoutCouponsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCouponsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCouponsInput, UserUncheckedUpdateWithoutCouponsInput>
  }

  export type UserUpdateWithoutCouponsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUpdateManyWithoutUserNestedInput
    user_agreements?: UserAgreementUpdateOneWithoutUserNestedInput
    user_preferences?: UserPreferenceUpdateManyWithoutUserNestedInput
    verification_codes?: VerificationCodeUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUpdateManyWithoutUserNestedInput
    badges?: BadgeUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCouponsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    kakao_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    allow_kakao_alert?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    fcm_token?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kakao_accounts?: KakaoAccountUncheckedUpdateManyWithoutUserNestedInput
    user_agreements?: UserAgreementUncheckedUpdateOneWithoutUserNestedInput
    user_preferences?: UserPreferenceUncheckedUpdateManyWithoutUserNestedInput
    verification_codes?: VerificationCodeUncheckedUpdateManyWithoutUserNestedInput
    challenge_participants?: ChallengeParticipantUncheckedUpdateManyWithoutUserNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    stamp_books?: StampBookUncheckedUpdateManyWithoutUserNestedInput
    point_transactions?: PointTransactionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CafeUpsertWithoutCouponsInput = {
    update: XOR<CafeUpdateWithoutCouponsInput, CafeUncheckedUpdateWithoutCouponsInput>
    create: XOR<CafeCreateWithoutCouponsInput, CafeUncheckedCreateWithoutCouponsInput>
    where?: CafeWhereInput
  }

  export type CafeUpdateToOneWithWhereWithoutCouponsInput = {
    where?: CafeWhereInput
    data: XOR<CafeUpdateWithoutCouponsInput, CafeUncheckedUpdateWithoutCouponsInput>
  }

  export type CafeUpdateWithoutCouponsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner_name?: StringFieldUpdateOperationsInput | string
    business_hours?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    store_filters?: JsonNullValueInput | InputJsonValue
    take_out_filters?: JsonNullValueInput | InputJsonValue
    menu_filters?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    status?: EnumCafeStatusFieldUpdateOperationsInput | $Enums.CafeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: CafeMenuUpdateManyWithoutCafeNestedInput
    photos?: CafePhotoUpdateManyWithoutCafeNestedInput
    available_challenges?: ChallengeAvailableCafeUpdateManyWithoutCafeNestedInput
    stamp_books?: StampBookUpdateManyWithoutCafeNestedInput
    reviews?: ReviewUpdateManyWithoutCafeNestedInput
    notifications?: NotificationUpdateManyWithoutCafeNestedInput
  }

  export type CafeUncheckedUpdateWithoutCouponsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner_name?: StringFieldUpdateOperationsInput | string
    business_hours?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    store_filters?: JsonNullValueInput | InputJsonValue
    take_out_filters?: JsonNullValueInput | InputJsonValue
    menu_filters?: JsonNullValueInput | InputJsonValue
    keywords?: JsonNullValueInput | InputJsonValue
    status?: EnumCafeStatusFieldUpdateOperationsInput | $Enums.CafeStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: CafeMenuUncheckedUpdateManyWithoutCafeNestedInput
    photos?: CafePhotoUncheckedUpdateManyWithoutCafeNestedInput
    available_challenges?: ChallengeAvailableCafeUncheckedUpdateManyWithoutCafeNestedInput
    stamp_books?: StampBookUncheckedUpdateManyWithoutCafeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCafeNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCafeNestedInput
  }

  export type KakaoAccountCreateManyUserInput = {
    id?: bigint | number
    social_id: string
    created_at?: Date | string
  }

  export type UserPreferenceCreateManyUserInput = {
    id?: bigint | number
    preferred_area: string
    preferred_keywords: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type VerificationCodeCreateManyUserInput = {
    id?: bigint | number
    phone_number: string
    code: string
    expires_at: Date | string
    verified: boolean
    created_at?: Date | string
  }

  export type ChallengeParticipantCreateManyUserInput = {
    id?: number
    challenge_id: number
    status: string
    joined_at: Date | string
    completed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BadgeCreateManyUserInput = {
    id?: number
    challenge_id: number
    badge_type_id: number
    earned_at?: Date | string
  }

  export type StampBookCreateManyUserInput = {
    id?: number
    cafe_id: bigint | number
    current_count: number
    goal_count: number
    reward_detail: string
    started_at: Date | string
    last_visited_at: Date | string
    expires_at: Date | string
    extended_at: Date | string
    expired_at: Date | string
    completed_at: Date | string
    converted_at: Date | string
    status: string
    is_completed: boolean
    is_converted: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PointTransactionCreateManyUserInput = {
    id?: number
    stamp_book_id: number
    point: number
    type: string
    description: string
    created_at?: Date | string
  }

  export type ReviewCreateManyUserInput = {
    id?: number
    cafe_id: bigint | number
    title: string
    content: string
    images: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    cafe_id: bigint | number
    type: string
    title: string
    content: string
    is_read: boolean
    created_at?: Date | string
  }

  export type CouponCreateManyUserInput = {
    id?: number
    cafe_id: bigint | number
    type: string
    name: string
    status: string
    issued_at: Date | string
    expired_at: Date | string
    used_at: Date | string
  }

  export type KakaoAccountUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    social_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KakaoAccountUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    social_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KakaoAccountUncheckedUpdateManyWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    social_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferenceUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_area?: StringFieldUpdateOperationsInput | string
    preferred_keywords?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferenceUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_area?: StringFieldUpdateOperationsInput | string
    preferred_keywords?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferenceUncheckedUpdateManyWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_area?: StringFieldUpdateOperationsInput | string
    preferred_keywords?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCodeUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone_number?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCodeUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone_number?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCodeUncheckedUpdateManyWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone_number?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeParticipantUpdateWithoutUserInput = {
    status?: StringFieldUpdateOperationsInput | string
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    challenge?: ChallengeUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ChallengeParticipantUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    challenge_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    challenge_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUpdateWithoutUserInput = {
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    challenge?: ChallengeUpdateOneRequiredWithoutBadgesNestedInput
    badge_type?: BadgeTypeUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type BadgeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    challenge_id?: IntFieldUpdateOperationsInput | number
    badge_type_id?: IntFieldUpdateOperationsInput | number
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    challenge_id?: IntFieldUpdateOperationsInput | number
    badge_type_id?: IntFieldUpdateOperationsInput | number
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StampBookUpdateWithoutUserInput = {
    current_count?: IntFieldUpdateOperationsInput | number
    goal_count?: IntFieldUpdateOperationsInput | number
    reward_detail?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_visited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    extended_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    converted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    is_converted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cafe?: CafeUpdateOneRequiredWithoutStamp_booksNestedInput
    stamps?: StampUpdateManyWithoutStamp_bookNestedInput
    point_transactions?: PointTransactionUpdateManyWithoutStamp_bookNestedInput
  }

  export type StampBookUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    current_count?: IntFieldUpdateOperationsInput | number
    goal_count?: IntFieldUpdateOperationsInput | number
    reward_detail?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_visited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    extended_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    converted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    is_converted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stamps?: StampUncheckedUpdateManyWithoutStamp_bookNestedInput
    point_transactions?: PointTransactionUncheckedUpdateManyWithoutStamp_bookNestedInput
  }

  export type StampBookUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    current_count?: IntFieldUpdateOperationsInput | number
    goal_count?: IntFieldUpdateOperationsInput | number
    reward_detail?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_visited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    extended_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    converted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    is_converted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointTransactionUpdateWithoutUserInput = {
    point?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stamp_book?: StampBookUpdateOneRequiredWithoutPoint_transactionsNestedInput
  }

  export type PointTransactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    stamp_book_id?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointTransactionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    stamp_book_id?: IntFieldUpdateOperationsInput | number
    point?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cafe?: CafeUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cafe?: CafeUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cafe?: CafeUpdateOneRequiredWithoutCouponsNestedInput
  }

  export type CouponUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeParticipantCreateManyChallengeInput = {
    id?: number
    user_id: bigint | number
    status: string
    joined_at: Date | string
    completed_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChallengeAvailableCafeCreateManyChallengeInput = {
    id?: number
    cafe_id: bigint | number
    created_at?: Date | string
  }

  export type BadgeCreateManyChallengeInput = {
    id?: number
    user_id: bigint | number
    badge_type_id: number
    earned_at?: Date | string
  }

  export type ChallengeParticipantUpdateWithoutChallengeInput = {
    status?: StringFieldUpdateOperationsInput | string
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChallenge_participantsNestedInput
  }

  export type ChallengeParticipantUncheckedUpdateWithoutChallengeInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeParticipantUncheckedUpdateManyWithoutChallengeInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: StringFieldUpdateOperationsInput | string
    joined_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeAvailableCafeUpdateWithoutChallengeInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cafe?: CafeUpdateOneRequiredWithoutAvailable_challengesNestedInput
  }

  export type ChallengeAvailableCafeUncheckedUpdateWithoutChallengeInput = {
    id?: IntFieldUpdateOperationsInput | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeAvailableCafeUncheckedUpdateManyWithoutChallengeInput = {
    id?: IntFieldUpdateOperationsInput | number
    cafe_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUpdateWithoutChallengeInput = {
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBadgesNestedInput
    badge_type?: BadgeTypeUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type BadgeUncheckedUpdateWithoutChallengeInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    badge_type_id?: IntFieldUpdateOperationsInput | number
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateManyWithoutChallengeInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    badge_type_id?: IntFieldUpdateOperationsInput | number
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeCreateManyBadge_typeInput = {
    id?: number
    user_id: bigint | number
    challenge_id: number
    earned_at?: Date | string
  }

  export type BadgeUpdateWithoutBadge_typeInput = {
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBadgesNestedInput
    challenge?: ChallengeUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type BadgeUncheckedUpdateWithoutBadge_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    challenge_id?: IntFieldUpdateOperationsInput | number
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateManyWithoutBadge_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    challenge_id?: IntFieldUpdateOperationsInput | number
    earned_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StampCreateManyStamp_bookInput = {
    id?: number
    stamp_image_url: string
    stamped_at?: Date | string
    source: string
    note: string
    latitude: number
    longitude: number
  }

  export type PointTransactionCreateManyStamp_bookInput = {
    id?: number
    user_id: bigint | number
    point: number
    type: string
    description: string
    created_at?: Date | string
  }

  export type StampUpdateWithoutStamp_bookInput = {
    stamp_image_url?: StringFieldUpdateOperationsInput | string
    stamped_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type StampUncheckedUpdateWithoutStamp_bookInput = {
    id?: IntFieldUpdateOperationsInput | number
    stamp_image_url?: StringFieldUpdateOperationsInput | string
    stamped_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type StampUncheckedUpdateManyWithoutStamp_bookInput = {
    id?: IntFieldUpdateOperationsInput | number
    stamp_image_url?: StringFieldUpdateOperationsInput | string
    stamped_at?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type PointTransactionUpdateWithoutStamp_bookInput = {
    point?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPoint_transactionsNestedInput
  }

  export type PointTransactionUncheckedUpdateWithoutStamp_bookInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    point?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointTransactionUncheckedUpdateManyWithoutStamp_bookInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    point?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeMenuCreateManyCafeInput = {
    id?: bigint | number
    category: string
    name: string
    description: string
    price: number
    is_sold_out: boolean
    photo_url: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CafePhotoCreateManyCafeInput = {
    id?: bigint | number
    photo_url: string
    display_order: number
    created_at?: Date | string
  }

  export type ChallengeAvailableCafeCreateManyCafeInput = {
    id?: number
    challenge_id: number
    created_at?: Date | string
  }

  export type StampBookCreateManyCafeInput = {
    id?: number
    user_id: bigint | number
    current_count: number
    goal_count: number
    reward_detail: string
    started_at: Date | string
    last_visited_at: Date | string
    expires_at: Date | string
    extended_at: Date | string
    expired_at: Date | string
    completed_at: Date | string
    converted_at: Date | string
    status: string
    is_completed: boolean
    is_converted: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ReviewCreateManyCafeInput = {
    id?: number
    user_id: bigint | number
    title: string
    content: string
    images: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type NotificationCreateManyCafeInput = {
    id?: number
    user_id: bigint | number
    type: string
    title: string
    content: string
    is_read: boolean
    created_at?: Date | string
  }

  export type CouponCreateManyCafeInput = {
    id?: number
    user_id: bigint | number
    type: string
    name: string
    status: string
    issued_at: Date | string
    expired_at: Date | string
    used_at: Date | string
  }

  export type CafeMenuUpdateWithoutCafeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    is_sold_out?: BoolFieldUpdateOperationsInput | boolean
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeMenuUncheckedUpdateWithoutCafeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    is_sold_out?: BoolFieldUpdateOperationsInput | boolean
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafeMenuUncheckedUpdateManyWithoutCafeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    is_sold_out?: BoolFieldUpdateOperationsInput | boolean
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafePhotoUpdateWithoutCafeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    photo_url?: StringFieldUpdateOperationsInput | string
    display_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafePhotoUncheckedUpdateWithoutCafeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    photo_url?: StringFieldUpdateOperationsInput | string
    display_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CafePhotoUncheckedUpdateManyWithoutCafeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    photo_url?: StringFieldUpdateOperationsInput | string
    display_order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeAvailableCafeUpdateWithoutCafeInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    challenge?: ChallengeUpdateOneRequiredWithoutAvailable_cafesNestedInput
  }

  export type ChallengeAvailableCafeUncheckedUpdateWithoutCafeInput = {
    id?: IntFieldUpdateOperationsInput | number
    challenge_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeAvailableCafeUncheckedUpdateManyWithoutCafeInput = {
    id?: IntFieldUpdateOperationsInput | number
    challenge_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StampBookUpdateWithoutCafeInput = {
    current_count?: IntFieldUpdateOperationsInput | number
    goal_count?: IntFieldUpdateOperationsInput | number
    reward_detail?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_visited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    extended_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    converted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    is_converted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStamp_booksNestedInput
    stamps?: StampUpdateManyWithoutStamp_bookNestedInput
    point_transactions?: PointTransactionUpdateManyWithoutStamp_bookNestedInput
  }

  export type StampBookUncheckedUpdateWithoutCafeInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    current_count?: IntFieldUpdateOperationsInput | number
    goal_count?: IntFieldUpdateOperationsInput | number
    reward_detail?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_visited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    extended_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    converted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    is_converted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stamps?: StampUncheckedUpdateManyWithoutStamp_bookNestedInput
    point_transactions?: PointTransactionUncheckedUpdateManyWithoutStamp_bookNestedInput
  }

  export type StampBookUncheckedUpdateManyWithoutCafeInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    current_count?: IntFieldUpdateOperationsInput | number
    goal_count?: IntFieldUpdateOperationsInput | number
    reward_detail?: StringFieldUpdateOperationsInput | string
    started_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_visited_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    extended_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    completed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    converted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    is_completed?: BoolFieldUpdateOperationsInput | boolean
    is_converted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutCafeInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutCafeInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutCafeInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutCafeInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutCafeInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutCafeInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUpdateWithoutCafeInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCouponsNestedInput
  }

  export type CouponUncheckedUpdateWithoutCafeInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateManyWithoutCafeInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issued_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}